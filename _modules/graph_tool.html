<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>graph_tool &mdash; graph-tool 2.2.44 documentation</title>
    
    <link rel="stylesheet" href="../_static/gt_style.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.2.44',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/MathJax/MathJax.js?config=default"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within graph-tool 2.2.44 documentation"
          href="../_static/opensearch.xml"/>
    <link rel="shortcut icon" href="../_static/graph-icon.ico"/>
    <link rel="top" title="graph-tool 2.2.44 documentation" href="../index.html" />
    <link rel="up" title="Module code" href="index.html" />
    <script type="text/javascript">
      var _gaq = _gaq || [];
      var pluginUrl =
        '//www.google-analytics.com/plugins/ga/inpage_linkid.js';
      _gaq.push(['_require', 'inpage_linkid', pluginUrl]);
      _gaq.push(['_setAccount', 'UA-248813-2']);
      _gaq.push(['_setDomainName', '.skewed.de']);
      _gaq.push(['_trackPageview']);
      (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
     

  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
    <li><img src="../_static/graph-icon.png" alt="logo" style="margin-right: 5px; margin-bottom:-2px;" /><a href="/">Project Homepage</a> &raquo;</li>
    
        <li class="nav-item nav-item-0"><a href="../index.html">graph-tool 2.2.44 documentation</a> &raquo;</li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for graph_tool</h1><div class="highlight"><pre>
<span class="c">#! /usr/bin/env python</span>
<span class="c"># -*- coding: utf-8 -*-</span>
<span class="c">#</span>
<span class="c"># graph_tool -- a general graph manipulation python module</span>
<span class="c">#</span>
<span class="c"># Copyright (C) 2006-2015 Tiago de Paula Peixoto &lt;tiago@skewed.de&gt;</span>
<span class="c">#</span>
<span class="c"># This program is free software: you can redistribute it and/or modify</span>
<span class="c"># it under the terms of the GNU General Public License as published by</span>
<span class="c"># the Free Software Foundation, either version 3 of the License, or</span>
<span class="c"># (at your option) any later version.</span>
<span class="c">#</span>
<span class="c"># This program is distributed in the hope that it will be useful,</span>
<span class="c"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c"># GNU General Public License for more details.</span>
<span class="c">#</span>
<span class="c"># You should have received a copy of the GNU General Public License</span>
<span class="c"># along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">graph_tool - efficient graph analysis and manipulation</span>
<span class="sd">======================================================</span>

<span class="sd">Summary</span>
<span class="sd">-------</span>

<span class="sd">.. autosummary::</span>
<span class="sd">   :nosignatures:</span>

<span class="sd">   Graph</span>
<span class="sd">   GraphView</span>
<span class="sd">   Vertex</span>
<span class="sd">   Edge</span>
<span class="sd">   PropertyMap</span>
<span class="sd">   PropertyArray</span>
<span class="sd">   load_graph</span>
<span class="sd">   group_vector_property</span>
<span class="sd">   ungroup_vector_property</span>
<span class="sd">   infect_vertex_property</span>
<span class="sd">   edge_endpoint_property</span>
<span class="sd">   incident_edges_op</span>
<span class="sd">   perfect_prop_hash</span>
<span class="sd">   value_types</span>
<span class="sd">   show_config</span>


<span class="sd">This module provides:</span>

<span class="sd">   1. A :class:`~graph_tool.Graph` class for graph representation and manipulation</span>
<span class="sd">   2. Property maps for Vertex, Edge or Graph.</span>
<span class="sd">   3. Fast algorithms implemented in C++.</span>

<span class="sd">How to use the documentation</span>
<span class="sd">----------------------------</span>

<span class="sd">Documentation is available in two forms: docstrings provided</span>
<span class="sd">with the code, and the full documentation available in</span>
<span class="sd">`the graph-tool homepage &lt;http://graph-tool.skewed.de&gt;`_.</span>

<span class="sd">We recommend exploring the docstrings using `IPython</span>
<span class="sd">&lt;http://ipython.scipy.org&gt;`_, an advanced Python shell with TAB-completion and</span>
<span class="sd">introspection capabilities.</span>

<span class="sd">The docstring examples assume that ``graph_tool.all`` has been imported as</span>
<span class="sd">``gt``::</span>

<span class="sd">   &gt;&gt;&gt; import graph_tool.all as gt</span>

<span class="sd">Code snippets are indicated by three greater-than signs::</span>

<span class="sd">   &gt;&gt;&gt; x = x + 1</span>

<span class="sd">Use the built-in ``help`` function to view a function&#39;s docstring::</span>

<span class="sd">   &gt;&gt;&gt; help(gt.Graph)</span>

<span class="sd">Contents</span>
<span class="sd">--------</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span><span class="p">,</span> <span class="n">absolute_import</span><span class="p">,</span> <span class="n">print_function</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">3</span><span class="p">,):</span>
    <span class="nb">range</span> <span class="o">=</span> <span class="nb">xrange</span>

<span class="n">__author__</span> <span class="o">=</span> <span class="s">&quot;Tiago de Paula Peixoto &lt;tiago@skewed.de&gt;&quot;</span>
<span class="n">__copyright__</span> <span class="o">=</span> <span class="s">&quot;Copyright 2006-2015 Tiago de Paula Peixoto&quot;</span>
<span class="n">__license__</span> <span class="o">=</span> <span class="s">&quot;GPL version 3 or above&quot;</span>
<span class="n">__URL__</span> <span class="o">=</span> <span class="s">&quot;http://graph-tool.skewed.de&quot;</span>

<span class="c"># import numpy and scipy before everything to avoid weird segmentation faults</span>
<span class="c"># depending on the order things are imported.</span>

<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">import</span> <span class="nn">numpy.ma</span>
<span class="kn">import</span> <span class="nn">scipy</span>
<span class="kn">import</span> <span class="nn">scipy.stats</span>


<span class="kn">from</span> <span class="nn">.dl_import</span> <span class="kn">import</span> <span class="o">*</span>
<span class="n">dl_import</span><span class="p">(</span><span class="s">&quot;from . import libgraph_tool_core as libcore&quot;</span><span class="p">)</span>
<span class="n">__version__</span> <span class="o">=</span> <span class="n">libcore</span><span class="o">.</span><span class="n">mod_info</span><span class="p">()</span><span class="o">.</span><span class="n">version</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">io</span>  <span class="c"># sets up libcore io routines</span>

<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">gzip</span>
<span class="kn">import</span> <span class="nn">weakref</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">textwrap</span>
<span class="kn">import</span> <span class="nn">io</span>

<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">3</span><span class="p">,):</span>
    <span class="kn">import</span> <span class="nn">StringIO</span>

<span class="kn">from</span> <span class="nn">.decorators</span> <span class="kn">import</span> <span class="n">_wraps</span><span class="p">,</span> <span class="n">_require</span><span class="p">,</span> <span class="n">_attrs</span><span class="p">,</span> <span class="n">_limit_args</span>
<span class="kn">from</span> <span class="nn">inspect</span> <span class="kn">import</span> <span class="n">ismethod</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;Graph&quot;</span><span class="p">,</span> <span class="s">&quot;GraphView&quot;</span><span class="p">,</span> <span class="s">&quot;Vertex&quot;</span><span class="p">,</span> <span class="s">&quot;Edge&quot;</span><span class="p">,</span> <span class="s">&quot;Vector_bool&quot;</span><span class="p">,</span>
           <span class="s">&quot;Vector_int16_t&quot;</span><span class="p">,</span> <span class="s">&quot;Vector_int32_t&quot;</span><span class="p">,</span> <span class="s">&quot;Vector_int64_t&quot;</span><span class="p">,</span>
           <span class="s">&quot;Vector_double&quot;</span><span class="p">,</span> <span class="s">&quot;Vector_long_double&quot;</span><span class="p">,</span> <span class="s">&quot;Vector_string&quot;</span><span class="p">,</span>
           <span class="s">&quot;Vector_size_t&quot;</span><span class="p">,</span> <span class="s">&quot;value_types&quot;</span><span class="p">,</span> <span class="s">&quot;load_graph&quot;</span><span class="p">,</span> <span class="s">&quot;PropertyMap&quot;</span><span class="p">,</span>
           <span class="s">&quot;group_vector_property&quot;</span><span class="p">,</span> <span class="s">&quot;ungroup_vector_property&quot;</span><span class="p">,</span>
           <span class="s">&quot;infect_vertex_property&quot;</span><span class="p">,</span> <span class="s">&quot;edge_endpoint_property&quot;</span><span class="p">,</span>
           <span class="s">&quot;incident_edges_op&quot;</span><span class="p">,</span> <span class="s">&quot;perfect_prop_hash&quot;</span><span class="p">,</span> <span class="s">&quot;seed_rng&quot;</span><span class="p">,</span> <span class="s">&quot;show_config&quot;</span><span class="p">,</span>
           <span class="s">&quot;PropertyArray&quot;</span><span class="p">,</span> <span class="s">&quot;openmp_enabled&quot;</span><span class="p">,</span> <span class="s">&quot;openmp_get_num_threads&quot;</span><span class="p">,</span>
           <span class="s">&quot;openmp_set_num_threads&quot;</span><span class="p">,</span> <span class="s">&quot;openmp_get_schedule&quot;</span><span class="p">,</span>
           <span class="s">&quot;openmp_set_schedule&quot;</span><span class="p">,</span> <span class="s">&quot;__author__&quot;</span><span class="p">,</span> <span class="s">&quot;__copyright__&quot;</span><span class="p">,</span> <span class="s">&quot;__URL__&quot;</span><span class="p">,</span>
           <span class="s">&quot;__version__&quot;</span><span class="p">]</span>

<span class="c"># this is rather pointless, but it works around a sphinx bug</span>
<span class="n">graph_tool</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">__name__</span><span class="p">]</span>

<span class="c">################################################################################</span>
<span class="c"># Utility functions</span>
<span class="c">################################################################################</span>


<span class="k">def</span> <span class="nf">_prop</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">prop</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return either a property map, or an internal property map with a given</span>
<span class="sd">    name.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">prop</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">pmap</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">properties</span><span class="p">[(</span><span class="n">t</span><span class="p">,</span> <span class="n">prop</span><span class="p">)]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s">&quot;no internal </span><span class="si">%s</span><span class="s"> property named: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span>\
                           <span class="p">(</span><span class="s">&quot;vertex&quot;</span> <span class="k">if</span> <span class="n">t</span> <span class="o">==</span> <span class="s">&quot;v&quot;</span> <span class="k">else</span> \
                            <span class="p">(</span><span class="s">&quot;edge&quot;</span> <span class="k">if</span> <span class="n">t</span> <span class="o">==</span> <span class="s">&quot;e&quot;</span> <span class="k">else</span> <span class="s">&quot;graph&quot;</span><span class="p">),</span> <span class="n">prop</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">pmap</span> <span class="o">=</span> <span class="n">prop</span>
    <span class="k">if</span> <span class="n">pmap</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">libcore</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">t</span> <span class="o">!=</span> <span class="n">prop</span><span class="o">.</span><span class="n">key_type</span><span class="p">():</span>
            <span class="n">names</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;e&#39;</span><span class="p">:</span> <span class="s">&#39;edge&#39;</span><span class="p">,</span> <span class="s">&#39;v&#39;</span><span class="p">:</span> <span class="s">&#39;vertex&#39;</span><span class="p">,</span> <span class="s">&#39;g&#39;</span><span class="p">:</span> <span class="s">&#39;graph&#39;</span><span class="p">}</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Expected &#39;</span><span class="si">%s</span><span class="s">&#39; property map, got &#39;</span><span class="si">%s</span><span class="s">&#39;&quot;</span> <span class="o">%</span>
                             <span class="p">(</span><span class="n">names</span><span class="p">[</span><span class="n">t</span><span class="p">],</span> <span class="n">names</span><span class="p">[</span><span class="n">prop</span><span class="o">.</span><span class="n">key_type</span><span class="p">()]))</span>
        <span class="k">return</span> <span class="n">pmap</span><span class="o">.</span><span class="n">_PropertyMap__map</span><span class="o">.</span><span class="n">get_map</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">_degree</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Retrieve the degree type from string, or returns the corresponding</span>
<span class="sd">    property map.&quot;&quot;&quot;</span>
    <span class="n">deg</span> <span class="o">=</span> <span class="n">name</span>
    <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&quot;in-degree&quot;</span> <span class="ow">or</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&quot;in&quot;</span><span class="p">:</span>
        <span class="n">deg</span> <span class="o">=</span> <span class="n">libcore</span><span class="o">.</span><span class="n">Degree</span><span class="o">.</span><span class="n">In</span>
    <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&quot;out-degree&quot;</span> <span class="ow">or</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&quot;out&quot;</span><span class="p">:</span>
        <span class="n">deg</span> <span class="o">=</span> <span class="n">libcore</span><span class="o">.</span><span class="n">Degree</span><span class="o">.</span><span class="n">Out</span>
    <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&quot;total-degree&quot;</span> <span class="ow">or</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&quot;total&quot;</span><span class="p">:</span>
        <span class="n">deg</span> <span class="o">=</span> <span class="n">libcore</span><span class="o">.</span><span class="n">Degree</span><span class="o">.</span><span class="n">Total</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">deg</span> <span class="o">=</span> <span class="n">_prop</span><span class="p">(</span><span class="s">&quot;v&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">deg</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">deg</span>


<span class="k">def</span> <span class="nf">_type_alias</span><span class="p">(</span><span class="n">type_name</span><span class="p">):</span>
    <span class="n">alias</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;int8_t&quot;</span><span class="p">:</span> <span class="s">&quot;bool&quot;</span><span class="p">,</span>
             <span class="s">&quot;boolean&quot;</span><span class="p">:</span> <span class="s">&quot;bool&quot;</span><span class="p">,</span>
             <span class="s">&quot;short&quot;</span><span class="p">:</span> <span class="s">&quot;int16_t&quot;</span><span class="p">,</span>
             <span class="s">&quot;int&quot;</span><span class="p">:</span> <span class="s">&quot;int32_t&quot;</span><span class="p">,</span>
             <span class="s">&quot;long&quot;</span><span class="p">:</span> <span class="s">&quot;int64_t&quot;</span><span class="p">,</span>
             <span class="s">&quot;long long&quot;</span><span class="p">:</span> <span class="s">&quot;int64_t&quot;</span><span class="p">,</span>
             <span class="s">&quot;unsigned long&quot;</span><span class="p">:</span> <span class="s">&quot;int64_t&quot;</span><span class="p">,</span>
             <span class="s">&quot;object&quot;</span><span class="p">:</span> <span class="s">&quot;python::object&quot;</span><span class="p">,</span>
             <span class="s">&quot;float&quot;</span><span class="p">:</span> <span class="s">&quot;double&quot;</span><span class="p">}</span>
    <span class="k">if</span> <span class="n">type_name</span> <span class="ow">in</span> <span class="n">value_types</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">type_name</span>
    <span class="k">if</span> <span class="n">type_name</span> <span class="ow">in</span> <span class="n">alias</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">alias</span><span class="p">[</span><span class="n">type_name</span><span class="p">]</span>
    <span class="n">ma</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">r&quot;vector&lt;(.*)&gt;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">type_name</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ma</span><span class="p">:</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">alias</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">&quot;vector&lt;</span><span class="si">%s</span><span class="s">&gt;&quot;</span> <span class="o">%</span> <span class="n">alias</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;invalid property value type: &quot;</span> <span class="o">+</span> <span class="n">type_name</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_python_type</span><span class="p">(</span><span class="n">type_name</span><span class="p">):</span>
    <span class="n">type_name</span> <span class="o">=</span> <span class="n">_type_alias</span><span class="p">(</span><span class="n">type_name</span><span class="p">)</span>
    <span class="k">if</span> <span class="s">&quot;vector&quot;</span> <span class="ow">in</span> <span class="n">type_name</span><span class="p">:</span>
        <span class="n">ma</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">r&quot;vector&lt;(.*)&gt;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">type_name</span><span class="p">)</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">,</span> <span class="n">_python_type</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="k">if</span> <span class="s">&quot;int&quot;</span> <span class="ow">in</span> <span class="n">type_name</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">int</span>
    <span class="k">if</span> <span class="n">type_name</span> <span class="o">==</span> <span class="s">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">bool</span>
    <span class="k">if</span> <span class="s">&quot;double&quot;</span> <span class="ow">in</span> <span class="n">type_name</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">float</span>
    <span class="k">if</span> <span class="s">&quot;string&quot;</span> <span class="ow">in</span> <span class="n">type_name</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">str</span>
    <span class="k">return</span> <span class="nb">object</span>


<span class="k">def</span> <span class="nf">_gt_type</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="n">t</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">t</span> <span class="ow">is</span> <span class="n">numpy</span><span class="o">.</span><span class="n">longlong</span> <span class="ow">or</span> <span class="n">t</span> <span class="ow">is</span> <span class="n">numpy</span><span class="o">.</span><span class="n">uint64</span><span class="p">:</span>
        <span class="k">return</span> <span class="s">&quot;long long&quot;</span>
    <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">int16</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;short&quot;</span>
    <span class="k">if</span> <span class="n">t</span> <span class="ow">is</span> <span class="nb">int</span> <span class="ow">or</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">int</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;int&quot;</span>
    <span class="k">if</span> <span class="n">t</span> <span class="ow">is</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float128</span><span class="p">:</span>
        <span class="k">return</span> <span class="s">&quot;long double&quot;</span>
    <span class="k">if</span> <span class="n">t</span> <span class="ow">is</span> <span class="nb">float</span> <span class="ow">or</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;double&quot;</span>
    <span class="k">if</span> <span class="n">t</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="s">&quot;string&quot;</span>
    <span class="k">if</span> <span class="n">t</span> <span class="ow">is</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="s">&quot;bool&quot;</span>
    <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;vector&lt;</span><span class="si">%s</span><span class="s">&gt;&quot;</span> <span class="o">%</span> <span class="n">_gt_type</span><span class="p">(</span><span class="n">obj</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">return</span> <span class="s">&quot;object&quot;</span>


<span class="k">def</span> <span class="nf">_convert</span><span class="p">(</span><span class="n">prop</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
    <span class="c"># attempt to convert to a compatible python type. This is useful,</span>
    <span class="c"># for instance, when dealing with numpy types.</span>
    <span class="n">vtype</span> <span class="o">=</span> <span class="n">_python_type</span><span class="p">(</span><span class="n">prop</span><span class="o">.</span><span class="n">value_type</span><span class="p">())</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">vtype</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">tuple</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">vtype</span><span class="p">[</span><span class="mi">1</span><span class="p">](</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">val</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">vtype</span> <span class="ow">is</span> <span class="nb">object</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">val</span>
    <span class="k">return</span> <span class="n">vtype</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>


<div class="viewcode-block" id="show_config"><a class="viewcode-back" href="../graph_tool.html#graph_tool.show_config">[docs]</a><span class="k">def</span> <span class="nf">show_config</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Show ``graph_tool`` build configuration.&quot;&quot;&quot;</span>
    <span class="n">info</span> <span class="o">=</span> <span class="n">libcore</span><span class="o">.</span><span class="n">mod_info</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&quot;version:&quot;</span><span class="p">,</span> <span class="n">info</span><span class="o">.</span><span class="n">version</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&quot;gcc version:&quot;</span><span class="p">,</span> <span class="n">info</span><span class="o">.</span><span class="n">gcc_version</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&quot;compilation flags:&quot;</span><span class="p">,</span> <span class="n">info</span><span class="o">.</span><span class="n">cxxflags</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&quot;install prefix:&quot;</span><span class="p">,</span> <span class="n">info</span><span class="o">.</span><span class="n">install_prefix</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&quot;python dir:&quot;</span><span class="p">,</span> <span class="n">info</span><span class="o">.</span><span class="n">python_dir</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&quot;graph filtering:&quot;</span><span class="p">,</span> <span class="n">libcore</span><span class="o">.</span><span class="n">graph_filtering_enabled</span><span class="p">())</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&quot;openmp:&quot;</span><span class="p">,</span> <span class="n">libcore</span><span class="o">.</span><span class="n">openmp_enabled</span><span class="p">())</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&quot;uname:&quot;</span><span class="p">,</span> <span class="s">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">uname</span><span class="p">()))</span>
</div>
<span class="k">def</span> <span class="nf">terminal_size</span><span class="p">():</span>
    <span class="kn">import</span> <span class="nn">fcntl</span><span class="o">,</span> <span class="nn">termios</span><span class="o">,</span> <span class="nn">struct</span>
    <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">hp</span><span class="p">,</span> <span class="n">wp</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s">&#39;HHHH&#39;</span><span class="p">,</span>
        <span class="n">fcntl</span><span class="o">.</span><span class="n">ioctl</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">termios</span><span class="o">.</span><span class="n">TIOCGWINSZ</span><span class="p">,</span>
        <span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s">&#39;HHHH&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span>

<span class="c">################################################################################</span>
<span class="c"># Property Maps</span>
<span class="c">################################################################################</span>


<div class="viewcode-block" id="PropertyArray"><a class="viewcode-back" href="../graph_tool.html#graph_tool.PropertyArray">[docs]</a><span class="k">class</span> <span class="nc">PropertyArray</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This is a :class:`~numpy.ndarray` subclass which keeps a reference of its :class:`~graph_tool.PropertyMap` owner, and detects if the underlying data has been invalidated.&quot;&quot;&quot;</span>

    <span class="n">__array_priority__</span> <span class="o">=</span> <span class="o">-</span><span class="mi">10</span>

    <span class="k">def</span> <span class="nf">_get_pmap</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prop_map</span>

    <span class="k">def</span> <span class="nf">_set_pmap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_prop_map</span> <span class="o">=</span> <span class="n">value</span>

    <span class="n">prop_map</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_pmap</span><span class="p">,</span> <span class="n">_set_pmap</span><span class="p">,</span>
                        <span class="n">doc</span><span class="o">=</span><span class="s">&quot;:class:`~graph_tool.PropertyMap` owner instance.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">input_array</span><span class="p">,</span> <span class="n">prop_map</span><span class="p">):</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">input_array</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">prop_map</span> <span class="o">=</span> <span class="n">prop_map</span>

        <span class="c"># check if data really belongs to property map</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">prop_map</span><span class="o">.</span><span class="n">_get_data</span><span class="p">()</span><span class="o">.</span><span class="n">__array_interface__</span><span class="p">[</span><span class="s">&#39;data&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">_get_base_data</span><span class="p">()):</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">prop_map</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="c"># do a copy</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">obj</span>

    <span class="k">def</span> <span class="nf">_get_base</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">base</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">while</span> <span class="n">base</span><span class="o">.</span><span class="n">base</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">base</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">base</span>
        <span class="k">return</span> <span class="n">base</span>

    <span class="k">def</span> <span class="nf">_get_base_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_base</span><span class="p">()</span><span class="o">.</span><span class="n">__array_interface__</span><span class="p">[</span><span class="s">&#39;data&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_check_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">prop_map</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prop_map</span><span class="o">.</span><span class="n">_get_data</span><span class="p">()</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span>
            <span class="n">data</span><span class="o">.</span><span class="n">__array_interface__</span><span class="p">[</span><span class="s">&#39;data&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_base_data</span><span class="p">()):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">((</span><span class="s">&quot;The graph correspondig to the underlying&quot;</span> <span class="o">+</span>
                              <span class="s">&quot; property map </span><span class="si">%s</span><span class="s"> has changed. The&quot;</span> <span class="o">+</span>
                              <span class="s">&quot; PropertyArray at 0x</span><span class="si">%x</span><span class="s"> is no longer valid!&quot;</span><span class="p">)</span> <span class="o">%</span>
                             <span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prop_map</span><span class="p">),</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">__array_finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="ow">is</span> <span class="n">PropertyArray</span><span class="p">:</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">_check_data</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c"># inherit prop_map only if the data is the same</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="ow">is</span> <span class="n">PropertyArray</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_get_base_data</span><span class="p">()</span> <span class="o">==</span> <span class="n">obj</span><span class="o">.</span><span class="n">_get_base_data</span><span class="p">()):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">prop_map</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s">&#39;prop_map&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">prop_map</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_data</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__array_prepare__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out_arr</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_data</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="o">.</span><span class="n">__array_prepare__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out_arr</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__array_wrap__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out_arr</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="c">#demote to ndarray</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="o">.</span><span class="n">__array_wrap__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out_arr</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

    <span class="c"># Overload members and operators to add data checking</span>

    <span class="k">def</span> <span class="nf">_wrap_method</span><span class="p">(</span><span class="n">method</span><span class="p">):</span>
        <span class="n">method</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">checked_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_data</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">ismethod</span><span class="p">(</span><span class="n">method</span><span class="p">):</span>
            <span class="n">checked_method</span> <span class="o">=</span> <span class="n">_wraps</span><span class="p">(</span><span class="n">method</span><span class="p">)(</span><span class="n">checked_method</span><span class="p">)</span>
        <span class="n">checked_method</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="s">&quot;__doc__&quot;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">checked_method</span>

    <span class="k">for</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;all&#39;</span><span class="p">,</span> <span class="s">&#39;any&#39;</span><span class="p">,</span> <span class="s">&#39;argmax&#39;</span><span class="p">,</span> <span class="s">&#39;argmin&#39;</span><span class="p">,</span> <span class="s">&#39;argsort&#39;</span><span class="p">,</span> <span class="s">&#39;astype&#39;</span><span class="p">,</span>
                   <span class="s">&#39;byteswap&#39;</span><span class="p">,</span> <span class="s">&#39;choose&#39;</span><span class="p">,</span> <span class="s">&#39;clip&#39;</span><span class="p">,</span> <span class="s">&#39;compress&#39;</span><span class="p">,</span> <span class="s">&#39;conj&#39;</span><span class="p">,</span>
                   <span class="s">&#39;conjugate&#39;</span><span class="p">,</span> <span class="s">&#39;copy&#39;</span><span class="p">,</span> <span class="s">&#39;cumprod&#39;</span><span class="p">,</span> <span class="s">&#39;cumsum&#39;</span><span class="p">,</span> <span class="s">&#39;diagonal&#39;</span><span class="p">,</span> <span class="s">&#39;dot&#39;</span><span class="p">,</span>
                   <span class="s">&#39;dump&#39;</span><span class="p">,</span> <span class="s">&#39;dumps&#39;</span><span class="p">,</span> <span class="s">&#39;fill&#39;</span><span class="p">,</span> <span class="s">&#39;flat&#39;</span><span class="p">,</span> <span class="s">&#39;flatten&#39;</span><span class="p">,</span> <span class="s">&#39;getfield&#39;</span><span class="p">,</span>
                   <span class="s">&#39;imag&#39;</span><span class="p">,</span> <span class="s">&#39;item&#39;</span><span class="p">,</span> <span class="s">&#39;itemset&#39;</span><span class="p">,</span> <span class="s">&#39;itemsize&#39;</span><span class="p">,</span> <span class="s">&#39;max&#39;</span><span class="p">,</span> <span class="s">&#39;mean&#39;</span><span class="p">,</span> <span class="s">&#39;min&#39;</span><span class="p">,</span>
                   <span class="s">&#39;newbyteorder&#39;</span><span class="p">,</span> <span class="s">&#39;nonzero&#39;</span><span class="p">,</span> <span class="s">&#39;prod&#39;</span><span class="p">,</span> <span class="s">&#39;ptp&#39;</span><span class="p">,</span> <span class="s">&#39;put&#39;</span><span class="p">,</span> <span class="s">&#39;ravel&#39;</span><span class="p">,</span>
                   <span class="s">&#39;real&#39;</span><span class="p">,</span> <span class="s">&#39;repeat&#39;</span><span class="p">,</span> <span class="s">&#39;reshape&#39;</span><span class="p">,</span> <span class="s">&#39;resize&#39;</span><span class="p">,</span> <span class="s">&#39;round&#39;</span><span class="p">,</span>
                   <span class="s">&#39;searchsorted&#39;</span><span class="p">,</span> <span class="s">&#39;setfield&#39;</span><span class="p">,</span> <span class="s">&#39;setflags&#39;</span><span class="p">,</span> <span class="s">&#39;sort&#39;</span><span class="p">,</span> <span class="s">&#39;squeeze&#39;</span><span class="p">,</span>
                   <span class="s">&#39;std&#39;</span><span class="p">,</span> <span class="s">&#39;sum&#39;</span><span class="p">,</span> <span class="s">&#39;swapaxes&#39;</span><span class="p">,</span> <span class="s">&#39;take&#39;</span><span class="p">,</span> <span class="s">&#39;tofile&#39;</span><span class="p">,</span> <span class="s">&#39;tolist&#39;</span><span class="p">,</span>
                   <span class="s">&#39;tostring&#39;</span><span class="p">,</span> <span class="s">&#39;trace&#39;</span><span class="p">,</span> <span class="s">&#39;transpose&#39;</span><span class="p">,</span> <span class="s">&#39;var&#39;</span><span class="p">,</span> <span class="s">&#39;view&#39;</span><span class="p">,</span>
                   <span class="s">&#39;__getitem__&#39;</span><span class="p">]:</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">method</span><span class="p">):</span>
            <span class="nb">locals</span><span class="p">()[</span><span class="n">method</span><span class="p">]</span> <span class="o">=</span> <span class="n">_wrap_method</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="PropertyMap"><a class="viewcode-back" href="../graph_tool.html#graph_tool.PropertyMap">[docs]</a><span class="k">class</span> <span class="nc">PropertyMap</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This class provides a mapping from vertices, edges or whole graphs to arbitrary properties.</span>

<span class="sd">    See :ref:`sec_property_maps` for more details.</span>

<span class="sd">    The possible property value types are listed below.</span>

<span class="sd">    .. table::</span>

<span class="sd">        =======================     ======================</span>
<span class="sd">         Type name                  Alias</span>
<span class="sd">        =======================     ======================</span>
<span class="sd">        ``bool``                    ``uint8_t``</span>
<span class="sd">        ``int16_t``                 ``short``</span>
<span class="sd">        ``int32_t``                 ``int``</span>
<span class="sd">        ``int64_t``                 ``long``, ``long long``</span>
<span class="sd">        ``double``                  ``float``</span>
<span class="sd">        ``long double``</span>
<span class="sd">        ``string``</span>
<span class="sd">        ``vector&lt;bool&gt;``            ``vector&lt;uint8_t&gt;``</span>
<span class="sd">        ``vector&lt;int16_t&gt;``         ``short``</span>
<span class="sd">        ``vector&lt;int32_t&gt;``         ``vector&lt;int&gt;``</span>
<span class="sd">        ``vector&lt;int64_t&gt;``         ``vector&lt;long&gt;``, ``vector&lt;long long&gt;``</span>
<span class="sd">        ``vector&lt;double&gt;``          ``vector&lt;float&gt;``</span>
<span class="sd">        ``vector&lt;long double&gt;``</span>
<span class="sd">        ``vector&lt;string&gt;``</span>
<span class="sd">        ``python::object``          ``object``</span>
<span class="sd">        =======================     ======================</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pmap</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">key_type</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__map</span> <span class="o">=</span> <span class="n">pmap</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__g</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__base_g</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="bp">None</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">GraphView</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__base_g</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">base</span><span class="p">)</span>  <span class="c"># keep reference to the</span>
                                                     <span class="c"># base graph, in case the</span>
                                                     <span class="c"># graph view is deleted.</span>
        <span class="k">except</span> <span class="ne">NameError</span><span class="p">:</span>
            <span class="k">pass</span>  <span class="c"># ignore if GraphView is yet undefined</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__key_type</span> <span class="o">=</span> <span class="n">key_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__register_map</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__key_trans</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_type</span><span class="p">()</span> <span class="o">==</span> <span class="s">&quot;g&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">key</span><span class="o">.</span><span class="n">_Graph__graph</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">key</span>


    <span class="k">def</span> <span class="nf">__register_map</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">__g</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">__base_g</span><span class="p">()]:</span>
            <span class="k">if</span> <span class="n">g</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">g</span><span class="o">.</span><span class="n">_Graph__known_properties</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__unregister_map</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">__g</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">__base_g</span><span class="p">()]:</span>
            <span class="k">if</span> <span class="n">g</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">_Graph__known_properties</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">g</span><span class="o">.</span><span class="n">_Graph__known_properties</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__unregister_map</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__map</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">__key_trans</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__key_trans</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__map</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__map</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">_convert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># provide some more useful information</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_type</span><span class="p">()</span> <span class="o">==</span> <span class="s">&quot;e&quot;</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="s">&quot;Edge&quot;</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_type</span><span class="p">()</span> <span class="o">==</span> <span class="s">&quot;v&quot;</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="s">&quot;Vertex&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="s">&quot;Graph&quot;</span>
        <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_graph</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">g</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">g</span> <span class="o">=</span> <span class="s">&quot;a non-existent graph&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">g</span> <span class="o">=</span> <span class="s">&quot;Graph 0x</span><span class="si">%x</span><span class="s">&quot;</span> <span class="o">%</span> <span class="nb">id</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="s">&quot;, with values:</span><span class="se">\n</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fa</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="s">&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="s">&quot;&lt;PropertyMap object with key type &#39;</span><span class="si">%s</span><span class="s">&#39; and value type &#39;</span><span class="si">%s</span><span class="s">&#39;,&quot;</span>
                <span class="o">+</span> <span class="s">&quot; for </span><span class="si">%s</span><span class="s">, at 0x</span><span class="si">%x%s</span><span class="s">&gt;&quot;</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">value_type</span><span class="p">(),</span> <span class="n">g</span><span class="p">,</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span>
                                            <span class="n">vals</span><span class="p">)</span>

<div class="viewcode-block" id="PropertyMap.copy"><a class="viewcode-back" href="../graph_tool.html#graph_tool.PropertyMap.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value_type</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a copy of the property map. If ``value_type`` is specified,</span>
<span class="sd">        the value type is converted to the chosen type.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_graph</span><span class="p">()</span><span class="o">.</span><span class="n">copy_property</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value_type</span><span class="o">=</span><span class="n">value_type</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

<div class="viewcode-block" id="PropertyMap.get_graph"><a class="viewcode-back" href="../graph_tool.html#graph_tool.PropertyMap.get_graph">[docs]</a>    <span class="k">def</span> <span class="nf">get_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the graph class to which the map refers.&quot;&quot;&quot;</span>
        <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__g</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">g</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__base_g</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">g</span>
</div>
<div class="viewcode-block" id="PropertyMap.key_type"><a class="viewcode-back" href="../graph_tool.html#graph_tool.PropertyMap.key_type">[docs]</a>    <span class="k">def</span> <span class="nf">key_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the key type of the map. Either &#39;g&#39;, &#39;v&#39; or &#39;e&#39;.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__key_type</span>
</div>
<div class="viewcode-block" id="PropertyMap.value_type"><a class="viewcode-back" href="../graph_tool.html#graph_tool.PropertyMap.value_type">[docs]</a>    <span class="k">def</span> <span class="nf">value_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the value type of the map.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__map</span><span class="o">.</span><span class="n">value_type</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="PropertyMap.python_value_type"><a class="viewcode-back" href="../graph_tool.html#graph_tool.PropertyMap.python_value_type">[docs]</a>    <span class="k">def</span> <span class="nf">python_value_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the python-compatible value type of the map.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_python_type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__map</span><span class="o">.</span><span class="n">value_type</span><span class="p">())</span>
</div>
<div class="viewcode-block" id="PropertyMap.get_array"><a class="viewcode-back" href="../graph_tool.html#graph_tool.PropertyMap.get_array">[docs]</a>    <span class="k">def</span> <span class="nf">get_array</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get a :class:`~graph_tool.PropertyArray` with the property values.</span>

<span class="sd">        .. note::</span>

<span class="sd">           An array is returned *only if* the value type of the property map is</span>
<span class="sd">           a scalar. For vector, string or object types, ``None`` is returned</span>
<span class="sd">           instead. For vector and string objects, indirect array access is</span>
<span class="sd">           provided via the :func:`~graph_tool.PropertyMap.get_2d_array()` and</span>
<span class="sd">           :func:`~graph_tool.PropertyMap.set_2d_array()` member functions.</span>

<span class="sd">        .. warning::</span>

<span class="sd">           The returned array does not own the data, which belongs to the</span>
<span class="sd">           property map. Therefore, if the graph changes, the array may become</span>
<span class="sd">           *invalid* and any operation on it will fail with a</span>
<span class="sd">           :class:`ValueError` exception. Do **not** store the array if</span>
<span class="sd">           the graph is to be modified; store a **copy** instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_data</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">a</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Cannot get array for value type: &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">value_type</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">PropertyArray</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">prop_map</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">_get_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_graph</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">g</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Cannot get array for an orphaned property map&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__key_type</span> <span class="o">==</span> <span class="s">&#39;v&#39;</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="o">.</span><span class="n">GetNumberOfVertices</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">__key_type</span> <span class="o">==</span> <span class="s">&#39;e&#39;</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">max_edge_index</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__map</span><span class="o">.</span><span class="n">get_array</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">a</span>

    <span class="k">def</span> <span class="nf">__set_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_array</span><span class="p">()</span>
        <span class="n">a</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">v</span>

    <span class="n">a</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">get_array</span><span class="p">,</span> <span class="n">__set_array</span><span class="p">,</span>
                 <span class="n">doc</span><span class="o">=</span><span class="s">r&quot;&quot;&quot;Shortcut to the :meth:`~PropertyMap.get_array` method</span>
<span class="s">                 as an attribute. This makes assignments more convenient, e.g.:</span>

<span class="s">                 &gt;&gt;&gt; g = gt.Graph()</span>
<span class="s">                 &gt;&gt;&gt; g.add_vertex(10)</span>
<span class="s">                 &lt;...&gt;</span>
<span class="s">                 &gt;&gt;&gt; prop = g.new_vertex_property(&quot;double&quot;)</span>
<span class="s">                 &gt;&gt;&gt; prop.a = np.random.random(10)           # Assignment from array</span>
<span class="s">                 &quot;&quot;&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__get_set_f_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">get</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_graph</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">g</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_array</span><span class="p">()</span>
        <span class="n">filt</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__key_type</span> <span class="o">==</span> <span class="s">&#39;v&#39;</span><span class="p">:</span>
            <span class="n">filt</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">get_vertex_filter</span><span class="p">()</span>
            <span class="n">N</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">num_vertices</span><span class="p">()</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">__key_type</span> <span class="o">==</span> <span class="s">&#39;e&#39;</span><span class="p">:</span>
            <span class="n">filt</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">get_edge_filter</span><span class="p">()</span>
            <span class="n">N</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">_get_max_edge_index</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">get_vertex_filter</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">filt</span> <span class="o">=</span> <span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">new_edge_property</span><span class="p">(</span><span class="s">&quot;bool&quot;</span><span class="p">),</span> <span class="n">filt</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">u</span> <span class="o">=</span> <span class="n">GraphView</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">skip_properties</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                <span class="n">libcore</span><span class="o">.</span><span class="n">mark_edges</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span> <span class="n">_prop</span><span class="p">(</span><span class="s">&quot;e&quot;</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">filt</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                <span class="k">if</span> <span class="n">filt</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">filt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">filt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">a</span>
            <span class="k">elif</span> <span class="n">g</span><span class="o">.</span><span class="n">_get_max_edge_index</span><span class="p">()</span> <span class="o">!=</span> <span class="n">g</span><span class="o">.</span><span class="n">num_edges</span><span class="p">():</span>
                <span class="n">filt</span> <span class="o">=</span> <span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">new_edge_property</span><span class="p">(</span><span class="s">&quot;bool&quot;</span><span class="p">),</span> <span class="bp">False</span><span class="p">)</span>
                <span class="n">u</span> <span class="o">=</span> <span class="n">GraphView</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">skip_properties</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                <span class="n">libcore</span><span class="o">.</span><span class="n">mark_edges</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span> <span class="n">_prop</span><span class="p">(</span><span class="s">&quot;e&quot;</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">filt</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">get</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">a</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">a</span>
            <span class="k">if</span> <span class="n">filt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">a</span>
            <span class="k">return</span> <span class="n">a</span><span class="p">[</span><span class="n">filt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">a</span> <span class="o">==</span> <span class="p">(</span><span class="ow">not</span> <span class="n">filt</span><span class="p">[</span><span class="mi">1</span><span class="p">])][:</span><span class="n">N</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">a</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="k">if</span> <span class="n">filt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">a</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">v</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="n">a</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">filt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">a</span> <span class="o">==</span> <span class="p">(</span><span class="ow">not</span> <span class="n">filt</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">m</span> <span class="o">*=</span> <span class="n">m</span><span class="o">.</span><span class="n">cumsum</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">N</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">a</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="n">a</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">)][</span><span class="n">m</span><span class="p">]</span>

    <span class="n">fa</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">__get_set_f_array</span><span class="p">,</span>
                  <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_set_f_array</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="bp">False</span><span class="p">),</span>
                  <span class="n">doc</span><span class="o">=</span><span class="s">r&quot;&quot;&quot;The same as the :attr:`~PropertyMap.a` attribute, but</span>
<span class="s">                  instead an *indexed* array is returned, which contains only</span>
<span class="s">                  entries for vertices/edges which are not filtered out. If</span>
<span class="s">                  there are no filters in place, the array is not indexed, and</span>
<span class="s">                  is identical to the :attr:`~PropertyMap.a` attribute.</span>

<span class="s">                  Note that because advanced indexing is triggered, a **copy**</span>
<span class="s">                  of the array is returned, not a view, as for the</span>
<span class="s">                  :attr:`~PropertyMap.a` attribute. Nevertheless, the assignment</span>
<span class="s">                  of values to the *whole* array at once works as expected.&quot;&quot;&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__get_set_m_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">get</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_graph</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">g</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_array</span><span class="p">()</span>
        <span class="n">filt</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__key_type</span> <span class="o">==</span> <span class="s">&#39;v&#39;</span><span class="p">:</span>
            <span class="n">filt</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">get_vertex_filter</span><span class="p">()</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">__key_type</span> <span class="o">==</span> <span class="s">&#39;e&#39;</span><span class="p">:</span>
            <span class="n">filt</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">get_edge_filter</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">get_vertex_filter</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">filt</span> <span class="o">=</span> <span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">new_edge_property</span><span class="p">(</span><span class="s">&quot;bool&quot;</span><span class="p">),</span> <span class="n">filt</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">u</span> <span class="o">=</span> <span class="n">GraphView</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">skip_properties</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                <span class="n">libcore</span><span class="o">.</span><span class="n">mark_edges</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span> <span class="n">_prop</span><span class="p">(</span><span class="s">&quot;e&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">filt</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                <span class="k">if</span> <span class="n">filt</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">filt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">filt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">a</span>
        <span class="k">if</span> <span class="n">filt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">a</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">get</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">a</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span>
        <span class="n">ma</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="p">(</span><span class="n">filt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">a</span> <span class="o">==</span> <span class="bp">False</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">filt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">else</span> <span class="p">(</span><span class="n">filt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">a</span> <span class="o">==</span> <span class="bp">True</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">get</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ma</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ma</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">v</span>

    <span class="n">ma</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">__get_set_m_array</span><span class="p">,</span>
                  <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_set_m_array</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="bp">False</span><span class="p">),</span>
                  <span class="n">doc</span><span class="o">=</span><span class="s">r&quot;&quot;&quot;The same as the :attr:`~PropertyMap.a` attribute, but</span>
<span class="s">                  instead a :class:`~numpy.ma.MaskedArray` object is returned,</span>
<span class="s">                  which contains only entries for vertices/edges which are not</span>
<span class="s">                  filtered out. If there are no filters in place, a regular</span>
<span class="s">                  :class:`~graph_tool.PropertyArray` is returned, which is</span>
<span class="s">                  identical to the :attr:`~PropertyMap.a` attribute.&quot;&quot;&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="PropertyMap.get_2d_array"><a class="viewcode-back" href="../graph_tool.html#graph_tool.PropertyMap.get_2d_array">[docs]</a>    <span class="k">def</span> <span class="nf">get_2d_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Return a two-dimensional array with a copy of the entries of the</span>
<span class="sd">        vector-valued property map. The parameter ``pos`` must be a sequence of</span>
<span class="sd">        integers which specifies the indexes of the property values which will</span>
<span class="sd">        be used. &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_type</span><span class="p">()</span> <span class="o">==</span> <span class="s">&quot;g&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Cannot create multidimensional array for graph property maps.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s">&quot;vector&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">value_type</span><span class="p">()</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Cannot create array of dimension </span><span class="si">%d</span><span class="s"> (indexes </span><span class="si">%s</span><span class="s">) from non-vector property map of type &#39;</span><span class="si">%s</span><span class="s">&#39;.&quot;</span> \
                             <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pos</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">pos</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">value_type</span><span class="p">()))</span>
        <span class="k">if</span> <span class="s">&quot;string&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">value_type</span><span class="p">():</span>
            <span class="k">if</span> <span class="s">&quot;vector&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">value_type</span><span class="p">():</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">ungroup_vector_property</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">p</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>
            <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_graph</span><span class="p">()</span>
            <span class="n">vfilt</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">get_vertex_filter</span><span class="p">()</span>
            <span class="n">efilt</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">get_edge_filter</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">vfilt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">g</span> <span class="o">=</span> <span class="n">GraphView</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">skip_vfilt</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">skip_efilt</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_type</span><span class="p">()</span> <span class="o">==</span> <span class="s">&quot;v&quot;</span><span class="p">:</span>
                <span class="n">N</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">num_vertices</span><span class="p">()</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">vertex_index</span>
                <span class="n">filt</span> <span class="o">=</span> <span class="n">vfilt</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">N</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">max_edge_index</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">edge_index</span>
                <span class="n">filt</span> <span class="o">=</span> <span class="n">efilt</span>
            <span class="n">a</span> <span class="o">=</span> <span class="p">[[</span><span class="s">&quot;&quot;</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">))]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_type</span><span class="p">()</span> <span class="o">==</span> <span class="s">&quot;v&quot;</span><span class="p">:</span>
                <span class="n">iters</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">iters</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">iters</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)):</span>
                    <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">idx</span><span class="p">[</span><span class="n">v</span><span class="p">]]</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">v</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">vfilt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">filt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">a</span><span class="p">[:</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">==</span> <span class="p">(</span><span class="ow">not</span> <span class="n">filt</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
            <span class="k">return</span> <span class="n">a</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fa</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">ungroup_vector_property</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">a</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">p</span><span class="p">])</span>
</div>
<div class="viewcode-block" id="PropertyMap.set_2d_array"><a class="viewcode-back" href="../graph_tool.html#graph_tool.PropertyMap.set_2d_array">[docs]</a>    <span class="k">def</span> <span class="nf">set_2d_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Set the entries of the vector-valued property map from a</span>
<span class="sd">        two-dimensional array ``a``. If given, the parameter ``pos`` must be a</span>
<span class="sd">        sequence of integers which specifies the indexes of the property values</span>
<span class="sd">        which will be set.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_type</span><span class="p">()</span> <span class="o">==</span> <span class="s">&quot;g&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Cannot set multidimensional array for graph property maps.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s">&quot;vector&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">value_type</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Cannot set array of shape </span><span class="si">%s</span><span class="s"> to non-vector property map of type </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> \
                                 <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">value_type</span><span class="p">()))</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">value_type</span><span class="p">()</span> <span class="o">!=</span> <span class="s">&quot;string&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fa</span> <span class="o">=</span> <span class="n">a</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_graph</span><span class="p">()</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_type</span><span class="p">()</span> <span class="o">==</span> <span class="s">&quot;v&quot;</span><span class="p">:</span>
                    <span class="n">iters</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">iters</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">edges</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="n">g</span><span class="o">.</span><span class="n">edge_index</span><span class="p">[</span><span class="n">e</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">iters</span><span class="p">):</span>
                    <span class="bp">self</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="k">return</span>

        <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value_type</span><span class="p">()[</span><span class="mi">7</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">ps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">ps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_graph</span><span class="p">()</span><span class="o">.</span><span class="n">new_property</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">key_type</span><span class="p">(),</span> <span class="n">val</span><span class="p">))</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">value_type</span><span class="p">()</span> <span class="o">!=</span> <span class="s">&quot;string&quot;</span><span class="p">:</span>
                <span class="n">ps</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">fa</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_graph</span><span class="p">()</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_type</span><span class="p">()</span> <span class="o">==</span> <span class="s">&quot;v&quot;</span><span class="p">:</span>
                    <span class="n">iters</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">iters</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">iters</span><span class="p">):</span>
                    <span class="n">ps</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
        <span class="n">group_vector_property</span><span class="p">(</span><span class="n">ps</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="PropertyMap.is_writable"><a class="viewcode-back" href="../graph_tool.html#graph_tool.PropertyMap.is_writable">[docs]</a>    <span class="k">def</span> <span class="nf">is_writable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True if the property is writable.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__map</span><span class="o">.</span><span class="n">is_writable</span><span class="p">()</span>
</div>
    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">p</span><span class="o">.</span><span class="n">fa</span> <span class="o">=</span> <span class="n">a</span>
        <span class="k">return</span> <span class="n">p</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_graph</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">g</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;cannot pickle orphaned property map&quot;</span><span class="p">)</span>
        <span class="n">value_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value_type</span><span class="p">()</span>
        <span class="n">key_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_type</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_writable</span><span class="p">():</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">GraphView</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">skip_vfilt</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">skip_efilt</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">key_type</span> <span class="o">==</span> <span class="s">&quot;v&quot;</span><span class="p">:</span>
                <span class="n">vals</span> <span class="o">=</span> <span class="p">[</span><span class="n">_convert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">u</span><span class="o">.</span><span class="n">vertices</span><span class="p">()]</span>
            <span class="k">elif</span> <span class="n">key_type</span> <span class="o">==</span> <span class="s">&quot;e&quot;</span><span class="p">:</span>
                <span class="n">vals</span> <span class="o">=</span> <span class="p">[</span><span class="n">_convert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="n">e</span><span class="p">])</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">u</span><span class="o">.</span><span class="n">edges</span><span class="p">()]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">vals</span> <span class="o">=</span> <span class="n">_convert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="n">g</span><span class="p">])</span>

        <span class="n">state</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">g</span><span class="o">=</span><span class="n">g</span><span class="p">,</span> <span class="n">value_type</span><span class="o">=</span><span class="n">value_type</span><span class="p">,</span>
                     <span class="n">key_type</span><span class="o">=</span><span class="n">key_type</span><span class="p">,</span> <span class="n">vals</span><span class="o">=</span><span class="n">vals</span><span class="p">,</span>
                     <span class="n">is_vindex</span><span class="o">=</span><span class="bp">self</span> <span class="ow">is</span> <span class="n">g</span><span class="o">.</span><span class="n">vertex_index</span><span class="p">,</span>
                     <span class="n">is_eindex</span><span class="o">=</span><span class="bp">self</span> <span class="ow">is</span> <span class="n">g</span><span class="o">.</span><span class="n">edge_index</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">state</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s">&quot;g&quot;</span><span class="p">]</span>
        <span class="n">key_type</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s">&quot;key_type&quot;</span><span class="p">]</span>
        <span class="n">value_type</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s">&quot;value_type&quot;</span><span class="p">]</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s">&quot;vals&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">state</span><span class="p">[</span><span class="s">&quot;is_vindex&quot;</span><span class="p">]:</span>
            <span class="n">pmap</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">vertex_index</span>
        <span class="k">elif</span> <span class="n">state</span><span class="p">[</span><span class="s">&quot;is_eindex&quot;</span><span class="p">]:</span>
            <span class="n">pmap</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">edge_index</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">GraphView</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">skip_vfilt</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">skip_efilt</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">key_type</span> <span class="o">==</span> <span class="s">&quot;v&quot;</span><span class="p">:</span>
                <span class="n">pmap</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="n">value_type</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">vertices</span><span class="p">()):</span>
                    <span class="n">pmap</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">vals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">key_type</span> <span class="o">==</span> <span class="s">&quot;e&quot;</span><span class="p">:</span>
                <span class="n">pmap</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_edge_property</span><span class="p">(</span><span class="n">value_type</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">edges</span><span class="p">()):</span>
                    <span class="n">pmap</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="n">vals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pmap</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_graph_property</span><span class="p">(</span><span class="n">value_type</span><span class="p">)</span>
                <span class="n">pmap</span><span class="p">[</span><span class="n">g</span><span class="p">]</span> <span class="o">=</span> <span class="n">vals</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__map</span> <span class="o">=</span> <span class="n">pmap</span><span class="o">.</span><span class="n">__map</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__g</span> <span class="o">=</span> <span class="n">pmap</span><span class="o">.</span><span class="n">__g</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__base_g</span> <span class="o">=</span> <span class="n">pmap</span><span class="o">.</span><span class="n">__base_g</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__key_type</span> <span class="o">=</span> <span class="n">key_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__register_map</span><span class="p">()</span>

</div>
<span class="k">def</span> <span class="nf">_check_prop_writable</span><span class="p">(</span><span class="n">prop</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">prop</span><span class="o">.</span><span class="n">is_writable</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;property map</span><span class="si">%s</span><span class="s"> is not writable.&quot;</span> <span class="o">%</span>\
                         <span class="p">((</span><span class="s">&quot; &#39;</span><span class="si">%s</span><span class="s">&#39;&quot;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span> <span class="k">if</span> <span class="n">name</span> <span class="o">!=</span> <span class="bp">None</span> <span class="k">else</span> <span class="s">&quot;&quot;</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_check_prop_scalar</span><span class="p">(</span><span class="n">prop</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">floating</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="n">scalars</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;bool&quot;</span><span class="p">,</span> <span class="s">&quot;int32_t&quot;</span><span class="p">,</span> <span class="s">&quot;int64_t&quot;</span><span class="p">,</span> <span class="s">&quot;unsigned long&quot;</span><span class="p">,</span>
               <span class="s">&quot;double&quot;</span><span class="p">,</span> <span class="s">&quot;long double&quot;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">floating</span><span class="p">:</span>
        <span class="n">scalars</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;double&quot;</span><span class="p">,</span> <span class="s">&quot;long double&quot;</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">prop</span><span class="o">.</span><span class="n">value_type</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">scalars</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;property map</span><span class="si">%s</span><span class="s"> is not of scalar</span><span class="si">%s</span><span class="s"> type.&quot;</span> <span class="o">%</span>\
                         <span class="p">(((</span><span class="s">&quot; &#39;</span><span class="si">%s</span><span class="s">&#39;&quot;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span> <span class="k">if</span> <span class="n">name</span> <span class="o">!=</span> <span class="bp">None</span> <span class="k">else</span> <span class="s">&quot;&quot;</span><span class="p">),</span>
                          <span class="p">(</span><span class="s">&quot; floating&quot;</span> <span class="k">if</span> <span class="n">floating</span> <span class="k">else</span> <span class="s">&quot;&quot;</span><span class="p">)))</span>


<span class="k">def</span> <span class="nf">_check_prop_vector</span><span class="p">(</span><span class="n">prop</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">scalar</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">floating</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="n">scalars</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;bool&quot;</span><span class="p">,</span> <span class="s">&quot;int32_t&quot;</span><span class="p">,</span> <span class="s">&quot;int64_t&quot;</span><span class="p">,</span> <span class="s">&quot;unsigned long&quot;</span><span class="p">,</span>
               <span class="s">&quot;double&quot;</span><span class="p">,</span> <span class="s">&quot;long double&quot;</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">scalar</span><span class="p">:</span>
        <span class="n">scalars</span> <span class="o">+=</span> <span class="p">[</span><span class="s">&quot;string&quot;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">floating</span><span class="p">:</span>
        <span class="n">scalars</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;double&quot;</span><span class="p">,</span> <span class="s">&quot;long double&quot;</span><span class="p">]</span>
    <span class="n">vals</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;vector&lt;</span><span class="si">%s</span><span class="s">&gt;&quot;</span> <span class="o">%</span> <span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">scalars</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">prop</span><span class="o">.</span><span class="n">value_type</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">vals</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;property map</span><span class="si">%s</span><span class="s"> is not of vector</span><span class="si">%s</span><span class="s"> type.&quot;</span> <span class="o">%</span>\
                         <span class="p">(((</span><span class="s">&quot; &#39;</span><span class="si">%s</span><span class="s">&#39;&quot;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span> <span class="k">if</span> <span class="n">name</span> <span class="o">!=</span> <span class="bp">None</span> <span class="k">else</span> <span class="s">&quot;&quot;</span><span class="p">),</span>
                          <span class="p">(</span><span class="s">&quot; floating&quot;</span> <span class="k">if</span> <span class="n">floating</span> <span class="k">else</span> <span class="s">&quot;&quot;</span><span class="p">)))</span>


<div class="viewcode-block" id="group_vector_property"><a class="viewcode-back" href="../graph_tool.html#graph_tool.group_vector_property">[docs]</a><span class="k">def</span> <span class="nf">group_vector_property</span><span class="p">(</span><span class="n">props</span><span class="p">,</span> <span class="n">value_type</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">vprop</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Group list of properties ``props`` into a vector property map of the same type.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    props : list of :class:`~graph_tool.PropertyMap`</span>
<span class="sd">        Properties to be grouped.</span>
<span class="sd">    value_type : string (optional, default: None)</span>
<span class="sd">        If supplied, defines the value type of the grouped property.</span>
<span class="sd">    vprop : :class:`~graph_tool.PropertyMap` (optional, default: None)</span>
<span class="sd">        If supplied, the properties are grouped into this property map.</span>
<span class="sd">    pos : list of ints (optional, default: None)</span>
<span class="sd">        If supplied, should contain a list of indexes where each corresponding</span>
<span class="sd">        element of ``props`` should be inserted.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    vprop : :class:`~graph_tool.PropertyMap`</span>
<span class="sd">       A vector property map with the grouped values of each property map in</span>
<span class="sd">       ``props``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from numpy.random import seed, randint</span>
<span class="sd">    &gt;&gt;&gt; from numpy import array</span>
<span class="sd">    &gt;&gt;&gt; seed(42)</span>
<span class="sd">    &gt;&gt;&gt; gt.seed_rng(42)</span>
<span class="sd">    &gt;&gt;&gt; g = gt.random_graph(100, lambda: (3, 3))</span>
<span class="sd">    &gt;&gt;&gt; props = [g.new_vertex_property(&quot;int&quot;) for i in range(3)]</span>
<span class="sd">    &gt;&gt;&gt; for i in range(3):</span>
<span class="sd">    ...    props[i].a = randint(0, 100, g.num_vertices())</span>
<span class="sd">    &gt;&gt;&gt; gprop = gt.group_vector_property(props)</span>
<span class="sd">    &gt;&gt;&gt; print(gprop[g.vertex(0)].a)</span>
<span class="sd">    [51 25  8]</span>
<span class="sd">    &gt;&gt;&gt; print(array([p[g.vertex(0)] for p in props]))</span>
<span class="sd">    [51 25  8]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">props</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_graph</span><span class="p">()</span>
    <span class="n">vtypes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">props</span><span class="p">):</span>
        <span class="k">if</span> <span class="s">&quot;vector&quot;</span> <span class="ow">in</span> <span class="n">p</span><span class="o">.</span><span class="n">value_type</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;property map &#39;props[</span><span class="si">%d</span><span class="s">]&#39; is a vector property.&quot;</span> <span class="o">%</span>
                             <span class="n">i</span><span class="p">)</span>
        <span class="n">vtypes</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">value_type</span><span class="p">())</span>
        <span class="n">keys</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">key_type</span><span class="p">())</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;&#39;props&#39; must be of the same key type.&quot;</span><span class="p">)</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">keys</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">vprop</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">value_type</span> <span class="o">==</span> <span class="bp">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">vtypes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">value_type</span> <span class="o">=</span> <span class="n">vtypes</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">value_type</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">value_type</span> <span class="o">=</span> <span class="s">&quot;vector&lt;</span><span class="si">%s</span><span class="s">&gt;&quot;</span> <span class="o">%</span> <span class="n">value_type</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="s">&#39;v&#39;</span><span class="p">:</span>
                <span class="n">vprop</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="n">value_type</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">k</span> <span class="o">==</span> <span class="s">&#39;e&#39;</span><span class="p">:</span>
                <span class="n">vprop</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_edge_property</span><span class="p">(</span><span class="n">value_type</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">vprop</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_graph_property</span><span class="p">(</span><span class="n">value_type</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Can&#39;t automatically determine property map value&quot;</span> <span class="o">+</span>
                       <span class="s">&quot; type. Please provide the &#39;value_type&#39; parameter.&quot;</span><span class="p">)</span>
    <span class="n">_check_prop_vector</span><span class="p">(</span><span class="n">vprop</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;vprop&quot;</span><span class="p">,</span> <span class="n">scalar</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">props</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="s">&quot;g&quot;</span><span class="p">:</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">GraphView</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="nb">reversed</span><span class="o">=</span><span class="n">g</span><span class="o">.</span><span class="n">is_reversed</span><span class="p">(),</span>
                          <span class="n">skip_properties</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="n">libcore</span><span class="o">.</span><span class="n">group_vector_property</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span> <span class="n">_prop</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">vprop</span><span class="p">),</span>
                                          <span class="n">_prop</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">p</span><span class="p">),</span>
                                          <span class="n">i</span> <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">pos</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                          <span class="n">k</span> <span class="o">==</span> <span class="s">&#39;e&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">vprop</span><span class="p">[</span><span class="n">g</span><span class="p">][</span><span class="n">i</span> <span class="k">if</span> <span class="n">pos</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">pos</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">g</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">vprop</span>

</div>
<div class="viewcode-block" id="ungroup_vector_property"><a class="viewcode-back" href="../graph_tool.html#graph_tool.ungroup_vector_property">[docs]</a><span class="k">def</span> <span class="nf">ungroup_vector_property</span><span class="p">(</span><span class="n">vprop</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">props</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Ungroup vector property map ``vprop`` into a list of individual property maps.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    vprop : :class:`~graph_tool.PropertyMap`</span>
<span class="sd">        Vector property map to be ungrouped.</span>
<span class="sd">    pos : list of ints</span>
<span class="sd">        A list of indexes corresponding to where each element of ``vprop``</span>
<span class="sd">        should be inserted into the ungrouped list.</span>
<span class="sd">    props : list of :class:`~graph_tool.PropertyMap`  (optional, default: None)</span>
<span class="sd">        If supplied, should contain a list of property maps to which ``vprop``</span>
<span class="sd">        should be ungroupped.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    props : list of :class:`~graph_tool.PropertyMap`</span>
<span class="sd">       A list of property maps with the ungrouped values of ``vprop``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from numpy.random import seed, randint</span>
<span class="sd">    &gt;&gt;&gt; from numpy import array</span>
<span class="sd">    &gt;&gt;&gt; seed(42)</span>
<span class="sd">    &gt;&gt;&gt; gt.seed_rng(42)</span>
<span class="sd">    &gt;&gt;&gt; g = gt.random_graph(100, lambda: (3, 3))</span>
<span class="sd">    &gt;&gt;&gt; prop = g.new_vertex_property(&quot;vector&lt;int&gt;&quot;)</span>
<span class="sd">    &gt;&gt;&gt; for v in g.vertices():</span>
<span class="sd">    ...    prop[v] = randint(0, 100, 3)</span>
<span class="sd">    &gt;&gt;&gt; uprops = gt.ungroup_vector_property(prop, [0, 1, 2])</span>
<span class="sd">    &gt;&gt;&gt; print(prop[g.vertex(0)].a)</span>
<span class="sd">    [51 92 14]</span>
<span class="sd">    &gt;&gt;&gt; print(array([p[g.vertex(0)] for p in uprops]))</span>
<span class="sd">    [51 92 14]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">g</span> <span class="o">=</span> <span class="n">vprop</span><span class="o">.</span><span class="n">get_graph</span><span class="p">()</span>
    <span class="n">_check_prop_vector</span><span class="p">(</span><span class="n">vprop</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;vprop&quot;</span><span class="p">,</span> <span class="n">scalar</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">vprop</span><span class="o">.</span><span class="n">key_type</span><span class="p">()</span>
    <span class="n">value_type</span> <span class="o">=</span> <span class="n">vprop</span><span class="o">.</span><span class="n">value_type</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&quot;&lt;&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&quot;&gt;&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">props</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="s">&#39;v&#39;</span><span class="p">:</span>
            <span class="n">props</span> <span class="o">=</span> <span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="n">value_type</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">pos</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">k</span> <span class="o">==</span> <span class="s">&#39;e&#39;</span><span class="p">:</span>
            <span class="n">props</span> <span class="o">=</span> <span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">new_edge_property</span><span class="p">(</span><span class="n">value_type</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">pos</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">props</span> <span class="o">=</span> <span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">new_graph_property</span><span class="p">(</span><span class="n">value_type</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">pos</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pos</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">props</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">key_type</span><span class="p">()</span> <span class="o">!=</span> <span class="n">k</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;&#39;props&#39; must be of the same key type as &#39;vprop&#39;.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="s">&#39;g&#39;</span><span class="p">:</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">GraphView</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="nb">reversed</span><span class="o">=</span><span class="n">g</span><span class="o">.</span><span class="n">is_reversed</span><span class="p">(),</span>
                          <span class="n">skip_properties</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="n">libcore</span><span class="o">.</span><span class="n">ungroup_vector_property</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span>
                                            <span class="n">_prop</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">vprop</span><span class="p">),</span>
                                            <span class="n">_prop</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">props</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span>
                                            <span class="n">p</span><span class="p">,</span> <span class="n">k</span> <span class="o">==</span> <span class="s">&#39;e&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">vprop</span><span class="p">[</span><span class="n">g</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="n">pos</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">vprop</span><span class="p">[</span><span class="n">g</span><span class="p">]</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">props</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">g</span><span class="p">]</span> <span class="o">=</span> <span class="n">vprop</span><span class="p">[</span><span class="n">g</span><span class="p">][</span><span class="n">pos</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
    <span class="k">return</span> <span class="n">props</span>

</div>
<div class="viewcode-block" id="infect_vertex_property"><a class="viewcode-back" href="../graph_tool.html#graph_tool.infect_vertex_property">[docs]</a><span class="k">def</span> <span class="nf">infect_vertex_property</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">prop</span><span class="p">,</span> <span class="n">vals</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Propagate the `prop` values of vertices with value `val` to all their</span>
<span class="sd">    out-neighbours.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    prop : :class:`~graph_tool.PropertyMap`</span>
<span class="sd">        Property map to be modified.</span>
<span class="sd">    vals : list (optional, default: `None`)</span>
<span class="sd">        List of values to be propagated. If not provided, all values</span>
<span class="sd">        will be propagated.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    None : ``None``</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from numpy.random import seed</span>
<span class="sd">    &gt;&gt;&gt; seed(42)</span>
<span class="sd">    &gt;&gt;&gt; gt.seed_rng(42)</span>
<span class="sd">    &gt;&gt;&gt; g = gt.random_graph(100, lambda: (3, 3))</span>
<span class="sd">    &gt;&gt;&gt; prop = g.vertex_index.copy(&quot;int32_t&quot;)</span>
<span class="sd">    &gt;&gt;&gt; gt.infect_vertex_property(g, prop, [10])</span>
<span class="sd">    &gt;&gt;&gt; print(sum(prop.a == 10))</span>
<span class="sd">    4</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">libcore</span><span class="o">.</span><span class="n">infect_vertex_property</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span> <span class="n">_prop</span><span class="p">(</span><span class="s">&quot;v&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">prop</span><span class="p">),</span>
                                   <span class="n">vals</span><span class="p">)</span>

</div>
<span class="nd">@_limit_args</span><span class="p">({</span><span class="s">&quot;endpoint&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s">&quot;source&quot;</span><span class="p">,</span> <span class="s">&quot;target&quot;</span><span class="p">]})</span>
<div class="viewcode-block" id="edge_endpoint_property"><a class="viewcode-back" href="../graph_tool.html#graph_tool.edge_endpoint_property">[docs]</a><span class="k">def</span> <span class="nf">edge_endpoint_property</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">prop</span><span class="p">,</span> <span class="n">endpoint</span><span class="p">,</span> <span class="n">eprop</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return an edge property map corresponding to the vertex property `prop` of</span>
<span class="sd">    either the target and source of the edge, according to `endpoint`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    prop : :class:`~graph_tool.PropertyMap`</span>
<span class="sd">        Vertex property map to be used to propagated to the edge.</span>
<span class="sd">    endpoint : `&quot;source&quot;` or `&quot;target&quot;`</span>
<span class="sd">        Edge endpoint considered. If the graph is undirected, the source is</span>
<span class="sd">        always the vertex with the lowest index.</span>
<span class="sd">    eprop : :class:`~graph_tool.PropertyMap` (optional, default: `None`)</span>
<span class="sd">        If provided, the resulting edge properties will be stored here.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    eprop : :class:`~graph_tool.PropertyMap`</span>
<span class="sd">        Propagated edge property.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; gt.seed_rng(42)</span>
<span class="sd">    &gt;&gt;&gt; g = gt.random_graph(100, lambda: (3, 3))</span>
<span class="sd">    &gt;&gt;&gt; esource = gt.edge_endpoint_property(g, g.vertex_index, &quot;source&quot;)</span>
<span class="sd">    &gt;&gt;&gt; print(esource.a)</span>
<span class="sd">    [ 0  0  0 96 96 96 92 92 92 88 88 88 84 84 84 80 80 80 76 76 76 72 72 72 68</span>
<span class="sd">     68 68 64 64 64 60 60 60 56 56 56 52 52 52 48 48 48 44 44 44 40 40 40 36 36</span>
<span class="sd">     36 32 32 32 28 28 28 24 24 24 20 20 20 16 16 16 12 12 12  8  8  8  4  4  4</span>
<span class="sd">     99 99 99  1  1  1  2  2  2  3  3  3  5  5  5  6  6  6  7  7  7  9  9  9 10</span>
<span class="sd">     10 10 14 14 14 19 19 19 25 25 25 30 30 30 35 35 35 41 41 41 46 46 46 51 51</span>
<span class="sd">     51 57 57 57 62 62 62 67 67 67 73 73 73 78 78 78 83 83 83 89 89 89 94 94 94</span>
<span class="sd">     11 11 11 98 98 98 97 97 97 95 95 95 93 93 93 91 91 91 90 90 90 87 87 87 86</span>
<span class="sd">     86 86 85 85 85 82 82 82 81 81 81 79 79 79 77 77 77 75 75 75 74 74 74 71 71</span>
<span class="sd">     71 69 69 69 61 61 61 54 54 54 47 47 47 39 39 39 33 33 33 26 26 26 18 18 18</span>
<span class="sd">     70 70 70 13 13 13 15 15 15 17 17 17 21 21 21 22 22 22 23 23 23 27 27 27 29</span>
<span class="sd">     29 29 31 31 31 34 34 34 37 37 37 38 38 38 42 42 42 43 43 43 45 45 45 49 49</span>
<span class="sd">     49 50 50 50 53 53 53 55 55 55 58 58 58 59 59 59 63 63 63 65 65 65 66 66 66]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">val_t</span> <span class="o">=</span> <span class="n">prop</span><span class="o">.</span><span class="n">value_type</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">val_t</span> <span class="o">==</span> <span class="s">&quot;unsigned long&quot;</span><span class="p">:</span>
        <span class="n">val_t</span> <span class="o">=</span> <span class="s">&quot;int64_t&quot;</span>
    <span class="k">if</span> <span class="n">eprop</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">eprop</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_edge_property</span><span class="p">(</span><span class="n">val_t</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">eprop</span><span class="o">.</span><span class="n">value_type</span><span class="p">()</span> <span class="o">!=</span> <span class="n">val_t</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;&#39;eprop&#39; must be of the same value type as &#39;prop&#39;: &quot;</span> <span class="o">+</span>
                         <span class="n">val_t</span><span class="p">)</span>
    <span class="n">libcore</span><span class="o">.</span><span class="n">edge_endpoint</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span> <span class="n">_prop</span><span class="p">(</span><span class="s">&quot;v&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">prop</span><span class="p">),</span>
                          <span class="n">_prop</span><span class="p">(</span><span class="s">&quot;e&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">eprop</span><span class="p">),</span> <span class="n">endpoint</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">eprop</span>
</div>
<span class="nd">@_limit_args</span><span class="p">({</span><span class="s">&quot;direction&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s">&quot;in&quot;</span><span class="p">,</span> <span class="s">&quot;out&quot;</span><span class="p">],</span> <span class="s">&quot;op&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s">&quot;sum&quot;</span><span class="p">,</span> <span class="s">&quot;prod&quot;</span><span class="p">,</span> <span class="s">&quot;min&quot;</span><span class="p">,</span> <span class="s">&quot;max&quot;</span><span class="p">]})</span>
<span class="k">def</span> <span class="nf">incident_edges_op</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">eprop</span><span class="p">,</span> <span class="n">vprop</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a vertex property map corresponding to a specific operation (sum,</span>
<span class="sd">    product, min or max) on the edge property `eprop` of incident edges on each</span>
<span class="sd">    vertex, following the direction given by `direction`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    direction : `&quot;in&quot;` or `&quot;out&quot;`</span>
<span class="sd">        Direction of the incident edges.</span>
<span class="sd">    op : `&quot;sum&quot;`, `&quot;prod&quot;`, `&quot;min&quot;` or `&quot;max&quot;`</span>
<span class="sd">        Operation performed on incident edges.</span>
<span class="sd">    eprop : :class:`~graph_tool.PropertyMap`</span>
<span class="sd">        Edge property map to be summed.</span>
<span class="sd">    vprop : :class:`~graph_tool.PropertyMap` (optional, default: `None`)</span>
<span class="sd">        If provided, the resulting vertex properties will be stored here.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    vprop : :class:`~graph_tool.PropertyMap`</span>
<span class="sd">        Summed vertex property.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; gt.seed_rng(42)</span>
<span class="sd">    &gt;&gt;&gt; g = gt.random_graph(100, lambda: (3, 3))</span>
<span class="sd">    &gt;&gt;&gt; vsum = gt.incident_edges_op(g, &quot;out&quot;, &quot;sum&quot;, g.edge_index)</span>
<span class="sd">    &gt;&gt;&gt; print(vsum.a)</span>
<span class="sd">    [  3 237 246 255 219 264 273 282 210 291 300 453 201 687 309 696 192 705</span>
<span class="sd">     669 318 183 714 723 732 174 327 660 741 165 750 336 759 156 651 768 345</span>
<span class="sd">     147 777 786 642 138 354 795 804 129 813 363 633 120 822 831 372 111 840</span>
<span class="sd">     624 849 102 381 858 867  93 615 390 876  84 885 894 399  75 606 678 597</span>
<span class="sd">      66 408 588 579  57 570 417 561  48 552 543 426  39 534 525 516  30 435</span>
<span class="sd">     507 498  21 489 444 480  12 471 462 228]</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">val_t</span> <span class="o">=</span> <span class="n">eprop</span><span class="o">.</span><span class="n">value_type</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">val_t</span> <span class="o">==</span> <span class="s">&quot;unsigned long&quot;</span><span class="p">:</span>
        <span class="n">val_t</span> <span class="o">=</span> <span class="s">&quot;int64_t&quot;</span>
    <span class="k">if</span> <span class="n">vprop</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">vprop</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="n">val_t</span><span class="p">)</span>
    <span class="n">orig_vprop</span> <span class="o">=</span> <span class="n">vprop</span>
    <span class="k">if</span> <span class="n">vprop</span><span class="o">.</span><span class="n">value_type</span> <span class="o">!=</span> <span class="n">val_t</span><span class="p">:</span>
        <span class="n">vprop</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="n">val_t</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="s">&quot;in&quot;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">g</span><span class="o">.</span><span class="n">is_directed</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">orig_vprop</span>
    <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="s">&quot;in&quot;</span><span class="p">:</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">GraphView</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="nb">reversed</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">skip_properties</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">libcore</span><span class="o">.</span><span class="n">out_edges_op</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span> <span class="n">_prop</span><span class="p">(</span><span class="s">&quot;e&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">eprop</span><span class="p">),</span>
                          <span class="n">_prop</span><span class="p">(</span><span class="s">&quot;v&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">vprop</span><span class="p">),</span> <span class="n">op</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">vprop</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">orig_vprop</span><span class="p">:</span>
        <span class="n">g</span><span class="o">.</span><span class="n">copy_property</span><span class="p">(</span><span class="n">vprop</span><span class="p">,</span> <span class="n">orig_vprop</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">orig_vprop</span>

<span class="nd">@_limit_args</span><span class="p">({</span><span class="s">&quot;htype&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s">&quot;int8_t&quot;</span><span class="p">,</span> <span class="s">&quot;int32_t&quot;</span><span class="p">,</span> <span class="s">&quot;int64_t&quot;</span><span class="p">]})</span>
<span class="k">def</span> <span class="nf">perfect_prop_hash</span><span class="p">(</span><span class="n">props</span><span class="p">,</span> <span class="n">htype</span><span class="o">=</span><span class="s">&quot;int32_t&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Given a list of property maps `props` of the same type, a derived list of</span>
<span class="sd">    property maps with integral type `htype` is returned, where each value is</span>
<span class="sd">    replaced by a perfect (i.e. unique) hash value.</span>

<span class="sd">    .. note::</span>
<span class="sd">       The hash value is deterministic, but it will not be necessarily the same</span>
<span class="sd">       for different values of `props`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">val_types</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">p</span><span class="o">.</span><span class="n">value_type</span><span class="p">()</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">props</span><span class="p">])</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">val_types</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;All properties must have the same value type&quot;</span><span class="p">)</span>
    <span class="n">hprops</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">get_graph</span><span class="p">()</span><span class="o">.</span><span class="n">new_property</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">key_type</span><span class="p">(),</span> <span class="n">htype</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">props</span><span class="p">]</span>

    <span class="n">eprops</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">props</span> <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">key_type</span><span class="p">()</span> <span class="o">==</span> <span class="s">&quot;e&quot;</span><span class="p">]</span>
    <span class="n">heprops</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">hprops</span> <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">key_type</span><span class="p">()</span> <span class="o">==</span> <span class="s">&quot;e&quot;</span><span class="p">]</span>

    <span class="n">vprops</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">props</span> <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">key_type</span><span class="p">()</span> <span class="o">==</span> <span class="s">&quot;v&quot;</span><span class="p">]</span>
    <span class="n">hvprops</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">hprops</span> <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">key_type</span><span class="p">()</span> <span class="o">==</span> <span class="s">&quot;v&quot;</span><span class="p">]</span>

    <span class="n">hdict</span> <span class="o">=</span> <span class="n">libcore</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">eprop</span><span class="p">,</span> <span class="n">heprop</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">eprops</span><span class="p">,</span> <span class="n">heprops</span><span class="p">):</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">eprop</span><span class="o">.</span><span class="n">get_graph</span><span class="p">()</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">GraphView</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">skip_properties</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">libcore</span><span class="o">.</span><span class="n">perfect_ehash</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span> <span class="n">_prop</span><span class="p">(</span><span class="s">&#39;e&#39;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">eprop</span><span class="p">),</span>
                              <span class="n">_prop</span><span class="p">(</span><span class="s">&#39;e&#39;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">heprop</span><span class="p">),</span> <span class="n">hdict</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">vprop</span><span class="p">,</span> <span class="n">hvprop</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">vprops</span><span class="p">,</span> <span class="n">hvprops</span><span class="p">):</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">vprop</span><span class="o">.</span><span class="n">get_graph</span><span class="p">()</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">GraphView</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">skip_properties</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">libcore</span><span class="o">.</span><span class="n">perfect_vhash</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span> <span class="n">_prop</span><span class="p">(</span><span class="s">&#39;v&#39;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">vprop</span><span class="p">),</span>
                              <span class="n">_prop</span><span class="p">(</span><span class="s">&#39;v&#39;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">hvprop</span><span class="p">),</span> <span class="n">hdict</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">hprops</span>

<span class="k">class</span> <span class="nc">PropertyDict</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Wrapper for the dict of vertex, graph or edge properties, which sets the</span>
<span class="sd">    value on the property map when changed in the dict.</span>

<span class="sd">    For convenience, the dictionary entries are also available via attributes.</span>

<span class="sd">    .. note::</span>

<span class="sd">        The class is only an one-way proxy to the internally-kept properties. If</span>
<span class="sd">        you modify this object, the change will be propagated to the internal</span>
<span class="sd">        dictionary, but not vice-versa. Keep this in mind if you intend to keep</span>
<span class="sd">        a copy of the class instance.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="n">get_func</span><span class="p">,</span> <span class="n">set_func</span><span class="p">,</span> <span class="n">del_func</span><span class="p">):</span>
        <span class="nb">dict</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="nb">dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">old</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">PropertyDict</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__setattr__</span><span class="p">(</span><span class="s">&quot;g&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">PropertyDict</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__setattr__</span><span class="p">(</span><span class="s">&quot;get_func&quot;</span><span class="p">,</span> <span class="n">get_func</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">PropertyDict</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__setattr__</span><span class="p">(</span><span class="s">&quot;set_func&quot;</span><span class="p">,</span> <span class="n">set_func</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">PropertyDict</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__setattr__</span><span class="p">(</span><span class="s">&quot;del_func&quot;</span><span class="p">,</span> <span class="n">del_func</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_func</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
            <span class="nb">dict</span><span class="o">.</span><span class="n">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">val</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s">&quot;Property dict cannot be gotten&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_func</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s">&quot;Property dict cannot be set&quot;</span><span class="p">)</span>
        <span class="nb">dict</span><span class="o">.</span><span class="n">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">del_func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
        <span class="nb">dict</span><span class="o">.</span><span class="n">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">del_func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
        <span class="nb">dict</span><span class="o">.</span><span class="n">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__getitem__</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__setitem__</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

<span class="c">################################################################################</span>
<span class="c"># Graph class</span>
<span class="c"># The main graph interface</span>
<span class="c">################################################################################</span>

<span class="kn">from</span> <span class="nn">.libgraph_tool_core</span> <span class="kn">import</span> <span class="n">Vertex</span><span class="p">,</span> <span class="n">EdgeBase</span><span class="p">,</span> <span class="n">Vector_bool</span><span class="p">,</span> <span class="n">Vector_int16_t</span><span class="p">,</span> \
    <span class="n">Vector_int32_t</span><span class="p">,</span> <span class="n">Vector_int64_t</span><span class="p">,</span> <span class="n">Vector_double</span><span class="p">,</span> <span class="n">Vector_long_double</span><span class="p">,</span> \
    <span class="n">Vector_string</span><span class="p">,</span> <span class="n">Vector_size_t</span><span class="p">,</span> <span class="n">new_vertex_property</span><span class="p">,</span> <span class="n">new_edge_property</span><span class="p">,</span> \
    <span class="n">new_graph_property</span>


<div class="viewcode-block" id="Graph"><a class="viewcode-back" href="../graph_tool.html#graph_tool.Graph">[docs]</a><span class="k">class</span> <span class="nc">Graph</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generic multigraph class.</span>

<span class="sd">    This class encapsulates either a directed multigraph (default or if</span>
<span class="sd">    ``directed=True``) or an undirected multigraph (if ``directed=False``),</span>
<span class="sd">    with optional internal edge, vertex or graph properties.</span>

<span class="sd">    If ``g`` is specified, the graph (and its internal properties) will be</span>
<span class="sd">    copied.</span>

<span class="sd">    If ``prune`` is set to ``True``, and ``g`` is specified, only the filtered</span>
<span class="sd">    graph will be copied, and the new graph object will not be</span>
<span class="sd">    filtered. Optionally, a tuple of three booleans can be passed as value to</span>
<span class="sd">    ``prune``, to specify a different behavior to vertex, edge, and reversal</span>
<span class="sd">    filters, respectively.</span>

<span class="sd">    If ``vorder`` is specified, it should correspond to a vertex</span>
<span class="sd">    :class:`~graph_tool.PropertyMap` specifying the ordering of the vertices in</span>
<span class="sd">    the copied graph.</span>

<span class="sd">    The graph is implemented as an `adjacency list`_, where both vertex and edge</span>
<span class="sd">    lists are C++ STL vectors.</span>

<span class="sd">    .. _adjacency list: http://en.wikipedia.org/wiki/Adjacency_list</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">g</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">prune</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">vorder</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__properties</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__known_properties</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__filter_state</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;reversed&quot;</span><span class="p">:</span> <span class="bp">False</span><span class="p">,</span>
                               <span class="s">&quot;edge_filter&quot;</span><span class="p">:</span> <span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="bp">False</span><span class="p">),</span>
                               <span class="s">&quot;vertex_filter&quot;</span><span class="p">:</span> <span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="bp">False</span><span class="p">),</span>
                               <span class="s">&quot;directed&quot;</span><span class="p">:</span> <span class="bp">True</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">g</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span> <span class="o">=</span> <span class="n">libcore</span><span class="o">.</span><span class="n">GraphInterface</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_directed</span><span class="p">(</span><span class="n">directed</span><span class="p">)</span>

            <span class="c"># internal index maps</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__vertex_index</span> <span class="o">=</span> \
                     <span class="n">PropertyMap</span><span class="p">(</span><span class="n">libcore</span><span class="o">.</span><span class="n">get_vertex_index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="p">),</span> <span class="bp">self</span><span class="p">,</span> <span class="s">&quot;v&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__edge_index</span> <span class="o">=</span> \
                     <span class="n">PropertyMap</span><span class="p">(</span><span class="n">libcore</span><span class="o">.</span><span class="n">get_edge_index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="p">),</span> <span class="bp">self</span><span class="p">,</span> <span class="s">&quot;e&quot;</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">prune</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
                <span class="n">vprune</span> <span class="o">=</span> <span class="n">eprune</span> <span class="o">=</span> <span class="n">rprune</span> <span class="o">=</span> <span class="n">prune</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">vprune</span><span class="p">,</span> <span class="n">eprune</span><span class="p">,</span> <span class="n">rprune</span> <span class="o">=</span> <span class="n">prune</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">vprune</span> <span class="ow">or</span> <span class="n">eprune</span> <span class="ow">or</span> <span class="n">rprune</span><span class="p">):</span>
                <span class="n">gv</span> <span class="o">=</span> <span class="n">GraphView</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">skip_vfilt</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                               <span class="n">skip_efilt</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">rprune</span><span class="p">:</span>
                    <span class="n">gv</span><span class="o">.</span><span class="n">set_reversed</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">gv</span> <span class="o">=</span> <span class="n">g</span>

            <span class="c"># The filters may or may not not be in the internal property maps</span>
            <span class="n">vfilt</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">get_vertex_filter</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">efilt</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">get_edge_filter</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">vorder</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="p">((</span><span class="n">vfilt</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">efilt</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">or</span>
                                    <span class="p">(</span><span class="ow">not</span> <span class="n">vprune</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">eprune</span><span class="p">))):</span>
                <span class="c"># Do a simpler, faster copy.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span> <span class="o">=</span> <span class="n">libcore</span><span class="o">.</span><span class="n">GraphInterface</span><span class="p">(</span><span class="n">gv</span><span class="o">.</span><span class="n">__graph</span><span class="p">,</span> <span class="bp">False</span><span class="p">,</span>
                                                      <span class="p">[],</span> <span class="p">[],</span> <span class="bp">None</span><span class="p">)</span>

                <span class="c"># internal index maps</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__vertex_index</span> <span class="o">=</span> \
                         <span class="n">PropertyMap</span><span class="p">(</span><span class="n">libcore</span><span class="o">.</span><span class="n">get_vertex_index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="p">),</span> <span class="bp">self</span><span class="p">,</span> <span class="s">&quot;v&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__edge_index</span> <span class="o">=</span> \
                         <span class="n">PropertyMap</span><span class="p">(</span><span class="n">libcore</span><span class="o">.</span><span class="n">get_edge_index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="p">),</span> <span class="bp">self</span><span class="p">,</span> <span class="s">&quot;e&quot;</span><span class="p">)</span>

                <span class="n">nvfilt</span> <span class="o">=</span> <span class="n">nefilt</span> <span class="o">=</span> <span class="bp">None</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">properties</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">nmap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy_property</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">g</span><span class="o">=</span><span class="n">gv</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">nmap</span>
                    <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="n">vfilt</span><span class="p">:</span>
                        <span class="n">nvfilt</span> <span class="o">=</span> <span class="n">nmap</span>
                    <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="n">efilt</span><span class="p">:</span>
                        <span class="n">nefilt</span> <span class="o">=</span> <span class="n">nmap</span>
                <span class="k">if</span> <span class="n">vfilt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">nvfilt</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="n">nvfilt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy_property</span><span class="p">(</span><span class="n">vfilt</span><span class="p">,</span> <span class="n">g</span><span class="o">=</span><span class="n">gv</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">efilt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">nefilt</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="n">nefilt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy_property</span><span class="p">(</span><span class="n">efilt</span><span class="p">,</span> <span class="n">g</span><span class="o">=</span><span class="n">gv</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_filters</span><span class="p">(</span><span class="n">nefilt</span><span class="p">,</span> <span class="n">nvfilt</span><span class="p">,</span>
                                 <span class="n">inverted_edges</span><span class="o">=</span><span class="n">g</span><span class="o">.</span><span class="n">get_edge_filter</span><span class="p">()[</span><span class="mi">1</span><span class="p">],</span>
                                 <span class="n">inverted_vertices</span><span class="o">=</span><span class="n">g</span><span class="o">.</span><span class="n">get_vertex_filter</span><span class="p">()[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>

                <span class="c"># Copy all internal properties from original graph.</span>
                <span class="n">vprops</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">eprops</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">ef_pos</span> <span class="o">=</span> <span class="n">vf_pos</span> <span class="o">=</span> <span class="bp">None</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">gv</span><span class="o">.</span><span class="n">vertex_properties</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">m</span><span class="o">.</span><span class="n">is_writable</span><span class="p">():</span>
                        <span class="n">m</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="s">&quot;int32_t&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">vprune</span> <span class="ow">and</span> <span class="n">m</span> <span class="ow">is</span> <span class="n">vfilt</span><span class="p">:</span>
                        <span class="n">vf_pos</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">vprops</span><span class="p">)</span>
                    <span class="n">vprops</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">_prop</span><span class="p">(</span><span class="s">&quot;v&quot;</span><span class="p">,</span> <span class="n">gv</span><span class="p">,</span> <span class="n">m</span><span class="p">),</span> <span class="n">libcore</span><span class="o">.</span><span class="n">any</span><span class="p">()])</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">gv</span><span class="o">.</span><span class="n">edge_properties</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">m</span><span class="o">.</span><span class="n">is_writable</span><span class="p">():</span>
                        <span class="n">m</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="s">&quot;int32_t&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">eprune</span> <span class="ow">and</span> <span class="n">m</span> <span class="ow">is</span> <span class="n">efilt</span><span class="p">:</span>
                        <span class="n">ef_pos</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">eprops</span><span class="p">)</span>
                    <span class="n">eprops</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">_prop</span><span class="p">(</span><span class="s">&quot;e&quot;</span><span class="p">,</span> <span class="n">gv</span><span class="p">,</span> <span class="n">m</span><span class="p">),</span> <span class="n">libcore</span><span class="o">.</span><span class="n">any</span><span class="p">()])</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">vprune</span> <span class="ow">and</span> <span class="n">vf_pos</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">vfilt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">vf_pos</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">vprops</span><span class="p">)</span>
                    <span class="n">vprops</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">_prop</span><span class="p">(</span><span class="s">&quot;v&quot;</span><span class="p">,</span> <span class="n">gv</span><span class="p">,</span> <span class="n">vfilt</span><span class="p">),</span> <span class="n">libcore</span><span class="o">.</span><span class="n">any</span><span class="p">()])</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">eprune</span> <span class="ow">and</span> <span class="n">ef_pos</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">efilt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">ef_pos</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">eprops</span><span class="p">)</span>
                    <span class="n">eprops</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">_prop</span><span class="p">(</span><span class="s">&quot;e&quot;</span><span class="p">,</span> <span class="n">gv</span><span class="p">,</span> <span class="n">efilt</span><span class="p">),</span> <span class="n">libcore</span><span class="o">.</span><span class="n">any</span><span class="p">()])</span>

                <span class="c"># The vertex ordering</span>
                <span class="k">if</span> <span class="n">vorder</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">vorder</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="s">&quot;int&quot;</span><span class="p">)</span>
                    <span class="n">vorder</span><span class="o">.</span><span class="n">fa</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">gv</span><span class="o">.</span><span class="n">num_vertices</span><span class="p">())</span>

                <span class="c"># The actual copying of the graph and property maps</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span> <span class="o">=</span> <span class="n">libcore</span><span class="o">.</span><span class="n">GraphInterface</span><span class="p">(</span><span class="n">gv</span><span class="o">.</span><span class="n">__graph</span><span class="p">,</span> <span class="bp">False</span><span class="p">,</span>
                                                      <span class="n">vprops</span><span class="p">,</span>
                                                      <span class="n">eprops</span><span class="p">,</span>
                                                      <span class="n">_prop</span><span class="p">(</span><span class="s">&quot;v&quot;</span><span class="p">,</span> <span class="n">gv</span><span class="p">,</span> <span class="n">vorder</span><span class="p">))</span>
                <span class="c"># internal index maps</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__vertex_index</span> <span class="o">=</span> \
                         <span class="n">PropertyMap</span><span class="p">(</span><span class="n">libcore</span><span class="o">.</span><span class="n">get_vertex_index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="p">),</span> <span class="bp">self</span><span class="p">,</span> <span class="s">&quot;v&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__edge_index</span> <span class="o">=</span> \
                         <span class="n">PropertyMap</span><span class="p">(</span><span class="n">libcore</span><span class="o">.</span><span class="n">get_edge_index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="p">),</span> <span class="bp">self</span><span class="p">,</span> <span class="s">&quot;e&quot;</span><span class="p">)</span>

                <span class="c"># Put the copied properties in the internal dictionary</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">gv</span><span class="o">.</span><span class="n">vertex_properties</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
                    <span class="n">pmap</span> <span class="o">=</span> <span class="n">new_vertex_property</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">value_type</span><span class="p">()</span> <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">is_writable</span><span class="p">()</span> <span class="k">else</span> <span class="s">&quot;int32_t&quot;</span><span class="p">,</span>
                                               <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="o">.</span><span class="n">GetVertexIndex</span><span class="p">(),</span>
                                               <span class="n">vprops</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">vertex_properties</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">PropertyMap</span><span class="p">(</span><span class="n">pmap</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="s">&quot;v&quot;</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">gv</span><span class="o">.</span><span class="n">edge_properties</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
                    <span class="n">pmap</span> <span class="o">=</span> <span class="n">new_edge_property</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">value_type</span><span class="p">()</span> <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">is_writable</span><span class="p">()</span> <span class="k">else</span> <span class="s">&quot;int32_t&quot;</span><span class="p">,</span>
                                             <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="o">.</span><span class="n">GetEdgeIndex</span><span class="p">(),</span>
                                             <span class="n">eprops</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">edge_properties</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">PropertyMap</span><span class="p">(</span><span class="n">pmap</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="s">&quot;e&quot;</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">gv</span><span class="o">.</span><span class="n">graph_properties</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">new_p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_graph_property</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">value_type</span><span class="p">())</span>
                    <span class="n">new_p</span><span class="p">[</span><span class="bp">self</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">gv</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">graph_properties</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_p</span>

                <span class="n">epmap</span> <span class="o">=</span> <span class="n">vpmap</span> <span class="o">=</span> <span class="bp">None</span>
                <span class="k">if</span> <span class="n">vf_pos</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">vpmap</span> <span class="o">=</span> <span class="n">new_vertex_property</span><span class="p">(</span><span class="s">&quot;bool&quot;</span><span class="p">,</span>
                                                <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="o">.</span><span class="n">GetVertexIndex</span><span class="p">(),</span>
                                                <span class="n">vprops</span><span class="p">[</span><span class="n">vf_pos</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">vpmap</span> <span class="o">=</span> <span class="n">PropertyMap</span><span class="p">(</span><span class="n">vpmap</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="s">&quot;v&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ef_pos</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">epmap</span> <span class="o">=</span> <span class="n">new_edge_property</span><span class="p">(</span><span class="s">&quot;bool&quot;</span><span class="p">,</span>
                                              <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="o">.</span><span class="n">GetEdgeIndex</span><span class="p">(),</span>
                                              <span class="n">eprops</span><span class="p">[</span><span class="n">ef_pos</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">epmap</span> <span class="o">=</span> <span class="n">PropertyMap</span><span class="p">(</span><span class="n">epmap</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="s">&quot;e&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_filters</span><span class="p">(</span><span class="n">epmap</span><span class="p">,</span> <span class="n">vpmap</span><span class="p">,</span>
                                 <span class="n">inverted_edges</span><span class="o">=</span><span class="n">g</span><span class="o">.</span><span class="n">get_edge_filter</span><span class="p">()[</span><span class="mi">1</span><span class="p">],</span>
                                 <span class="n">inverted_vertices</span><span class="o">=</span><span class="n">g</span><span class="o">.</span><span class="n">get_vertex_filter</span><span class="p">()[</span><span class="mi">1</span><span class="p">])</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">rprune</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_reversed</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">is_reversed</span><span class="p">())</span>

            <span class="c"># directedness is always a filter</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_directed</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">is_directed</span><span class="p">())</span>

        <span class="c"># modification permissions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__perms</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;add_edge&quot;</span><span class="p">:</span> <span class="bp">True</span><span class="p">,</span> <span class="s">&quot;del_edge&quot;</span><span class="p">:</span> <span class="bp">True</span><span class="p">,</span>
                        <span class="s">&quot;add_vertex&quot;</span><span class="p">:</span> <span class="bp">True</span><span class="p">,</span> <span class="s">&quot;del_vertex&quot;</span><span class="p">:</span> <span class="bp">True</span><span class="p">}</span>

<div class="viewcode-block" id="Graph.copy"><a class="viewcode-back" href="../graph_tool.html#graph_tool.Graph.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a deep copy of self. All :ref:`internal property maps &lt;sec_internal_props&gt;`</span>
<span class="sd">        are also copied.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Graph</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># provide more useful information</span>
        <span class="n">d</span> <span class="o">=</span> <span class="s">&quot;directed&quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_directed</span><span class="p">()</span> <span class="k">else</span> <span class="s">&quot;undirected&quot;</span>
        <span class="n">fr</span> <span class="o">=</span> <span class="s">&quot;, reversed&quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_reversed</span><span class="p">()</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_directed</span><span class="p">()</span> <span class="k">else</span> <span class="s">&quot;&quot;</span>
        <span class="n">f</span> <span class="o">=</span> <span class="s">&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_edge_filter</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">+=</span> <span class="s">&quot;, edges filtered by </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_edge_filter</span><span class="p">()))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_vertex_filter</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">+=</span> <span class="s">&quot;, vertices filtered by </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_vertex_filter</span><span class="p">()))</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_vertices</span><span class="p">()</span>
        <span class="n">e</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()</span>
        <span class="k">return</span> <span class="s">&quot;&lt;</span><span class="si">%s</span><span class="s"> object, </span><span class="si">%s%s</span><span class="s">, with </span><span class="si">%d</span><span class="s"> </span><span class="si">%s</span><span class="s"> and </span><span class="si">%d</span><span class="s"> edge</span><span class="si">%s%s</span><span class="s"> at 0x</span><span class="si">%x</span><span class="s">&gt;&quot;</span>\
               <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">fr</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span>
                  <span class="s">&quot;vertex&quot;</span> <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="s">&quot;vertices&quot;</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="s">&quot;&quot;</span> <span class="k">if</span> <span class="n">e</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="s">&quot;s&quot;</span><span class="p">,</span>
                  <span class="n">f</span><span class="p">,</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

    <span class="c"># Graph access</span>
    <span class="c"># ============</span>

    <span class="k">def</span> <span class="nf">__check_perms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ptype</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__perms</span><span class="p">[</span><span class="n">ptype</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&quot;the graph cannot be modified at this point!&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="Graph.vertices"><a class="viewcode-back" href="../graph_tool.html#graph_tool.Graph.vertices">[docs]</a>    <span class="k">def</span> <span class="nf">vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an :meth:`iterator &lt;iterator.__iter__&gt;` over the vertices.</span>

<span class="sd">        .. note::</span>

<span class="sd">           The order of the vertices traversed by the iterator **always**</span>
<span class="sd">           corresponds to the vertex index ordering, as given by the</span>
<span class="sd">           :attr:`~graph_tool.Graph.vertex_index` property map.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; g = gt.Graph()</span>
<span class="sd">        &gt;&gt;&gt; vlist = list(g.add_vertex(5))</span>
<span class="sd">        &gt;&gt;&gt; vlist2 = []</span>
<span class="sd">        &gt;&gt;&gt; for v in g.vertices():</span>
<span class="sd">        ...     vlist2.append(v)</span>
<span class="sd">        ...</span>
<span class="sd">        &gt;&gt;&gt; assert(vlist == vlist2)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">libcore</span><span class="o">.</span><span class="n">get_vertices</span><span class="p">(</span><span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="Graph.vertex"><a class="viewcode-back" href="../graph_tool.html#graph_tool.Graph.vertex">[docs]</a>    <span class="k">def</span> <span class="nf">vertex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">use_index</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">add_missing</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the vertex with index ``i``. If ``use_index=False``, the</span>
<span class="sd">        ``i``-th vertex is returned (which can differ from the vertex with index</span>
<span class="sd">        ``i`` in case of filtered graphs).</span>

<span class="sd">        If ``add_missing == True``, and the vertex does not exist in the graph,</span>
<span class="sd">        the necessary number of missing vertices are inserted, and the new</span>
<span class="sd">        vertex is returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">vfilt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_vertex_filter</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">vfilt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">use_index</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">libcore</span><span class="o">.</span><span class="n">get_vertex</span><span class="p">(</span><span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_vertex_filter</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">libcore</span><span class="o">.</span><span class="n">get_vertex</span><span class="p">(</span><span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">is_valid</span><span class="p">()</span> <span class="ow">and</span> <span class="n">vfilt</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">v</span><span class="p">]</span> <span class="o">==</span> <span class="n">vfilt</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Invalid vertex index: </span><span class="si">%d</span><span class="s"> (filtered out)&quot;</span> <span class="o">%</span> <span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
            <span class="k">finally</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_vertex_filter</span><span class="p">(</span><span class="n">vfilt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">vfilt</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">v</span><span class="o">.</span><span class="n">is_valid</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">add_missing</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_vertices</span><span class="p">(</span><span class="n">use_index</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">use_index</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Invalid vertex index: </span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">v</span>
</div>
<div class="viewcode-block" id="Graph.edge"><a class="viewcode-back" href="../graph_tool.html#graph_tool.Graph.edge">[docs]</a>    <span class="k">def</span> <span class="nf">edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">all_edges</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">add_missing</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the edge from vertex ``s`` to ``t``, if it exists. If</span>
<span class="sd">        ``all_edges=True`` then a list is returned with all the parallel edges</span>
<span class="sd">        from ``s`` to ``t``, otherwise only one edge is returned.</span>

<span class="sd">        If ``add_missing == True``, a new edge is created and returned, if none</span>
<span class="sd">        currently exists.</span>

<span class="sd">        This operation will take :math:`O(k(s))` time, where :math:`k(s)` is the</span>
<span class="sd">        out-degree of vertex :math:`s`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">s</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">t</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="n">efilt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_edge_filter</span><span class="p">()</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="n">libcore</span><span class="o">.</span><span class="n">get_edge</span><span class="p">(</span><span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">all_edges</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">add_missing</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">all_edges</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">edges</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
</div>
<div class="viewcode-block" id="Graph.edges"><a class="viewcode-back" href="../graph_tool.html#graph_tool.Graph.edges">[docs]</a>    <span class="k">def</span> <span class="nf">edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an :meth:`iterator &lt;iterator.__iter__&gt;` over the edges.</span>

<span class="sd">        .. note::</span>

<span class="sd">           The order of the edges traversed by the iterator **does not**</span>
<span class="sd">           necessarily correspond to the edge index ordering, as given by the</span>
<span class="sd">           :attr:`~graph_tool.Graph.edge_index` property map. This will only</span>
<span class="sd">           happen after :meth:`~graph_tool.Graph.reindex_edges` is called, or in</span>
<span class="sd">           certain situations such as just after a graph is loaded from a</span>
<span class="sd">           file. However, further manipulation of the graph may destroy the</span>
<span class="sd">           ordering.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">libcore</span><span class="o">.</span><span class="n">get_edges</span><span class="p">(</span><span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="Graph.add_vertex"><a class="viewcode-back" href="../graph_tool.html#graph_tool.Graph.add_vertex">[docs]</a>    <span class="k">def</span> <span class="nf">add_vertex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a vertex to the graph, and return it. If ``n != 1``, ``n``</span>
<span class="sd">        vertices are inserted and an iterator over the new vertices is returned.</span>
<span class="sd">        This operation is :math:`O(n)`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">None</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__check_perms</span><span class="p">(</span><span class="s">&quot;add_vertex&quot;</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">libcore</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(</span><span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">n</span><span class="p">)</span>

        <span class="n">vfilt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_vertex_filter</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">vfilt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_vertices</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
            <span class="n">vfilt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="n">N</span> <span class="o">-</span> <span class="n">n</span><span class="p">:</span> <span class="n">N</span><span class="p">]</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">vfilt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">v</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_vertices</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span> <span class="o">-</span> <span class="n">n</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">n</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="Graph.remove_vertex"><a class="viewcode-back" href="../graph_tool.html#graph_tool.Graph.remove_vertex">[docs]</a>    <span class="k">def</span> <span class="nf">remove_vertex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertex</span><span class="p">,</span> <span class="n">fast</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Remove a vertex from the graph. If ``vertex`` is an iterable, it</span>
<span class="sd">        should correspond to a sequence of vertices to be removed.</span>

<span class="sd">        .. note::</span>

<span class="sd">           If the option ``fast == False`` is given, this operation is</span>
<span class="sd">           :math:`O(N + E)` (this is the default). Otherwise it is</span>
<span class="sd">           :math:`O(k + k_{\text{last}})`, where :math:`k` is the (total)</span>
<span class="sd">           degree of the vertex being deleted, and :math:`k_{\text{last}}` is</span>
<span class="sd">           the (total) degree of the vertex with the largest index.</span>

<span class="sd">        .. warning::</span>

<span class="sd">           This operation may invalidate vertex descriptors. Vertices are always</span>
<span class="sd">           indexed contiguously in the range :math:`[0, N-1]`, hence vertex</span>
<span class="sd">           descriptors with an index higher than ``vertex`` will be invalidated</span>
<span class="sd">           after removal (if ``fast == False``, otherwise only descriptors</span>
<span class="sd">           pointing to vertices with the largest index will be invalidated).</span>

<span class="sd">           Because of this, the only safe way to remove more than one vertex at</span>
<span class="sd">           once is to sort them in decreasing index order:</span>

<span class="sd">           .. code::</span>

<span class="sd">               # &#39;del_list&#39; is a list of vertex descriptors</span>
<span class="sd">               for v in reversed(sorted(del_list)):</span>
<span class="sd">                   g.remove_vertex(v)</span>

<span class="sd">           Alternatively (and preferably), a list (or iterable) may be passed</span>
<span class="sd">           directly as the ``vertex`` parameter, and the above is performed</span>
<span class="sd">           internally (in C++).</span>

<span class="sd">        .. warning::</span>

<span class="sd">           If ``fast == True``, the vertex being deleted is &#39;swapped&#39; with the</span>
<span class="sd">           last vertex (i.e. with the largest index), which will in turn inherit</span>
<span class="sd">           the index of the vertex being deleted. All property maps associated</span>
<span class="sd">           with the graph will be properly updated, but the index ordering of</span>
<span class="sd">           the graph will no longer be the same.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__check_perms</span><span class="p">(</span><span class="s">&quot;del_vertex&quot;</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">vs</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">vertex</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&quot;int64&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">vs</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">vertex</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&quot;int64&quot;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="n">vs</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vertex</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&quot;int64&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">vs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span>

            <span class="n">vs</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">vs</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">back</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="o">.</span><span class="n">GetNumberOfVertices</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">vs</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">back</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Vertex index </span><span class="si">%d</span><span class="s"> is invalid&quot;</span> <span class="o">%</span> <span class="n">vs</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>

        <span class="c"># move / shift all known property maps</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">vs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">vs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">back</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">pmap</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__known_properties</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">pmap</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">pmap</span><span class="p">()</span><span class="o">.</span><span class="n">key_type</span><span class="p">()</span> <span class="o">==</span> <span class="s">&quot;v&quot;</span> <span class="ow">and</span> <span class="n">pmap</span><span class="p">()</span><span class="o">.</span><span class="n">is_writable</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">fast</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="o">.</span><span class="n">MoveVertexProperty</span><span class="p">(</span><span class="n">pmap</span><span class="p">()</span><span class="o">.</span><span class="n">_PropertyMap__map</span><span class="o">.</span><span class="n">get_map</span><span class="p">(),</span> <span class="n">vs</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="o">.</span><span class="n">ShiftVertexProperty</span><span class="p">(</span><span class="n">pmap</span><span class="p">()</span><span class="o">.</span><span class="n">_PropertyMap__map</span><span class="o">.</span><span class="n">get_map</span><span class="p">(),</span> <span class="n">vs</span><span class="p">)</span>

        <span class="n">libcore</span><span class="o">.</span><span class="n">remove_vertex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="p">,</span> <span class="n">vs</span><span class="p">,</span> <span class="n">fast</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Graph.clear_vertex"><a class="viewcode-back" href="../graph_tool.html#graph_tool.Graph.clear_vertex">[docs]</a>    <span class="k">def</span> <span class="nf">clear_vertex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertex</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove all in and out-edges from the given vertex.&quot;&quot;&quot;</span>
        <span class="n">del_es</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">vertex</span><span class="o">.</span><span class="n">all_edges</span><span class="p">():</span>
            <span class="n">del_es</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">del_es</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Graph.add_edge"><a class="viewcode-back" href="../graph_tool.html#graph_tool.Graph.add_edge">[docs]</a>    <span class="k">def</span> <span class="nf">add_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">add_missing</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a new edge from ``source`` to ``target`` to the graph, and return</span>
<span class="sd">        it. This operation is :math:`O(1)`.</span>

<span class="sd">        If ``add_missing == True``, the source and target vertices are included</span>
<span class="sd">        in the graph if they don&#39;t yet exist.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__check_perms</span><span class="p">(</span><span class="s">&quot;add_edge&quot;</span><span class="p">)</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">libcore</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">source</span><span class="p">),</span> <span class="n">add_missing</span><span class="o">=</span><span class="n">add_missing</span><span class="p">),</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">target</span><span class="p">),</span> <span class="n">add_missing</span><span class="o">=</span><span class="n">add_missing</span><span class="p">))</span>
        <span class="n">efilt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_edge_filter</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">efilt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">efilt</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">efilt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">e</span>
</div>
<div class="viewcode-block" id="Graph.remove_edge"><a class="viewcode-back" href="../graph_tool.html#graph_tool.Graph.remove_edge">[docs]</a>    <span class="k">def</span> <span class="nf">remove_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Remove an edge from the graph.</span>

<span class="sd">        .. note::</span>

<span class="sd">           This operation is normally :math:`O(k_s + k_t)`, where :math:`k_s`</span>
<span class="sd">           and :math:`k_s` are the total degrees of the source and target</span>
<span class="sd">           vertices, respectively. However, if :meth:`~Graph.set_fast_edge_removal`</span>
<span class="sd">           is set to `True`, this operation becomes :math:`O(1)`.</span>

<span class="sd">        .. warning::</span>

<span class="sd">           The relative ordering of the remaining edges in the graph is kept</span>
<span class="sd">           unchanged, unless :meth:`~Graph.set_fast_edge_removal` is set to</span>
<span class="sd">           `True`, in which case it can change.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__check_perms</span><span class="p">(</span><span class="s">&quot;del_edge&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">libcore</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="p">,</span> <span class="n">edge</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Graph.add_edge_list"><a class="viewcode-back" href="../graph_tool.html#graph_tool.Graph.add_edge_list">[docs]</a>    <span class="k">def</span> <span class="nf">add_edge_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_list</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a list of edges to the graph, given by ``edge_list``, which can</span>
<span class="sd">        be a list of ``(source, target)`` pairs where both ``source`` and</span>
<span class="sd">        ``target`` are vertex indexes, or a :class:`~numpy.ndarray` of shape</span>
<span class="sd">        ``(E,2)``, where ``E`` is the number of edges, and each line specifies a </span>
<span class="sd">        ``(source, target)`` pair. If the list references vertices which do not</span>
<span class="sd">        exist in the graph, they will be created.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__check_perms</span><span class="p">(</span><span class="s">&quot;add_edge&quot;</span><span class="p">)</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">edge_list</span><span class="p">)</span>
        <span class="n">libcore</span><span class="o">.</span><span class="n">add_edge_list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="p">,</span> <span class="n">edges</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Graph.set_fast_edge_removal"><a class="viewcode-back" href="../graph_tool.html#graph_tool.Graph.set_fast_edge_removal">[docs]</a>    <span class="k">def</span> <span class="nf">set_fast_edge_removal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fast</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;If ``fast == True`` the fast :math:`O(1)` removal of edges will be</span>
<span class="sd">        enabled. This requires an additional data structure of size :math:`O(E)`</span>
<span class="sd">        to be kept at all times.  If ``fast == False``, this data structure is</span>
<span class="sd">        destroyed.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="o">.</span><span class="n">SetKeepEpos</span><span class="p">(</span><span class="n">fast</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Graph.get_fast_edge_removal"><a class="viewcode-back" href="../graph_tool.html#graph_tool.Graph.get_fast_edge_removal">[docs]</a>    <span class="k">def</span> <span class="nf">get_fast_edge_removal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Return whether the fast :math:`O(1)` removal of edges is currently</span>
<span class="sd">        enabled.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="o">.</span><span class="n">GetKeepEpos</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Graph.clear"><a class="viewcode-back" href="../graph_tool.html#graph_tool.Graph.clear">[docs]</a>    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove all vertices and edges from the graph.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__check_perms</span><span class="p">(</span><span class="s">&quot;del_vertex&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__check_perms</span><span class="p">(</span><span class="s">&quot;del_edge&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="o">.</span><span class="n">Clear</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Graph.clear_edges"><a class="viewcode-back" href="../graph_tool.html#graph_tool.Graph.clear_edges">[docs]</a>    <span class="k">def</span> <span class="nf">clear_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove all edges from the graph.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__check_perms</span><span class="p">(</span><span class="s">&quot;del_edge&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="o">.</span><span class="n">ClearEdges</span><span class="p">()</span>

    <span class="c"># Internal property maps</span>
    <span class="c"># ======================</span>

    <span class="c"># all properties</span></div>
    <span class="k">def</span> <span class="nf">__get_properties</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">PropertyDict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__properties</span><span class="p">,</span>
                            <span class="k">lambda</span> <span class="n">g</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">g</span><span class="o">.</span><span class="n">__properties</span><span class="p">[</span><span class="n">k</span><span class="p">],</span>
                            <span class="k">lambda</span> <span class="n">g</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">g</span><span class="o">.</span><span class="n">__set_property</span><span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">v</span><span class="p">),</span>
                            <span class="k">lambda</span> <span class="n">g</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">g</span><span class="o">.</span><span class="n">__del_property</span><span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

    <span class="nd">@_limit_args</span><span class="p">({</span><span class="s">&quot;t&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s">&quot;v&quot;</span><span class="p">,</span> <span class="s">&quot;e&quot;</span><span class="p">,</span> <span class="s">&quot;g&quot;</span><span class="p">]})</span>
    <span class="nd">@_require</span><span class="p">(</span><span class="s">&quot;k&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__set_property</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">t</span> <span class="o">==</span> <span class="s">&quot;g&quot;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">PropertyMap</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__properties</span><span class="p">[(</span><span class="n">t</span><span class="p">,</span> <span class="n">k</span><span class="p">)][</span><span class="bp">self</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">t</span> <span class="o">!=</span> <span class="n">v</span><span class="o">.</span><span class="n">key_type</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;wrong key type for property map&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__properties</span><span class="p">[(</span><span class="n">t</span><span class="p">,</span> <span class="n">k</span><span class="p">)]</span> <span class="o">=</span> <span class="n">v</span>

    <span class="nd">@_limit_args</span><span class="p">({</span><span class="s">&quot;t&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s">&quot;v&quot;</span><span class="p">,</span> <span class="s">&quot;e&quot;</span><span class="p">,</span> <span class="s">&quot;g&quot;</span><span class="p">]})</span>
    <span class="nd">@_require</span><span class="p">(</span><span class="s">&quot;k&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__del_property</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">__properties</span><span class="p">[(</span><span class="n">t</span><span class="p">,</span> <span class="n">k</span><span class="p">)]</span>

    <span class="n">properties</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">__get_properties</span><span class="p">,</span>
                          <span class="n">doc</span><span class="o">=</span>
    <span class="sd">&quot;&quot;&quot;Dictionary of internal properties. Keys must always be a tuple, where the</span>
<span class="sd">    first element if a string from the set {&#39;v&#39;, &#39;e&#39;, &#39;g&#39;}, representing a</span>
<span class="sd">    vertex, edge or graph property, respectively, and the second element is the</span>
<span class="sd">    name of the property map.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; g = gt.Graph()</span>
<span class="sd">    &gt;&gt;&gt; g.properties[(&quot;e&quot;, &quot;foo&quot;)] = g.new_edge_property(&quot;vector&lt;double&gt;&quot;)</span>
<span class="sd">    &gt;&gt;&gt; del g.properties[(&quot;e&quot;, &quot;foo&quot;)]</span>
<span class="sd">    &quot;&quot;&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__get_specific_properties</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="n">props</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__properties</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> \
                      <span class="k">if</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">t</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">props</span>

    <span class="c"># vertex properties</span>
    <span class="k">def</span> <span class="nf">__get_vertex_properties</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">PropertyDict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_specific_properties</span><span class="p">(</span><span class="s">&quot;v&quot;</span><span class="p">),</span>
                            <span class="k">lambda</span> <span class="n">g</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">g</span><span class="o">.</span><span class="n">__properties</span><span class="p">[(</span><span class="s">&quot;v&quot;</span><span class="p">,</span> <span class="n">k</span><span class="p">)],</span>
                            <span class="k">lambda</span> <span class="n">g</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">g</span><span class="o">.</span><span class="n">__set_property</span><span class="p">(</span><span class="s">&quot;v&quot;</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">),</span>
                            <span class="k">lambda</span> <span class="n">g</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">g</span><span class="o">.</span><span class="n">__del_property</span><span class="p">(</span><span class="s">&quot;v&quot;</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span>
    <span class="n">vertex_properties</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">__get_vertex_properties</span><span class="p">,</span>
                                 <span class="n">doc</span><span class="o">=</span><span class="s">&quot;Dictionary of internal vertex properties. The keys are the property names.&quot;</span><span class="p">)</span>
    <span class="n">vp</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">__get_vertex_properties</span><span class="p">,</span>
                  <span class="n">doc</span><span class="o">=</span><span class="s">&quot;Alias to :attr:`~Graph.vertex_properties`.&quot;</span><span class="p">)</span>

    <span class="c"># edge properties</span>
    <span class="k">def</span> <span class="nf">__get_edge_properties</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">PropertyDict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_specific_properties</span><span class="p">(</span><span class="s">&quot;e&quot;</span><span class="p">),</span>
                            <span class="k">lambda</span> <span class="n">g</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">g</span><span class="o">.</span><span class="n">__properties</span><span class="p">[(</span><span class="s">&quot;e&quot;</span><span class="p">,</span> <span class="n">k</span><span class="p">)],</span>
                            <span class="k">lambda</span> <span class="n">g</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">g</span><span class="o">.</span><span class="n">__set_property</span><span class="p">(</span><span class="s">&quot;e&quot;</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">),</span>
                            <span class="k">lambda</span> <span class="n">g</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">g</span><span class="o">.</span><span class="n">__del_property</span><span class="p">(</span><span class="s">&quot;e&quot;</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span>
    <span class="n">edge_properties</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">__get_edge_properties</span><span class="p">,</span>
                                 <span class="n">doc</span><span class="o">=</span><span class="s">&quot;Dictionary of internal edge properties. The keys are the property names.&quot;</span><span class="p">)</span>
    <span class="n">ep</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">__get_edge_properties</span><span class="p">,</span>
                  <span class="n">doc</span><span class="o">=</span><span class="s">&quot;Alias to :attr:`~Graph.edge_properties`.&quot;</span><span class="p">)</span>

    <span class="c"># graph properties</span>
    <span class="k">def</span> <span class="nf">__get_graph_properties</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">PropertyDict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_specific_properties</span><span class="p">(</span><span class="s">&quot;g&quot;</span><span class="p">),</span>
                            <span class="k">lambda</span> <span class="n">g</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">g</span><span class="o">.</span><span class="n">__properties</span><span class="p">[(</span><span class="s">&quot;g&quot;</span><span class="p">,</span> <span class="n">k</span><span class="p">)][</span><span class="n">g</span><span class="p">],</span>
                            <span class="k">lambda</span> <span class="n">g</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">g</span><span class="o">.</span><span class="n">__set_property</span><span class="p">(</span><span class="s">&quot;g&quot;</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">),</span>
                            <span class="k">lambda</span> <span class="n">g</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">g</span><span class="o">.</span><span class="n">__del_property</span><span class="p">(</span><span class="s">&quot;g&quot;</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span>
    <span class="n">graph_properties</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">__get_graph_properties</span><span class="p">,</span>
                                 <span class="n">doc</span><span class="o">=</span><span class="s">&quot;Dictionary of internal graph properties. The keys are the property names.&quot;</span><span class="p">)</span>
    <span class="n">gp</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">__get_graph_properties</span><span class="p">,</span>
                  <span class="n">doc</span><span class="o">=</span><span class="s">&quot;Alias to :attr:`~Graph.graph_properties`.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">own_property</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prop</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a version of the property map &#39;prop&#39; (possibly belonging to</span>
<span class="sd">        another graph) which is owned by the current graph.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">PropertyMap</span><span class="p">(</span><span class="n">prop</span><span class="o">.</span><span class="n">_PropertyMap__map</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">prop</span><span class="o">.</span><span class="n">key_type</span><span class="p">())</span>

<div class="viewcode-block" id="Graph.list_properties"><a class="viewcode-back" href="../graph_tool.html#graph_tool.Graph.list_properties">[docs]</a>    <span class="k">def</span> <span class="nf">list_properties</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Print a list of all internal properties.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; g = gt.Graph()</span>
<span class="sd">        &gt;&gt;&gt; g.properties[(&quot;e&quot;, &quot;foo&quot;)] = g.new_edge_property(&quot;vector&lt;double&gt;&quot;)</span>
<span class="sd">        &gt;&gt;&gt; g.vertex_properties[&quot;foo&quot;] = g.new_vertex_property(&quot;double&quot;)</span>
<span class="sd">        &gt;&gt;&gt; g.vertex_properties[&quot;bar&quot;] = g.new_vertex_property(&quot;python::object&quot;)</span>
<span class="sd">        &gt;&gt;&gt; g.graph_properties[&quot;gnat&quot;] = g.new_graph_property(&quot;string&quot;, &quot;hi there!&quot;)</span>
<span class="sd">        &gt;&gt;&gt; g.list_properties()</span>
<span class="sd">        gnat           (graph)   (type: string, val: hi there!)</span>
<span class="sd">        bar            (vertex)  (type: python::object)</span>
<span class="sd">        foo            (vertex)  (type: double)</span>
<span class="sd">        foo            (edge)    (type: vector&lt;double&gt;)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__properties</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">w</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__properties</span><span class="o">.</span><span class="n">keys</span><span class="p">())])</span> <span class="o">+</span> <span class="mi">4</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">w</span> <span class="k">if</span> <span class="n">w</span> <span class="o">&gt;</span> <span class="mi">14</span> <span class="k">else</span> <span class="mi">14</span>

        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__properties</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">&quot;g&quot;</span><span class="p">:</span>
                <span class="n">pref</span><span class="o">=</span><span class="s">&quot;</span><span class="si">%%</span><span class="s">-</span><span class="si">%d</span><span class="s">s (graph)   (type: </span><span class="si">%%</span><span class="s">s, val: &quot;</span> <span class="o">%</span> <span class="n">w</span> <span class="o">%</span> \
                      <span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">v</span><span class="o">.</span><span class="n">value_type</span><span class="p">())</span>
                <span class="n">val</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="bp">self</span><span class="p">])</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1000</span><span class="p">:</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="p">[:</span><span class="mi">1000</span><span class="p">]</span> <span class="o">+</span> <span class="s">&quot;...&quot;</span>
                <span class="n">tw</span> <span class="o">=</span> <span class="n">terminal_size</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">textwrap</span><span class="o">.</span><span class="n">indent</span><span class="p">(</span><span class="n">textwrap</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">val</span><span class="p">,</span>
                                                    <span class="n">width</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="n">tw</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">pref</span><span class="p">),</span> <span class="mi">1</span><span class="p">)),</span>
                                      <span class="s">&quot; &quot;</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">pref</span><span class="p">))</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">pref</span><span class="p">):]</span>
                <span class="k">print</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s%s</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">pref</span><span class="p">,</span> <span class="n">val</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__properties</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">&quot;v&quot;</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%%</span><span class="s">-</span><span class="si">%d</span><span class="s">s (vertex)  (type: </span><span class="si">%%</span><span class="s">s)&quot;</span> <span class="o">%</span> <span class="n">w</span> <span class="o">%</span> <span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                                            <span class="n">v</span><span class="o">.</span><span class="n">value_type</span><span class="p">()))</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__properties</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">&quot;e&quot;</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%%</span><span class="s">-</span><span class="si">%d</span><span class="s">s (edge)    (type: </span><span class="si">%%</span><span class="s">s)&quot;</span> <span class="o">%</span> <span class="n">w</span> <span class="o">%</span> <span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                                            <span class="n">v</span><span class="o">.</span><span class="n">value_type</span><span class="p">()))</span>

    <span class="c"># index properties</span>
</div>
    <span class="k">def</span> <span class="nf">_get_vertex_index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__vertex_index</span>
    <span class="n">vertex_index</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_vertex_index</span><span class="p">,</span>
                            <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;Vertex index map.</span>

<span class="s">                            It maps for each vertex in the graph an unique</span>
<span class="s">                            integer in the range [0, :meth:`~graph_tool.Graph.num_vertices` - 1].</span>

<span class="s">                            .. note::</span>

<span class="s">                                Like :attr:`~graph_tool.Graph.edge_index`, this</span>
<span class="s">                                is a special instance of a :class:`~graph_tool.PropertyMap`</span>
<span class="s">                                class, which is **immutable**, and cannot be</span>
<span class="s">                                accessed as an array.&quot;&quot;&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_edge_index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__edge_index</span>
    <span class="n">edge_index</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_edge_index</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;Edge index map.</span>

<span class="s">                            It maps for each edge in the graph an unique</span>
<span class="s">                            integer.</span>

<span class="s">                            .. note::</span>

<span class="s">                                Like :attr:`~graph_tool.Graph.vertex_index`, this</span>
<span class="s">                                is a special instance of a :class:`~graph_tool.PropertyMap`</span>
<span class="s">                                class, which is **immutable**, and cannot be</span>
<span class="s">                                accessed as an array.</span>

<span class="s">                                Additionally, the indexes may not necessarily</span>
<span class="s">                                lie in the range [0, :meth:`~graph_tool.Graph.num_edges` - 1].</span>
<span class="s">                                However this will always happen whenever no</span>
<span class="s">                                edges are deleted from the graph.&quot;&quot;&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_max_edge_index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="o">.</span><span class="n">GetMaxEdgeIndex</span><span class="p">()</span>

    <span class="n">max_edge_index</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_max_edge_index</span><span class="p">,</span>
                              <span class="n">doc</span><span class="o">=</span><span class="s">&quot;The maximum value of the edge index map.&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="Graph.reindex_edges"><a class="viewcode-back" href="../graph_tool.html#graph_tool.Graph.reindex_edges">[docs]</a>    <span class="k">def</span> <span class="nf">reindex_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reset the edge indexes so that they lie in the [0, :meth:`~graph_tool.Graph.num_edges` - 1]</span>
<span class="sd">        range. The index ordering will be compatible with the sequence returned</span>
<span class="sd">        by the :meth:`~graph_tool.Graph.edges` function.</span>

<span class="sd">        .. WARNING::</span>

<span class="sd">           Calling this function will invalidate all existing edge property</span>
<span class="sd">           maps, if the index ordering is modified! The property maps will still</span>
<span class="sd">           be usable, but their contents will still be tied to the old indexes,</span>
<span class="sd">           and thus may become scrambled.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="o">.</span><span class="n">ReIndexEdges</span><span class="p">()</span>

    <span class="c"># Property map creation</span>
</div>
<div class="viewcode-block" id="Graph.new_property"><a class="viewcode-back" href="../graph_tool.html#graph_tool.Graph.new_property">[docs]</a>    <span class="k">def</span> <span class="nf">new_property</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key_type</span><span class="p">,</span> <span class="n">value_type</span><span class="p">,</span> <span class="n">vals</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a new (uninitialized) vertex property map of key type</span>
<span class="sd">        ``key_type`` (``v``, ``e`` or ``g``), value type ``value_type``, and</span>
<span class="sd">        return it. If provided, the values will be initialized by ``vals``,</span>
<span class="sd">        which should be a sequence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">key_type</span> <span class="o">==</span> <span class="s">&quot;v&quot;</span> <span class="ow">or</span> <span class="n">key_type</span> <span class="o">==</span> <span class="s">&quot;vertex&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="n">value_type</span><span class="p">,</span> <span class="n">vals</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">key_type</span> <span class="o">==</span> <span class="s">&quot;e&quot;</span> <span class="ow">or</span> <span class="n">key_type</span> <span class="o">==</span> <span class="s">&quot;edge&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_edge_property</span><span class="p">(</span><span class="n">value_type</span><span class="p">,</span> <span class="n">vals</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">key_type</span> <span class="o">==</span> <span class="s">&quot;g&quot;</span> <span class="ow">or</span> <span class="n">key_type</span> <span class="o">==</span> <span class="s">&quot;graph&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_graph_property</span><span class="p">(</span><span class="n">value_type</span><span class="p">,</span> <span class="n">vals</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;unknown key type: &quot;</span> <span class="o">+</span> <span class="n">key_type</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Graph.new_vertex_property"><a class="viewcode-back" href="../graph_tool.html#graph_tool.Graph.new_vertex_property">[docs]</a>    <span class="k">def</span> <span class="nf">new_vertex_property</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value_type</span><span class="p">,</span> <span class="n">vals</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a new (uninitialized) vertex property map of type ``value_type``,</span>
<span class="sd">        and return it. If provided, the values will be initialized by ``vals``,</span>
<span class="sd">        which should be either a sequence or a single value.&quot;&quot;&quot;</span>
        <span class="n">prop</span> <span class="o">=</span> <span class="n">PropertyMap</span><span class="p">(</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="n">_type_alias</span><span class="p">(</span><span class="n">value_type</span><span class="p">),</span>
                                               <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="o">.</span><span class="n">GetVertexIndex</span><span class="p">(),</span>
                                               <span class="n">libcore</span><span class="o">.</span><span class="n">any</span><span class="p">()),</span>
                           <span class="bp">self</span><span class="p">,</span> <span class="s">&quot;v&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">vals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">prop</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">vals</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">(),</span> <span class="n">vals</span><span class="p">):</span>
                    <span class="n">prop</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
        <span class="k">return</span> <span class="n">prop</span>
</div>
<div class="viewcode-block" id="Graph.new_edge_property"><a class="viewcode-back" href="../graph_tool.html#graph_tool.Graph.new_edge_property">[docs]</a>    <span class="k">def</span> <span class="nf">new_edge_property</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value_type</span><span class="p">,</span> <span class="n">vals</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a new (uninitialized) edge property map of type</span>
<span class="sd">        ``value_type``, and return it. If provided, the values will be</span>
<span class="sd">        initialized by ``vals``, which should be a sequence or a single value.&quot;&quot;&quot;</span>
        <span class="n">prop</span> <span class="o">=</span> <span class="n">PropertyMap</span><span class="p">(</span><span class="n">new_edge_property</span><span class="p">(</span><span class="n">_type_alias</span><span class="p">(</span><span class="n">value_type</span><span class="p">),</span>
                                             <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="o">.</span><span class="n">GetEdgeIndex</span><span class="p">(),</span>
                                             <span class="n">libcore</span><span class="o">.</span><span class="n">any</span><span class="p">()),</span>
                           <span class="bp">self</span><span class="p">,</span> <span class="s">&quot;e&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">vals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">prop</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">vals</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">e</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">(),</span> <span class="n">vals</span><span class="p">):</span>
                    <span class="n">prop</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
        <span class="k">return</span> <span class="n">prop</span>
</div>
<div class="viewcode-block" id="Graph.new_graph_property"><a class="viewcode-back" href="../graph_tool.html#graph_tool.Graph.new_graph_property">[docs]</a>    <span class="k">def</span> <span class="nf">new_graph_property</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value_type</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a new graph property map of type ``value_type``, and return</span>
<span class="sd">        it. If ``val`` is not None, the property is initialized to its value.&quot;&quot;&quot;</span>
        <span class="n">prop</span> <span class="o">=</span> <span class="n">PropertyMap</span><span class="p">(</span><span class="n">new_graph_property</span><span class="p">(</span><span class="n">_type_alias</span><span class="p">(</span><span class="n">value_type</span><span class="p">),</span>
                                              <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="o">.</span><span class="n">GetGraphIndex</span><span class="p">(),</span>
                                              <span class="n">libcore</span><span class="o">.</span><span class="n">any</span><span class="p">()),</span>
                           <span class="bp">self</span><span class="p">,</span> <span class="s">&quot;g&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">prop</span><span class="p">[</span><span class="bp">self</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="k">return</span> <span class="n">prop</span>

    <span class="c"># property map copying</span></div>
    <span class="nd">@_require</span><span class="p">(</span><span class="s">&quot;src&quot;</span><span class="p">,</span> <span class="n">PropertyMap</span><span class="p">)</span>
    <span class="nd">@_require</span><span class="p">(</span><span class="s">&quot;tgt&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">PropertyMap</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">None</span><span class="p">)))</span>
<div class="viewcode-block" id="Graph.copy_property"><a class="viewcode-back" href="../graph_tool.html#graph_tool.Graph.copy_property">[docs]</a>    <span class="k">def</span> <span class="nf">copy_property</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">tgt</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">value_type</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">g</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Copy contents of ``src`` property to ``tgt`` property. If ``tgt`` is</span>
<span class="sd">        None, then a new property map of the same type (or with the type given</span>
<span class="sd">        by the optional ``value_type`` parameter) is created, and returned. The</span>
<span class="sd">        optional parameter g specifies the (identical) source graph to copy</span>
<span class="sd">        properties from (defaults to self).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">tgt</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">tgt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_property</span><span class="p">(</span><span class="n">src</span><span class="o">.</span><span class="n">key_type</span><span class="p">(),</span>
                                    <span class="p">(</span><span class="n">src</span><span class="o">.</span><span class="n">value_type</span><span class="p">()</span>
                                     <span class="k">if</span> <span class="n">value_type</span> <span class="o">==</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">value_type</span><span class="p">))</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">tgt</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="k">if</span> <span class="n">src</span><span class="o">.</span><span class="n">key_type</span><span class="p">()</span> <span class="o">!=</span> <span class="n">tgt</span><span class="o">.</span><span class="n">key_type</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;source and target properties must have the same&quot;</span> <span class="o">+</span>
                             <span class="s">&quot; key type&quot;</span><span class="p">)</span>

        <span class="n">u</span> <span class="o">=</span> <span class="bp">self</span> <span class="k">if</span> <span class="n">g</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">g</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">GraphView</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="nb">reversed</span><span class="o">=</span><span class="n">u</span><span class="o">.</span><span class="n">is_reversed</span><span class="p">(),</span>
                      <span class="n">skip_properties</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">src</span><span class="o">.</span><span class="n">key_type</span><span class="p">()</span> <span class="o">==</span> <span class="s">&quot;v&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="o">.</span><span class="n">CopyVertexProperty</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">__graph</span><span class="p">,</span> <span class="n">_prop</span><span class="p">(</span><span class="s">&quot;v&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">src</span><span class="p">),</span>
                                            <span class="n">_prop</span><span class="p">(</span><span class="s">&quot;v&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">tgt</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">src</span><span class="o">.</span><span class="n">key_type</span><span class="p">()</span> <span class="o">==</span> <span class="s">&quot;e&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="o">.</span><span class="n">CopyEdgeProperty</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">__graph</span><span class="p">,</span> <span class="n">_prop</span><span class="p">(</span><span class="s">&quot;e&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">src</span><span class="p">),</span>
                                            <span class="n">_prop</span><span class="p">(</span><span class="s">&quot;e&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">tgt</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tgt</span><span class="p">[</span><span class="bp">self</span><span class="p">]</span> <span class="o">=</span> <span class="n">src</span><span class="p">[</span><span class="n">g</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="c"># degree property map</span></div>
    <span class="nd">@_limit_args</span><span class="p">({</span><span class="s">&quot;deg&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s">&quot;in&quot;</span><span class="p">,</span> <span class="s">&quot;out&quot;</span><span class="p">,</span> <span class="s">&quot;total&quot;</span><span class="p">]})</span>
<div class="viewcode-block" id="Graph.degree_property_map"><a class="viewcode-back" href="../graph_tool.html#graph_tool.Graph.degree_property_map">[docs]</a>    <span class="k">def</span> <span class="nf">degree_property_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deg</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create and return a vertex property map containing the degree type</span>
<span class="sd">        given by ``deg``, which can be any of ``&quot;in&quot;``, ``&quot;out&quot;``, or ``&quot;total&quot;``.</span>
<span class="sd">        If provided, ``weight`` should be an edge :class:`~graph_tool.PropertyMap`</span>
<span class="sd">        containing the edge weights which should be summed.&quot;&quot;&quot;</span>
        <span class="n">pmap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="o">.</span><span class="n">DegreeMap</span><span class="p">(</span><span class="n">deg</span><span class="p">,</span> <span class="n">_prop</span><span class="p">(</span><span class="s">&quot;e&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">weight</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">PropertyMap</span><span class="p">(</span><span class="n">pmap</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="s">&quot;v&quot;</span><span class="p">)</span>

    <span class="c"># I/O operations</span>
    <span class="c"># ==============</span></div>
    <span class="k">def</span> <span class="nf">__get_file_format</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_name</span><span class="p">):</span>
        <span class="n">fmt</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&quot;gt&quot;</span><span class="p">,</span> <span class="s">&quot;graphml&quot;</span><span class="p">,</span> <span class="s">&quot;xml&quot;</span><span class="p">,</span> <span class="s">&quot;dot&quot;</span><span class="p">,</span> <span class="s">&quot;gml&quot;</span><span class="p">]:</span>
            <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;.&quot;</span> <span class="o">+</span> <span class="n">f</span><span class="p">,</span> <span class="s">&quot;.</span><span class="si">%s</span><span class="s">.gz&quot;</span> <span class="o">%</span> <span class="n">f</span><span class="p">,</span> <span class="s">&quot;.</span><span class="si">%s</span><span class="s">.bz2&quot;</span> <span class="o">%</span> <span class="n">f</span><span class="p">,</span> <span class="s">&quot;.</span><span class="si">%s</span><span class="s">.xz&quot;</span> <span class="o">%</span> <span class="n">f</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">file_name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
                    <span class="n">fmt</span> <span class="o">=</span> <span class="n">f</span>
                    <span class="k">break</span>
        <span class="k">if</span> <span class="n">fmt</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;cannot determine file format of: &quot;</span> <span class="o">+</span> <span class="n">file_name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fmt</span>

<div class="viewcode-block" id="Graph.load"><a class="viewcode-back" href="../graph_tool.html#graph_tool.Graph.load">[docs]</a>    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_name</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s">&quot;auto&quot;</span><span class="p">,</span> <span class="n">ignore_vp</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">ignore_ep</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
             <span class="n">ignore_gp</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Load graph from ``file_name`` (which can be either a string or a file-like</span>
<span class="sd">        object). The format is guessed from ``file_name``, or can be specified</span>
<span class="sd">        by ``fmt``, which can be either &quot;gt&quot;, &quot;graphml&quot;, &quot;xml&quot;, &quot;dot&quot; or &quot;gml&quot;.</span>
<span class="sd">        (Note that &quot;graphml&quot; and &quot;xml&quot; are synonyms).</span>

<span class="sd">        If provided, the parameters ``ignore_vp``, ``ignore_ep`` and</span>
<span class="sd">        ``ignore_gp``, should contain a list of property names (vertex, edge or</span>
<span class="sd">        graph, respectively) which should be ignored when reading the file.</span>

<span class="sd">        .. warning::</span>

<span class="sd">           The only file formats which are capable of perfectly preserving the</span>
<span class="sd">           internal property maps are &quot;gt&quot; and &quot;graphml&quot;. Because of this,</span>
<span class="sd">           they should be preferred over the other formats whenever possible.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">file_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="n">file_name</span><span class="p">)</span>
            <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_name</span><span class="p">)</span> <span class="c"># throw the appropriate exception, if not found</span>
        <span class="k">if</span> <span class="n">fmt</span> <span class="o">==</span> <span class="s">&#39;auto&#39;</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">fmt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_file_format</span><span class="p">(</span><span class="n">file_name</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">fmt</span> <span class="o">==</span> <span class="s">&quot;auto&quot;</span><span class="p">:</span>
            <span class="n">fmt</span> <span class="o">=</span> <span class="s">&quot;gt&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">file_name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s">&quot;.xz&quot;</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="kn">import</span> <span class="nn">lzma</span>
                <span class="n">file_name</span> <span class="o">=</span> <span class="n">lzma</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&quot;rb&quot;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;lzma compression is only available in Python &gt;= 3.3&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fmt</span> <span class="o">==</span> <span class="s">&quot;graphml&quot;</span><span class="p">:</span>
            <span class="n">fmt</span> <span class="o">=</span> <span class="s">&quot;xml&quot;</span>
        <span class="k">if</span> <span class="n">ignore_vp</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">ignore_vp</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">ignore_ep</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">ignore_ep</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">ignore_gp</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">ignore_gp</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">props</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="o">.</span><span class="n">ReadFromFile</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">ignore_vp</span><span class="p">,</span>
                                              <span class="n">ignore_ep</span><span class="p">,</span> <span class="n">ignore_gp</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">props</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="o">.</span><span class="n">ReadFromFile</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">file_name</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">ignore_vp</span><span class="p">,</span>
                                              <span class="n">ignore_ep</span><span class="p">,</span> <span class="n">ignore_gp</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">prop</span> <span class="ow">in</span> <span class="n">props</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vertex_properties</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">PropertyMap</span><span class="p">(</span><span class="n">prop</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="s">&quot;v&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">prop</span> <span class="ow">in</span> <span class="n">props</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">edge_properties</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">PropertyMap</span><span class="p">(</span><span class="n">prop</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="s">&quot;e&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">prop</span> <span class="ow">in</span> <span class="n">props</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">graph_properties</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">PropertyMap</span><span class="p">(</span><span class="n">prop</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="s">&quot;g&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s">&quot;_Graph__save__vfilter&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph_properties</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_vertex_filter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertex_properties</span><span class="p">[</span><span class="s">&quot;_Graph__save__vfilter&quot;</span><span class="p">],</span>
                                   <span class="bp">self</span><span class="o">.</span><span class="n">graph_properties</span><span class="p">[</span><span class="s">&quot;_Graph__save__vfilter&quot;</span><span class="p">])</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertex_properties</span><span class="p">[</span><span class="s">&quot;_Graph__save__vfilter&quot;</span><span class="p">]</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph_properties</span><span class="p">[</span><span class="s">&quot;_Graph__save__vfilter&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="s">&quot;_Graph__save__efilter&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph_properties</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_edge_filter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edge_properties</span><span class="p">[</span><span class="s">&quot;_Graph__save__efilter&quot;</span><span class="p">],</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">graph_properties</span><span class="p">[</span><span class="s">&quot;_Graph__save__efilter&quot;</span><span class="p">])</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_properties</span><span class="p">[</span><span class="s">&quot;_Graph__save__efilter&quot;</span><span class="p">]</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph_properties</span><span class="p">[</span><span class="s">&quot;_Graph__save__efilter&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="s">&quot;_Graph__reversed&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph_properties</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_reversed</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph_properties</span><span class="p">[</span><span class="s">&quot;_Graph__reversed&quot;</span><span class="p">]</span>


</div>
<div class="viewcode-block" id="Graph.save"><a class="viewcode-back" href="../graph_tool.html#graph_tool.Graph.save">[docs]</a>    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_name</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s">&quot;auto&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Save graph to ``file_name`` (which can be either a string or a file-like</span>
<span class="sd">        object). The format is guessed from the ``file_name``, or can be</span>
<span class="sd">        specified by ``fmt``, which can be either &quot;gt&quot;, &quot;graphml&quot;, &quot;xml&quot;, &quot;dot&quot;</span>
<span class="sd">        or &quot;gml&quot;.  (Note that &quot;graphml&quot; and &quot;xml&quot; are synonyms).</span>

<span class="sd">        .. warning::</span>

<span class="sd">           The only file formats which are capable of perfectly preserving the</span>
<span class="sd">           internal property maps are &quot;gt&quot; and &quot;graphml&quot;. Because of this,</span>
<span class="sd">           they should be preferred over the other formats whenever possible.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">u</span> <span class="o">=</span> <span class="n">GraphView</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">reversed</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">is_reversed</span><span class="p">(),</span> <span class="n">skip_vfilt</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                      <span class="n">skip_efilt</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_vertex_filter</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">u</span><span class="o">.</span><span class="n">graph_properties</span><span class="p">[</span><span class="s">&quot;_Graph__save__vfilter&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_graph_property</span><span class="p">(</span><span class="s">&quot;bool&quot;</span><span class="p">)</span>
            <span class="n">u</span><span class="o">.</span><span class="n">vertex_properties</span><span class="p">[</span><span class="s">&quot;_Graph__save__vfilter&quot;</span><span class="p">]</span> <span class="o">=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">get_vertex_filter</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">u</span><span class="o">.</span><span class="n">graph_properties</span><span class="p">[</span><span class="s">&quot;_Graph__save__vfilter&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_vertex_filter</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_edge_filter</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">u</span><span class="o">.</span><span class="n">graph_properties</span><span class="p">[</span><span class="s">&quot;_Graph__save__efilter&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_graph_property</span><span class="p">(</span><span class="s">&quot;bool&quot;</span><span class="p">)</span>
            <span class="n">u</span><span class="o">.</span><span class="n">edge_properties</span><span class="p">[</span><span class="s">&quot;_Graph__save__efilter&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_edge_filter</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">u</span><span class="o">.</span><span class="n">graph_properties</span><span class="p">[</span><span class="s">&quot;_Graph__save__efilter&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_edge_filter</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_reversed</span><span class="p">():</span>
            <span class="n">u</span><span class="o">.</span><span class="n">graph_properties</span><span class="p">[</span><span class="s">&quot;_Graph__reversed&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_graph_property</span><span class="p">(</span><span class="s">&quot;bool&quot;</span><span class="p">)</span>
            <span class="n">u</span><span class="o">.</span><span class="n">graph_properties</span><span class="p">[</span><span class="s">&quot;_Graph__reversed&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">file_name</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
            <span class="n">file_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="n">file_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fmt</span> <span class="o">==</span> <span class="s">&#39;auto&#39;</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">fmt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_file_format</span><span class="p">(</span><span class="n">file_name</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">fmt</span> <span class="o">==</span> <span class="s">&quot;auto&quot;</span><span class="p">:</span>
            <span class="n">fmt</span> <span class="o">=</span> <span class="s">&quot;gt&quot;</span>
        <span class="k">if</span> <span class="n">fmt</span> <span class="o">==</span> <span class="s">&quot;graphml&quot;</span><span class="p">:</span>
            <span class="n">fmt</span> <span class="o">=</span> <span class="s">&quot;xml&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">file_name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s">&quot;.xz&quot;</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="kn">import</span> <span class="nn">lzma</span>
                <span class="n">file_name</span> <span class="o">=</span> <span class="n">lzma</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&quot;wb&quot;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;lzma compression is only available in Python &gt;= 3.3&quot;</span><span class="p">)</span>

        <span class="n">props</span> <span class="o">=</span> <span class="p">[(</span><span class="n">name</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">prop</span><span class="o">.</span><span class="n">_PropertyMap__map</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">prop</span> <span class="ow">in</span> \
                 <span class="bp">self</span><span class="o">.</span><span class="n">__properties</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="s">&quot;w&quot;</span><span class="p">)</span> <span class="c"># throw the appropriate exception, if</span>
                                     <span class="c"># unable to open</span>
            <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="n">u</span><span class="o">.</span><span class="n">__graph</span><span class="o">.</span><span class="n">WriteToFile</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">props</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">u</span><span class="o">.</span><span class="n">__graph</span><span class="o">.</span><span class="n">WriteToFile</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">file_name</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">props</span><span class="p">)</span>


    <span class="c"># Directedness</span>
    <span class="c"># ============</span>
</div>
<div class="viewcode-block" id="Graph.set_directed"><a class="viewcode-back" href="../graph_tool.html#graph_tool.Graph.set_directed">[docs]</a>    <span class="k">def</span> <span class="nf">set_directed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">is_directed</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the directedness of the graph.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="o">.</span><span class="n">SetDirected</span><span class="p">(</span><span class="n">is_directed</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Graph.is_directed"><a class="viewcode-back" href="../graph_tool.html#graph_tool.Graph.is_directed">[docs]</a>    <span class="k">def</span> <span class="nf">is_directed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the directedness of the graph.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="o">.</span><span class="n">GetDirected</span><span class="p">()</span>

    <span class="c"># Reversedness</span>
    <span class="c"># ============</span>
</div>
<div class="viewcode-block" id="Graph.set_reversed"><a class="viewcode-back" href="../graph_tool.html#graph_tool.Graph.set_reversed">[docs]</a>    <span class="k">def</span> <span class="nf">set_reversed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">is_reversed</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reverse the direction of the edges, if ``is_reversed`` is ``True``,</span>
<span class="sd">        or maintain the original direction otherwise.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="o">.</span><span class="n">SetReversed</span><span class="p">(</span><span class="n">is_reversed</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Graph.is_reversed"><a class="viewcode-back" href="../graph_tool.html#graph_tool.Graph.is_reversed">[docs]</a>    <span class="k">def</span> <span class="nf">is_reversed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``True`` if the edges are reversed, and ``False`` otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="o">.</span><span class="n">GetReversed</span><span class="p">()</span>

    <span class="c"># Filtering</span>
    <span class="c"># =========</span>
</div>
<div class="viewcode-block" id="Graph.set_filters"><a class="viewcode-back" href="../graph_tool.html#graph_tool.Graph.set_filters">[docs]</a>    <span class="k">def</span> <span class="nf">set_filters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eprop</span><span class="p">,</span> <span class="n">vprop</span><span class="p">,</span> <span class="n">inverted_edges</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">inverted_vertices</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the boolean properties for edge and vertex filters, respectively.</span>
<span class="sd">        Only the vertices and edges with value different than ``True`` are kept in</span>
<span class="sd">        the filtered graph. If either the ``inverted_edges`` or ``inverted_vertex``</span>
<span class="sd">        options are supplied with the value ``True``, only the edges or vertices</span>
<span class="sd">        with value ``False`` are kept. If any of the supplied property is ``None``,</span>
<span class="sd">        an empty filter is constructed which allows all edges or vertices.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">eprop</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">vprop</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="n">eprop</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">eprop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_edge_property</span><span class="p">(</span><span class="s">&quot;bool&quot;</span><span class="p">)</span>
            <span class="n">eprop</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">inverted_edges</span>

        <span class="k">if</span> <span class="n">vprop</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">vprop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="s">&quot;bool&quot;</span><span class="p">)</span>
            <span class="n">vprop</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">inverted_vertices</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="o">.</span><span class="n">SetVertexFilterProperty</span><span class="p">(</span><span class="n">_prop</span><span class="p">(</span><span class="s">&quot;v&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">vprop</span><span class="p">),</span>
                                             <span class="n">inverted_vertices</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__filter_state</span><span class="p">[</span><span class="s">&quot;vertex_filter&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">vprop</span><span class="p">,</span> <span class="n">inverted_vertices</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="o">.</span><span class="n">SetEdgeFilterProperty</span><span class="p">(</span><span class="n">_prop</span><span class="p">(</span><span class="s">&quot;e&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">eprop</span><span class="p">),</span>
                                           <span class="n">inverted_edges</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__filter_state</span><span class="p">[</span><span class="s">&quot;edge_filter&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">eprop</span><span class="p">,</span> <span class="n">inverted_edges</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Graph.set_vertex_filter"><a class="viewcode-back" href="../graph_tool.html#graph_tool.Graph.set_vertex_filter">[docs]</a>    <span class="k">def</span> <span class="nf">set_vertex_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prop</span><span class="p">,</span> <span class="n">inverted</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the vertex boolean filter property. Only the vertices with value</span>
<span class="sd">        different than ``False`` are kept in the filtered graph. If the ``inverted``</span>
<span class="sd">        option is supplied with value ``True``, only the vertices with value</span>
<span class="sd">        ``False`` are kept. If the supplied property is ``None``, the filter is</span>
<span class="sd">        replaced by an uniform filter allowing all vertices.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">prop</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">prop</span><span class="o">.</span><span class="n">value_type</span><span class="p">()</span> <span class="o">!=</span> <span class="s">&quot;bool&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;filter property map must have &#39;bool&#39; type&quot;</span><span class="p">)</span>

        <span class="n">vfilt</span> <span class="o">=</span> <span class="n">prop</span>
        <span class="n">efilt</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="n">eprop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_edge_filter</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">eprop</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">vfilt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">efilt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_edge_property</span><span class="p">(</span><span class="s">&quot;bool&quot;</span><span class="p">)</span>
            <span class="n">efilt</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">if</span> <span class="n">eprop</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">vfilt</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">vfilt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="s">&quot;bool&quot;</span><span class="p">)</span>
            <span class="n">vfilt</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">inverted</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="o">.</span><span class="n">SetVertexFilterProperty</span><span class="p">(</span><span class="n">_prop</span><span class="p">(</span><span class="s">&quot;v&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">vfilt</span><span class="p">),</span>
                                             <span class="n">inverted</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__filter_state</span><span class="p">[</span><span class="s">&quot;vertex_filter&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">vfilt</span><span class="p">,</span> <span class="n">inverted</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">efilt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_edge_filter</span><span class="p">(</span><span class="n">efilt</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Graph.get_vertex_filter"><a class="viewcode-back" href="../graph_tool.html#graph_tool.Graph.get_vertex_filter">[docs]</a>    <span class="k">def</span> <span class="nf">get_vertex_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a tuple with the vertex filter property and bool value</span>
<span class="sd">        indicating whether or not it is inverted.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__filter_state</span><span class="p">[</span><span class="s">&quot;vertex_filter&quot;</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="Graph.set_edge_filter"><a class="viewcode-back" href="../graph_tool.html#graph_tool.Graph.set_edge_filter">[docs]</a>    <span class="k">def</span> <span class="nf">set_edge_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prop</span><span class="p">,</span> <span class="n">inverted</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the edge boolean filter property. Only the edges with value</span>
<span class="sd">        different than ``False`` are kept in the filtered graph. If the ``inverted``</span>
<span class="sd">        option is supplied with value ``True``, only the edges with value ``False``</span>
<span class="sd">        are kept. If the supplied property is ``None``, the filter is</span>
<span class="sd">        replaced by an uniform filter allowing all edges.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">prop</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">prop</span><span class="o">.</span><span class="n">value_type</span><span class="p">()</span> <span class="o">!=</span> <span class="s">&quot;bool&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;filter property map must have &#39;bool&#39; type&quot;</span><span class="p">)</span>

        <span class="n">efilt</span> <span class="o">=</span> <span class="n">prop</span>
        <span class="n">vfilt</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="n">vprop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_vertex_filter</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">vprop</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">efilt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">vfilt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="s">&quot;bool&quot;</span><span class="p">)</span>
            <span class="n">vfilt</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">if</span> <span class="n">vprop</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">efilt</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">efilt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_edge_property</span><span class="p">(</span><span class="s">&quot;bool&quot;</span><span class="p">)</span>
            <span class="n">efilt</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">inverted</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="o">.</span><span class="n">SetEdgeFilterProperty</span><span class="p">(</span><span class="n">_prop</span><span class="p">(</span><span class="s">&quot;e&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">efilt</span><span class="p">),</span> <span class="n">inverted</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__filter_state</span><span class="p">[</span><span class="s">&quot;edge_filter&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">efilt</span><span class="p">,</span> <span class="n">inverted</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">vfilt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_vertex_filter</span><span class="p">(</span><span class="n">vfilt</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Graph.get_edge_filter"><a class="viewcode-back" href="../graph_tool.html#graph_tool.Graph.get_edge_filter">[docs]</a>    <span class="k">def</span> <span class="nf">get_edge_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a tuple with the edge filter property and bool value</span>
<span class="sd">        indicating whether or not it is inverted.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__filter_state</span><span class="p">[</span><span class="s">&quot;edge_filter&quot;</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="Graph.clear_filters"><a class="viewcode-back" href="../graph_tool.html#graph_tool.Graph.clear_filters">[docs]</a>    <span class="k">def</span> <span class="nf">clear_filters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove vertex and edge filters, and set the graph to the unfiltered</span>
<span class="sd">        state.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="o">.</span><span class="n">SetVertexFilterProperty</span><span class="p">(</span><span class="n">_prop</span><span class="p">(</span><span class="s">&quot;v&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span> <span class="bp">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__filter_state</span><span class="p">[</span><span class="s">&quot;vertex_filter&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="o">.</span><span class="n">SetEdgeFilterProperty</span><span class="p">(</span><span class="n">_prop</span><span class="p">(</span><span class="s">&quot;e&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span> <span class="bp">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__filter_state</span><span class="p">[</span><span class="s">&quot;edge_filter&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Graph.purge_vertices"><a class="viewcode-back" href="../graph_tool.html#graph_tool.Graph.purge_vertices">[docs]</a>    <span class="k">def</span> <span class="nf">purge_vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_place</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove all vertices of the graph which are currently being filtered out. This</span>
<span class="sd">        operation is not reversible.</span>

<span class="sd">        If the option ``in_place == True`` is given, the algorithm will remove</span>
<span class="sd">        the filtered vertices and re-index all property maps which are tied with</span>
<span class="sd">        the graph. This is a slow operation which has an :math:`O(N^2)`</span>
<span class="sd">        complexity.</span>

<span class="sd">        If ``in_place == False``, the graph and its vertex and edge property</span>
<span class="sd">        maps are temporarily copied to a new unfiltered graph, which will</span>
<span class="sd">        replace the contents of the original graph. This is a fast operation</span>
<span class="sd">        with an :math:`O(N + E)` complexity. This is the default behaviour if no</span>
<span class="sd">        option is given.</span>

<span class="sd">        .. note :</span>

<span class="sd">           The graph will remain in a filtered state after this operation, since</span>
<span class="sd">           there might be edge filters present. To return the graph to an</span>
<span class="sd">           unfiltered state, use :meth:`~graph_tool.Graph.clear_filters`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">in_place</span><span class="p">:</span>
            <span class="n">old_indexes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertex_index</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="s">&quot;int64_t&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="o">.</span><span class="n">PurgeVertices</span><span class="p">(</span><span class="n">_prop</span><span class="p">(</span><span class="s">&quot;v&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">old_indexes</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_vertex_filter</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">pmap</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__known_properties</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">pmap</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">pmap</span><span class="p">()</span><span class="o">.</span><span class="n">key_type</span><span class="p">()</span> <span class="o">==</span> <span class="s">&quot;v&quot;</span> <span class="ow">and</span>
                    <span class="n">pmap</span><span class="p">()</span><span class="o">.</span><span class="n">is_writable</span><span class="p">()</span> <span class="ow">and</span>
                    <span class="n">pmap</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">vertex_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_index</span><span class="p">]):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="o">.</span><span class="n">ReIndexVertexProperty</span><span class="p">(</span><span class="n">pmap</span><span class="p">()</span><span class="o">.</span><span class="n">_PropertyMap__map</span><span class="o">.</span><span class="n">get_map</span><span class="p">(),</span>
                                                       <span class="n">_prop</span><span class="p">(</span><span class="s">&quot;v&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">old_indexes</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stamp</span> <span class="o">=</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">pmaps</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">pmap</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__known_properties</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">pmap</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">pmap</span><span class="p">()</span><span class="o">.</span><span class="n">key_type</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&quot;v&quot;</span><span class="p">,</span> <span class="s">&quot;e&quot;</span><span class="p">]</span> <span class="ow">and</span>
                    <span class="n">pmap</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">vertex_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_index</span><span class="p">]):</span>
                    <span class="n">pmaps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pmap</span><span class="p">())</span>
                    <span class="n">pname</span> <span class="o">=</span> <span class="s">&quot;__tmp_purge_vertices_</span><span class="si">%d</span><span class="s">_</span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">stamp</span><span class="p">,</span> <span class="nb">id</span><span class="p">(</span><span class="n">pmaps</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="p">[(</span><span class="n">pmaps</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">key_type</span><span class="p">(),</span> <span class="n">pname</span><span class="p">)]</span> <span class="o">=</span> <span class="n">pmaps</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">new_g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prune</span><span class="o">=</span><span class="p">(</span><span class="bp">True</span><span class="p">,</span> <span class="bp">False</span><span class="p">,</span> <span class="bp">False</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span> <span class="o">=</span> <span class="n">new_g</span><span class="o">.</span><span class="n">__graph</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_vertex_filter</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">pmap</span> <span class="ow">in</span> <span class="n">pmaps</span><span class="p">:</span>
                <span class="n">pname</span> <span class="o">=</span> <span class="s">&quot;__tmp_purge_vertices_</span><span class="si">%d</span><span class="s">_</span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">stamp</span><span class="p">,</span> <span class="nb">id</span><span class="p">(</span><span class="n">pmap</span><span class="p">))</span>
                <span class="n">new_pmap</span> <span class="o">=</span> <span class="n">new_g</span><span class="o">.</span><span class="n">properties</span><span class="p">[(</span><span class="n">pmap</span><span class="o">.</span><span class="n">key_type</span><span class="p">(),</span> <span class="n">pname</span><span class="p">)]</span>
                <span class="n">pmap</span><span class="o">.</span><span class="n">_PropertyMap__map</span> <span class="o">=</span> <span class="n">new_pmap</span><span class="o">.</span><span class="n">_PropertyMap__map</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="p">[(</span><span class="n">pmap</span><span class="o">.</span><span class="n">key_type</span><span class="p">(),</span> <span class="n">pname</span><span class="p">)]</span>

            <span class="c"># update edge filter if set</span>
            <span class="n">efilt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_edge_filter</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">efilt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_edge_filter</span><span class="p">(</span><span class="n">efilt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">efilt</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</div>
<div class="viewcode-block" id="Graph.purge_edges"><a class="viewcode-back" href="../graph_tool.html#graph_tool.Graph.purge_edges">[docs]</a>    <span class="k">def</span> <span class="nf">purge_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove all edges of the graph which are currently being filtered out. This</span>
<span class="sd">        operation is not reversible.</span>

<span class="sd">        .. note :</span>

<span class="sd">           The graph will remain in a filtered state after this operation, since</span>
<span class="sd">           there might be vertex filters present. To return the graph to an</span>
<span class="sd">           unfiltered state, use :meth:`~graph_tool.Graph.clear_filters`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="o">.</span><span class="n">PurgeEdges</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_edge_filter</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">get_filter_state</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a copy of the filter state of the graph.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__filter_state</span><span class="p">[</span><span class="s">&quot;directed&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_directed</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__filter_state</span><span class="p">[</span><span class="s">&quot;reversed&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_reversed</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__filter_state</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_filter_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the filter state of the graph.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">libcore</span><span class="o">.</span><span class="n">graph_filtering_enabled</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_vertex_filter</span><span class="p">(</span><span class="n">state</span><span class="p">[</span><span class="s">&quot;vertex_filter&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                                   <span class="n">state</span><span class="p">[</span><span class="s">&quot;vertex_filter&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_edge_filter</span><span class="p">(</span><span class="n">state</span><span class="p">[</span><span class="s">&quot;edge_filter&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                                 <span class="n">state</span><span class="p">[</span><span class="s">&quot;edge_filter&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_directed</span><span class="p">(</span><span class="n">state</span><span class="p">[</span><span class="s">&quot;directed&quot;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_reversed</span><span class="p">(</span><span class="n">state</span><span class="p">[</span><span class="s">&quot;reversed&quot;</span><span class="p">])</span>

    <span class="c"># Basic graph statistics</span>
    <span class="c"># ======================</span>

<div class="viewcode-block" id="Graph.num_vertices"><a class="viewcode-back" href="../graph_tool.html#graph_tool.Graph.num_vertices">[docs]</a>    <span class="k">def</span> <span class="nf">num_vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ignore_filter</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the number of vertices.</span>

<span class="sd">        If ``ignore_filter == True``, vertex filters are ignored.</span>

<span class="sd">        .. note::</span>

<span class="sd">            If the vertices are being filtered, and ``ignore_filter == False``,</span>
<span class="sd">            this operation is :math:`O(N)`. Otherwise it is :math:`O(1)`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="o">.</span><span class="n">GetNumberOfVertices</span><span class="p">(</span><span class="ow">not</span> <span class="n">ignore_filter</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Graph.num_edges"><a class="viewcode-back" href="../graph_tool.html#graph_tool.Graph.num_edges">[docs]</a>    <span class="k">def</span> <span class="nf">num_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ignore_filter</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the number of edges.</span>

<span class="sd">        If ``ignore_filter == True``, edge filters are ignored.</span>

<span class="sd">        .. note::</span>

<span class="sd">            If the edges are being filtered, and ``ignore_filter == False``,</span>
<span class="sd">            this operation is :math:`O(E)`. Otherwise it is :math:`O(1)`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__graph</span><span class="o">.</span><span class="n">GetNumberOfEdges</span><span class="p">(</span><span class="ow">not</span> <span class="n">ignore_filter</span><span class="p">)</span>

    <span class="c"># Pickling support</span>
    <span class="c"># ================</span>
</div>
    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">state</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">3</span><span class="p">,):</span>
            <span class="n">sio</span> <span class="o">=</span> <span class="n">StringIO</span><span class="o">.</span><span class="n">StringIO</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sio</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">()</span>
        <span class="n">stream</span> <span class="o">=</span> <span class="n">gzip</span><span class="o">.</span><span class="n">GzipFile</span><span class="p">(</span><span class="n">fileobj</span><span class="o">=</span><span class="n">sio</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&quot;wb&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="s">&quot;gt&quot;</span><span class="p">)</span>
        <span class="n">stream</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">state</span><span class="p">[</span><span class="s">&quot;blob&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sio</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">state</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="n">blob</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s">&quot;blob&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">blob</span> <span class="o">!=</span> <span class="s">&quot;&quot;</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">3</span><span class="p">,):</span>
                    <span class="n">sio</span> <span class="o">=</span> <span class="n">StringIO</span><span class="o">.</span><span class="n">StringIO</span><span class="p">(</span><span class="n">blob</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">sio</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">(</span><span class="n">blob</span><span class="p">)</span>
                <span class="n">stream</span> <span class="o">=</span> <span class="n">gzip</span><span class="o">.</span><span class="n">GzipFile</span><span class="p">(</span><span class="n">fileobj</span><span class="o">=</span><span class="n">sio</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&quot;rb&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="s">&quot;gt&quot;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">3</span><span class="p">,):</span>
                    <span class="n">sio</span> <span class="o">=</span> <span class="n">StringIO</span><span class="o">.</span><span class="n">StringIO</span><span class="p">(</span><span class="n">blob</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">sio</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">(</span><span class="n">blob</span><span class="p">)</span>
                <span class="n">stream</span> <span class="o">=</span> <span class="n">gzip</span><span class="o">.</span><span class="n">GzipFile</span><span class="p">(</span><span class="n">fileobj</span><span class="o">=</span><span class="n">sio</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&quot;rb&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="s">&quot;xml&quot;</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="load_graph"><a class="viewcode-back" href="../graph_tool.html#graph_tool.load_graph">[docs]</a><span class="k">def</span> <span class="nf">load_graph</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s">&quot;auto&quot;</span><span class="p">,</span> <span class="n">ignore_vp</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">ignore_ep</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
               <span class="n">ignore_gp</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Load a graph from ``file_name`` (which can be either a string or a file-like object).</span>

<span class="sd">    The format is guessed from ``file_name``, or can be specified by ``fmt``,</span>
<span class="sd">    which can be either &quot;gt&quot;, &quot;graphml&quot;, &quot;xml&quot;, &quot;dot&quot; or &quot;gml&quot;.  (Note that</span>
<span class="sd">    &quot;graphml&quot; and &quot;xml&quot; are synonyms).</span>

<span class="sd">    If provided, the parameters ``ignore_vp``, ``ignore_ep`` and</span>
<span class="sd">    ``ignore_gp``, should contain a list of property names (vertex, edge or</span>
<span class="sd">    graph, respectively) which should be ignored when reading the file.</span>

<span class="sd">    .. warning::</span>

<span class="sd">       The only file formats which are capable of perfectly preserving the</span>
<span class="sd">       internal property maps are &quot;gt&quot; and &quot;graphml&quot;. Because of this,</span>
<span class="sd">       they should be preferred over the other formats whenever possible.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span>
    <span class="n">g</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">ignore_vp</span><span class="p">,</span> <span class="n">ignore_ep</span><span class="p">,</span> <span class="n">ignore_gp</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">g</span>

</div>
<div class="viewcode-block" id="GraphView"><a class="viewcode-back" href="../graph_tool.html#graph_tool.GraphView">[docs]</a><span class="k">class</span> <span class="nc">GraphView</span><span class="p">(</span><span class="n">Graph</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A view of selected vertices or edges of another graph.</span>

<span class="sd">    This class uses shared data from another :class:`~graph_tool.Graph`</span>
<span class="sd">    instance, but allows for local filtering of vertices and/or edges, edge</span>
<span class="sd">    directionality or reversal. See :ref:`sec_graph_views` for more details and</span>
<span class="sd">    examples.</span>

<span class="sd">    The existence of a :class:`~graph_tool.GraphView` object does not affect the</span>
<span class="sd">    original graph, except if the graph view is modified (addition or removal of</span>
<span class="sd">    vertices or edges), in which case the modification is directly reflected in</span>
<span class="sd">    the original graph (and vice-versa), since they both point to the same</span>
<span class="sd">    underlying data. Because of this, instances of</span>
<span class="sd">    :class:`~graph_tool.PropertyMap` can be used interchangeably with a graph</span>
<span class="sd">    and its views.</span>

<span class="sd">    The argument ``g`` must be an instance of a :class:`~graph_tool.Graph`</span>
<span class="sd">    class. If specified, ``vfilt`` and ``efilt`` select which vertices and edges</span>
<span class="sd">    are filtered, respectively. These parameters can either be a</span>
<span class="sd">    boolean-valued :class:`~graph_tool.PropertyMap` or a</span>
<span class="sd">    :class:`~numpy.ndarray`, which specify which vertices/edges are selected, or</span>
<span class="sd">    an unary function which returns ``True`` if a given vertex/edge is to be</span>
<span class="sd">    selected, or ``False`` otherwise.</span>

<span class="sd">    The boolean parameter ``directed`` can be used to set the directionality of</span>
<span class="sd">    the graph view. If ``directed = None``, the directionality is inherited from</span>
<span class="sd">    ``g``.</span>

<span class="sd">    If ``reversed = True``, the direction of the edges is reversed.</span>

<span class="sd">    If ``vfilt`` or ``efilt`` is anything other than a</span>
<span class="sd">    :class:`~graph_tool.PropertyMap` instance, the instantiation running time is</span>
<span class="sd">    :math:`O(V)` and :math:`O(E)`, respectively. Otherwise, the running time is</span>
<span class="sd">    :math:`O(1)`.</span>

<span class="sd">    If either ``skip_properties``, ``skip_vfilt`` or ``skip_efilt`` is ``True``,</span>
<span class="sd">    then the internal properties, vertex filter or edge filter of the original</span>
<span class="sd">    graph are ignored, respectively.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">vfilt</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">efilt</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="nb">reversed</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">skip_properties</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">skip_vfilt</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                 <span class="n">skip_efilt</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__base</span> <span class="o">=</span> <span class="n">g</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">GraphView</span><span class="p">)</span> <span class="k">else</span> <span class="n">g</span><span class="o">.</span><span class="n">base</span>
        <span class="n">Graph</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="c"># copy graph reference</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_Graph__graph</span> <span class="o">=</span> <span class="n">libcore</span><span class="o">.</span><span class="n">GraphInterface</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span> <span class="bp">True</span><span class="p">,</span>
                                                    <span class="p">[],</span> <span class="p">[],</span>
                                                    <span class="n">_prop</span><span class="p">(</span><span class="s">&quot;v&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">vertex_index</span><span class="p">))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">skip_properties</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">properties</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">own_property</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

        <span class="c"># set already existent filters</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">skip_vfilt</span><span class="p">:</span>
            <span class="n">vf</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">get_vertex_filter</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">vf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_vertex_filter</span><span class="p">(</span><span class="n">vf</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">vf</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">skip_efilt</span><span class="p">:</span>
            <span class="n">ef</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">get_edge_filter</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">ef</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_edge_filter</span><span class="p">(</span><span class="n">ef</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ef</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">vfilt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">vfilt</span><span class="p">)</span> <span class="ow">is</span> <span class="n">PropertyMap</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_vertex_filter</span><span class="p">(</span><span class="n">vfilt</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">vmap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="s">&quot;bool&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">vfilt</span><span class="p">),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                    <span class="n">vmap</span><span class="o">.</span><span class="n">fa</span> <span class="o">=</span> <span class="n">vfilt</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">vertices</span><span class="p">():</span>
                        <span class="n">vmap</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">vfilt</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_vertex_filter</span><span class="p">(</span><span class="n">vmap</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">efilt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">efilt</span><span class="p">)</span> <span class="ow">is</span> <span class="n">PropertyMap</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_edge_filter</span><span class="p">(</span><span class="n">efilt</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">emap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_edge_property</span><span class="p">(</span><span class="s">&quot;bool&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">efilt</span><span class="p">),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                    <span class="n">emap</span><span class="o">.</span><span class="n">fa</span> <span class="o">=</span> <span class="n">efilt</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
                        <span class="n">emap</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="n">efilt</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_edge_filter</span><span class="p">(</span><span class="n">emap</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">directed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_directed</span><span class="p">(</span><span class="n">directed</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">reversed</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_reversed</span><span class="p">(</span><span class="ow">not</span> <span class="n">g</span><span class="o">.</span><span class="n">is_reversed</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">__get_base</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__base</span>
    <span class="n">base</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">__get_base</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s">&quot;Base graph.&quot;</span><span class="p">)</span>

    <span class="c"># pickling support</span>
    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Graph</span><span class="o">.</span><span class="n">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span>
        <span class="n">g</span><span class="o">.</span><span class="n">__setstate__</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="value_types"><a class="viewcode-back" href="../graph_tool.html#graph_tool.value_types">[docs]</a><span class="k">def</span> <span class="nf">value_types</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Return a list of possible properties value types.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">libcore</span><span class="o">.</span><span class="n">get_property_types</span><span class="p">()</span>

<span class="c"># Vertex and Edge Types</span>
<span class="c"># =====================</span></div>
<span class="kn">from</span> <span class="nn">.libgraph_tool_core</span> <span class="kn">import</span> <span class="n">Vertex</span><span class="p">,</span> <span class="n">Edge</span><span class="p">,</span> <span class="n">EdgeBase</span>

<span class="n">Vertex</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;Vertex descriptor.</span>

<span class="s">This class represents a vertex in a :class:`~graph_tool.Graph` instance.</span>

<span class="s">:class:`~graph_tool.Vertex` instances are hashable, and are convertible to</span>
<span class="s">integers, corresponding to its index (see :attr:`~graph_tool.Graph.vertex_index`).</span>
<span class="s">&quot;&quot;&quot;</span>


<span class="k">def</span> <span class="nf">_out_neighbours</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return an iterator over the out-neighbours.&quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">out_edges</span><span class="p">():</span>
        <span class="k">yield</span> <span class="n">e</span><span class="o">.</span><span class="n">target</span><span class="p">()</span>
<span class="n">Vertex</span><span class="o">.</span><span class="n">out_neighbours</span> <span class="o">=</span> <span class="n">_out_neighbours</span>


<span class="k">def</span> <span class="nf">_in_neighbours</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return an iterator over the in-neighbours.&quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_edges</span><span class="p">():</span>
        <span class="k">yield</span> <span class="n">e</span><span class="o">.</span><span class="n">source</span><span class="p">()</span>
<span class="n">Vertex</span><span class="o">.</span><span class="n">in_neighbours</span> <span class="o">=</span> <span class="n">_in_neighbours</span>


<span class="k">def</span> <span class="nf">_all_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return an iterator over all edges (both in or out).&quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">out_edges</span><span class="p">():</span>
        <span class="k">yield</span> <span class="n">e</span>
    <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_edges</span><span class="p">():</span>
        <span class="k">yield</span> <span class="n">e</span>
<span class="n">Vertex</span><span class="o">.</span><span class="n">all_edges</span> <span class="o">=</span> <span class="n">_all_edges</span>


<span class="k">def</span> <span class="nf">_all_neighbours</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return an iterator over all neighbours (both in or out).&quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">out_neighbours</span><span class="p">():</span>
        <span class="k">yield</span> <span class="n">v</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_neighbours</span><span class="p">():</span>
        <span class="k">yield</span> <span class="n">v</span>
<span class="n">Vertex</span><span class="o">.</span><span class="n">all_neighbours</span> <span class="o">=</span> <span class="n">_all_neighbours</span>

<span class="k">def</span> <span class="nf">_in_degree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the in-degree of the vertex. If provided, ``weight`` should be a</span>
<span class="sd">    scalar edge property map, and the in-degree will correspond to the sum of</span>
<span class="sd">    the weights of the in-edges.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">weight</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__in_degree</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__weighted_in_degree</span><span class="p">(</span><span class="n">_prop</span><span class="p">(</span><span class="s">&quot;e&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_graph</span><span class="p">(),</span> <span class="n">weight</span><span class="p">))</span>

<span class="n">Vertex</span><span class="o">.</span><span class="n">in_degree</span> <span class="o">=</span> <span class="n">_in_degree</span>

<span class="k">def</span> <span class="nf">_out_degree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the out-degree of the vertex. If provided, ``weight`` should be a</span>
<span class="sd">    scalar edge property map, and the out-degree will correspond to the sum of</span>
<span class="sd">    the weights of the out-edges.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">weight</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__out_degree</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__weighted_out_degree</span><span class="p">(</span><span class="n">_prop</span><span class="p">(</span><span class="s">&quot;e&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_graph</span><span class="p">(),</span> <span class="n">weight</span><span class="p">))</span>

<span class="n">Vertex</span><span class="o">.</span><span class="n">out_degree</span> <span class="o">=</span> <span class="n">_out_degree</span>


<span class="k">def</span> <span class="nf">_vertex_repr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_valid</span><span class="p">():</span>
        <span class="k">return</span> <span class="s">&quot;&lt;invalid Vertex object at 0x</span><span class="si">%x</span><span class="s">&gt;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
    <span class="k">return</span> <span class="s">&quot;&lt;Vertex object with index &#39;</span><span class="si">%d</span><span class="s">&#39; at 0x</span><span class="si">%x</span><span class="s">&gt;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
<span class="n">Vertex</span><span class="o">.</span><span class="n">__repr__</span> <span class="o">=</span> <span class="n">_vertex_repr</span>

<span class="n">Vertex</span><span class="o">.</span><span class="n">__eq__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span> <span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">v2</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v2</span><span class="p">,</span> <span class="n">Vertex</span><span class="p">)</span> <span class="k">else</span> <span class="n">v2</span><span class="p">)</span>
<span class="n">Vertex</span><span class="o">.</span><span class="n">__ne__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span> <span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">v2</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v2</span><span class="p">,</span> <span class="n">Vertex</span><span class="p">)</span> <span class="k">else</span> <span class="n">v2</span><span class="p">)</span>
<span class="n">Vertex</span><span class="o">.</span><span class="n">__lt__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span> <span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">v2</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v2</span><span class="p">,</span> <span class="n">Vertex</span><span class="p">)</span> <span class="k">else</span> <span class="n">v2</span><span class="p">)</span>
<span class="n">Vertex</span><span class="o">.</span><span class="n">__gt__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span> <span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">v2</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v2</span><span class="p">,</span> <span class="n">Vertex</span><span class="p">)</span> <span class="k">else</span> <span class="n">v2</span><span class="p">)</span>
<span class="n">Vertex</span><span class="o">.</span><span class="n">__le__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span> <span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">v2</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v2</span><span class="p">,</span> <span class="n">Vertex</span><span class="p">)</span> <span class="k">else</span> <span class="n">v2</span><span class="p">)</span>
<span class="n">Vertex</span><span class="o">.</span><span class="n">__ge__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span> <span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">v2</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v2</span><span class="p">,</span> <span class="n">Vertex</span><span class="p">)</span> <span class="k">else</span> <span class="n">v2</span><span class="p">)</span>

<span class="n">_edge_doc</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;Edge descriptor.</span>

<span class="s">This class represents an edge in a :class:`~graph_tool.Graph`.</span>

<span class="s">:class:`~graph_tool.Edge` instances are hashable, and are convertible to a</span>
<span class="s">tuple, which contains the source and target vertices.</span>
<span class="s">&quot;&quot;&quot;</span>

<span class="k">def</span> <span class="nf">_edge_cmp</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">):</span>
    <span class="n">te1</span><span class="p">,</span> <span class="n">te2</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">e1</span><span class="p">),</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">e2</span><span class="p">)</span>
    <span class="n">g1</span> <span class="o">=</span> <span class="n">e1</span><span class="o">.</span><span class="n">get_graph</span><span class="p">()</span>
    <span class="n">g2</span> <span class="o">=</span> <span class="n">e2</span><span class="o">.</span><span class="n">get_graph</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">g1</span><span class="o">.</span><span class="n">is_directed</span><span class="p">():</span>
        <span class="n">te1</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">te1</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">g2</span><span class="o">.</span><span class="n">is_directed</span><span class="p">():</span>
        <span class="n">te2</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">te2</span><span class="p">)</span>
    <span class="n">te1</span> <span class="o">=</span> <span class="p">(</span><span class="n">te1</span><span class="p">,</span> <span class="n">g1</span><span class="o">.</span><span class="n">edge_index</span><span class="p">[</span><span class="n">e1</span><span class="p">])</span>
    <span class="n">te2</span> <span class="o">=</span> <span class="p">(</span><span class="n">te2</span><span class="p">,</span> <span class="n">g2</span><span class="o">.</span><span class="n">edge_index</span><span class="p">[</span><span class="n">e2</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">te1</span> <span class="o">&lt;</span> <span class="n">te2</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">if</span> <span class="n">te1</span> <span class="o">&gt;</span> <span class="n">te2</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="mi">0</span>

<span class="k">def</span> <span class="nf">_edge_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Iterate over the source and target&quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">()]:</span>
        <span class="k">yield</span> <span class="n">v</span>


<span class="k">def</span> <span class="nf">_edge_repr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_valid</span><span class="p">():</span>
        <span class="k">return</span> <span class="s">&quot;&lt;invalid Edge object at 0x</span><span class="si">%x</span><span class="s">&gt;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

    <span class="k">return</span> <span class="p">(</span><span class="s">&quot;&lt;Edge object with source &#39;</span><span class="si">%d</span><span class="s">&#39; and target &#39;</span><span class="si">%d</span><span class="s">&#39;&quot;</span> <span class="o">+</span>
            <span class="s">&quot; at 0x</span><span class="si">%x</span><span class="s">&gt;&quot;</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">()),</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">()),</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>


<span class="c"># There are several edge classes... me must cycle through them all to modify</span>
<span class="c"># them.</span>

<span class="k">def</span> <span class="nf">init_edge_classes</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">directed</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">True</span><span class="p">,</span> <span class="bp">False</span><span class="p">]:</span>
        <span class="k">for</span> <span class="n">e_reversed</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">True</span><span class="p">,</span> <span class="bp">False</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">e_filtered</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">True</span><span class="p">,</span> <span class="bp">False</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">v_filtered</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">True</span><span class="p">,</span> <span class="bp">False</span><span class="p">]:</span>
                    <span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">directed</span><span class="o">=</span><span class="n">directed</span><span class="p">)</span>
                    <span class="n">g</span><span class="o">.</span><span class="n">set_reversed</span><span class="p">(</span><span class="n">e_reversed</span><span class="p">)</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">()</span>
                    <span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">e_filtered</span><span class="p">:</span>
                        <span class="n">e_filter</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_edge_property</span><span class="p">(</span><span class="s">&quot;bool&quot;</span><span class="p">)</span>
                        <span class="n">e_filter</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">g</span><span class="o">.</span><span class="n">set_edge_filter</span><span class="p">(</span><span class="n">e_filter</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">v_filtered</span><span class="p">:</span>
                        <span class="n">v_filter</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="s">&quot;bool&quot;</span><span class="p">)</span>
                        <span class="n">v_filter</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">g</span><span class="o">.</span><span class="n">set_vertex_filter</span><span class="p">(</span><span class="n">v_filter</span><span class="p">)</span>
                    <span class="n">e</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span>
                    <span class="n">e</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__repr__</span> <span class="o">=</span> <span class="n">_edge_repr</span>
                    <span class="n">e</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__iter__</span> <span class="o">=</span> <span class="n">_edge_iter</span>
                    <span class="n">e</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">_edge_doc</span>

                    <span class="n">e</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__eq__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">e1</span><span class="p">,</span> <span class="n">e2</span> <span class="p">:</span> <span class="n">_edge_cmp</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
                    <span class="n">e</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__ne__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">e1</span><span class="p">,</span> <span class="n">e2</span> <span class="p">:</span> <span class="n">_edge_cmp</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>
                    <span class="n">e</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__lt__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">e1</span><span class="p">,</span> <span class="n">e2</span> <span class="p">:</span> <span class="n">_edge_cmp</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span>
                    <span class="n">e</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__gt__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">e1</span><span class="p">,</span> <span class="n">e2</span> <span class="p">:</span> <span class="n">_edge_cmp</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
                    <span class="n">e</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__le__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">e1</span><span class="p">,</span> <span class="n">e2</span> <span class="p">:</span> <span class="n">_edge_cmp</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span>
                    <span class="n">e</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__ge__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">e1</span><span class="p">,</span> <span class="n">e2</span> <span class="p">:</span> <span class="n">_edge_cmp</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span>

<span class="n">init_edge_classes</span><span class="p">()</span>

<span class="c"># some shenanigans to make it seem there is only a single edge class</span>
<span class="n">EdgeBase</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">Edge</span><span class="o">.</span><span class="n">__doc__</span>
<span class="n">EdgeBase</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="n">Edge</span><span class="o">.</span><span class="n">source</span>
<span class="n">EdgeBase</span><span class="o">.</span><span class="n">target</span> <span class="o">=</span> <span class="n">Edge</span><span class="o">.</span><span class="n">target</span>
<span class="n">EdgeBase</span><span class="o">.</span><span class="n">is_valid</span> <span class="o">=</span> <span class="n">Edge</span><span class="o">.</span><span class="n">is_valid</span>
<span class="n">EdgeBase</span><span class="o">.</span><span class="n">get_graph</span> <span class="o">=</span> <span class="n">Edge</span><span class="o">.</span><span class="n">get_graph</span>
<span class="n">Edge</span> <span class="o">=</span> <span class="n">EdgeBase</span>
<span class="n">Edge</span><span class="o">.</span><span class="n">__name__</span> <span class="o">=</span> <span class="s">&quot;Edge&quot;</span>


<span class="c"># Add convenience function to vector classes</span>
<span class="k">def</span> <span class="nf">_get_array_view</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_array</span><span class="p">()[:]</span>


<span class="k">def</span> <span class="nf">_set_array_view</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">get_array</span><span class="p">()[:]</span> <span class="o">=</span> <span class="n">v</span>

<span class="n">vector_types</span> <span class="o">=</span> <span class="p">[</span><span class="n">Vector_bool</span><span class="p">,</span> <span class="n">Vector_int16_t</span><span class="p">,</span> <span class="n">Vector_int32_t</span><span class="p">,</span> <span class="n">Vector_int64_t</span><span class="p">,</span>
                <span class="n">Vector_double</span><span class="p">,</span> <span class="n">Vector_long_double</span><span class="p">]</span>
<span class="k">for</span> <span class="n">vt</span> <span class="ow">in</span> <span class="n">vector_types</span><span class="p">:</span>
    <span class="n">vt</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_array_view</span><span class="p">,</span> <span class="n">_set_array_view</span><span class="p">,</span>
                    <span class="n">doc</span><span class="o">=</span><span class="s">r&quot;&quot;&quot;Shortcut to the `get_array` method as an attribute.&quot;&quot;&quot;</span><span class="p">)</span>
    <span class="n">vt</span><span class="o">.</span><span class="n">__repr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">__repr__</span><span class="p">()</span>
<span class="n">Vector_string</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="bp">None</span>
<span class="n">Vector_string</span><span class="o">.</span><span class="n">get_array</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="bp">None</span>
<span class="n">Vector_string</span><span class="o">.</span><span class="n">__repr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="nb">repr</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>


<span class="c"># Global RNG</span>

<span class="n">_rng</span> <span class="o">=</span> <span class="n">libcore</span><span class="o">.</span><span class="n">get_rng</span><span class="p">((</span><span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">sys</span><span class="o">.</span><span class="n">maxsize</span><span class="p">)</span> <span class="o">+</span> <span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">())</span> <span class="o">%</span> <span class="n">sys</span><span class="o">.</span><span class="n">maxsize</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">seed_rng</span><span class="p">(</span><span class="n">seed</span><span class="p">):</span>
    <span class="s">&quot;Seed the random number generator used by graph-tool&#39;s algorithms.&quot;</span>
    <span class="kn">import</span> <span class="nn">graph_tool</span>
    <span class="n">graph_tool</span><span class="o">.</span><span class="n">_rng</span> <span class="o">=</span> <span class="n">libcore</span><span class="o">.</span><span class="n">get_rng</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">seed</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">_get_rng</span><span class="p">():</span>
    <span class="k">global</span> <span class="n">_rng</span>
    <span class="k">return</span> <span class="n">_rng</span>

<span class="c"># OpenMP Setup</span>

<span class="k">def</span> <span class="nf">openmp_enabled</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Return `True` if OpenMP was enabled during compilation.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">libcore</span><span class="o">.</span><span class="n">openmp_enabled</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">openmp_get_num_threads</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Return the number of OpenMP threads.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">libcore</span><span class="o">.</span><span class="n">openmp_get_num_threads</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">openmp_set_num_threads</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Set the number of OpenMP threads.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">libcore</span><span class="o">.</span><span class="n">openmp_set_num_threads</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">openmp_get_schedule</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Return the runtime OpenMP schedule and chunk size. The schedule can by</span>
<span class="sd">    any of: `&quot;static&quot;`, `&quot;dynamic&quot;`, `&quot;guided&quot;`, `&quot;auto&quot;`.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">libcore</span><span class="o">.</span><span class="n">openmp_get_schedule</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">openmp_set_schedule</span><span class="p">(</span><span class="n">schedule</span><span class="p">,</span> <span class="n">chunk</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Set the runtime OpenMP schedule and chunk size. The schedule can by</span>
<span class="sd">    any of: `&quot;static&quot;`, `&quot;dynamic&quot;`, `&quot;guided&quot;`, `&quot;auto&quot;`.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">libcore</span><span class="o">.</span><span class="n">openmp_set_schedule</span><span class="p">(</span><span class="n">schedule</span><span class="p">,</span> <span class="n">chunk</span><span class="p">)</span>

<span class="k">if</span> <span class="n">openmp_enabled</span><span class="p">()</span> <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&quot;OMP_SCHEDULE&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
    <span class="n">openmp_set_schedule</span><span class="p">(</span><span class="s">&quot;static&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">

<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
<!-- <a href="graph-tool.pdf">(Download PDF version)</a> -->

<p/>
Latest <a href="/doc/dev/">development version docs</a> are also available.

        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
    <li><img src="../_static/graph-icon.png" alt="logo" style="margin-right: 5px; margin-bottom:-2px;" /><a href="/">Project Homepage</a> &raquo;</li>
    
        <li class="nav-item nav-item-0"><a href="../index.html">graph-tool 2.2.44 documentation</a> &raquo;</li>

          <li class="nav-item nav-item-1"><a href="index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2015, Tiago de Paula Peixoto &lt;tiago@skewed.de&gt;.
      Last updated on Jul 02, 2015.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
  </body>
</html>