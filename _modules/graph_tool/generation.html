<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>graph_tool.generation &mdash; graph-tool 2.2.44 documentation</title>
    
    <link rel="stylesheet" href="../../_static/gt_style.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '2.2.44',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/MathJax/MathJax.js?config=default"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within graph-tool 2.2.44 documentation"
          href="../../_static/opensearch.xml"/>
    <link rel="shortcut icon" href="../../_static/graph-icon.ico"/>
    <link rel="top" title="graph-tool 2.2.44 documentation" href="../../index.html" />
    <link rel="up" title="graph_tool" href="../graph_tool.html" />
    <script type="text/javascript">
      var _gaq = _gaq || [];
      var pluginUrl =
        '//www.google-analytics.com/plugins/ga/inpage_linkid.js';
      _gaq.push(['_require', 'inpage_linkid', pluginUrl]);
      _gaq.push(['_setAccount', 'UA-248813-2']);
      _gaq.push(['_setDomainName', '.skewed.de']);
      _gaq.push(['_trackPageview']);
      (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
     

  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
    <li><img src="../../_static/graph-icon.png" alt="logo" style="margin-right: 5px; margin-bottom:-2px;" /><a href="/">Project Homepage</a> &raquo;</li>
    
        <li class="nav-item nav-item-0"><a href="../../index.html">graph-tool 2.2.44 documentation</a> &raquo;</li>

          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &raquo;</li>
          <li class="nav-item nav-item-2"><a href="../graph_tool.html" accesskey="U">graph_tool</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for graph_tool.generation</h1><div class="highlight"><pre>
<span class="c">#! /usr/bin/env python</span>
<span class="c"># -*- coding: utf-8 -*-</span>
<span class="c">#</span>
<span class="c"># graph_tool -- a general graph manipulation python module</span>
<span class="c">#</span>
<span class="c"># Copyright (C) 2006-2015 Tiago de Paula Peixoto &lt;tiago@skewed.de&gt;</span>
<span class="c">#</span>
<span class="c"># This program is free software: you can redistribute it and/or modify</span>
<span class="c"># it under the terms of the GNU General Public License as published by</span>
<span class="c"># the Free Software Foundation, either version 3 of the License, or</span>
<span class="c"># (at your option) any later version.</span>
<span class="c">#</span>
<span class="c"># This program is distributed in the hope that it will be useful,</span>
<span class="c"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c"># GNU General Public License for more details.</span>
<span class="c">#</span>
<span class="c"># You should have received a copy of the GNU General Public License</span>
<span class="c"># along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.s</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">``graph_tool.generation`` - Random graph generation</span>
<span class="sd">---------------------------------------------------</span>

<span class="sd">Summary</span>
<span class="sd">+++++++</span>

<span class="sd">.. autosummary::</span>
<span class="sd">   :nosignatures:</span>

<span class="sd">   random_graph</span>
<span class="sd">   random_rewire</span>
<span class="sd">   predecessor_tree</span>
<span class="sd">   line_graph</span>
<span class="sd">   graph_union</span>
<span class="sd">   triangulation</span>
<span class="sd">   lattice</span>
<span class="sd">   geometric_graph</span>
<span class="sd">   price_network</span>
<span class="sd">   complete_graph</span>
<span class="sd">   circular_graph</span>

<span class="sd">Contents</span>
<span class="sd">++++++++</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span><span class="p">,</span> <span class="n">absolute_import</span><span class="p">,</span> <span class="n">print_function</span>

<span class="kn">from</span> <span class="nn">..</span> <span class="nn">dl_import</span> <span class="kn">import</span> <span class="n">dl_import</span>
<span class="n">dl_import</span><span class="p">(</span><span class="s">&quot;from . import libgraph_tool_generation&quot;</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">Graph</span><span class="p">,</span> <span class="n">GraphView</span><span class="p">,</span> <span class="n">_check_prop_scalar</span><span class="p">,</span> <span class="n">_prop</span><span class="p">,</span> <span class="n">_limit_args</span><span class="p">,</span> <span class="n">_gt_type</span><span class="p">,</span> <span class="n">_get_rng</span><span class="p">,</span> <span class="n">libcore</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="nn">stats</span> <span class="kn">import</span> <span class="n">label_parallel_edges</span><span class="p">,</span> <span class="n">label_self_loops</span>
<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">import</span> <span class="nn">types</span>
<span class="kn">import</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">numpy</span><span class="o">,</span> <span class="nn">numpy.random</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;random_graph&quot;</span><span class="p">,</span> <span class="s">&quot;random_rewire&quot;</span><span class="p">,</span> <span class="s">&quot;predecessor_tree&quot;</span><span class="p">,</span> <span class="s">&quot;line_graph&quot;</span><span class="p">,</span>
           <span class="s">&quot;graph_union&quot;</span><span class="p">,</span> <span class="s">&quot;triangulation&quot;</span><span class="p">,</span> <span class="s">&quot;lattice&quot;</span><span class="p">,</span> <span class="s">&quot;geometric_graph&quot;</span><span class="p">,</span>
           <span class="s">&quot;price_network&quot;</span><span class="p">,</span> <span class="s">&quot;complete_graph&quot;</span><span class="p">,</span> <span class="s">&quot;circular_graph&quot;</span><span class="p">]</span>


<div class="viewcode-block" id="random_graph"><a class="viewcode-back" href="../../generation.html#graph_tool.generation.random_graph">[docs]</a><span class="k">def</span> <span class="nf">random_graph</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">deg_sampler</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                 <span class="n">parallel_edges</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">self_loops</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">block_membership</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">block_type</span><span class="o">=</span><span class="s">&quot;int&quot;</span><span class="p">,</span> <span class="n">degree_block</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                 <span class="n">random</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Generate a random graph, with a given degree distribution and (optionally)</span>
<span class="sd">    vertex-vertex correlation.</span>

<span class="sd">    The graph will be randomized via the :func:`~graph_tool.generation.random_rewire`</span>
<span class="sd">    function, and any remaining parameters will be passed to that function.</span>
<span class="sd">    Please read its documentation for all the options regarding the different</span>
<span class="sd">    statistical models which can be chosen.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    N : int</span>
<span class="sd">        Number of vertices in the graph.</span>
<span class="sd">    deg_sampler : function</span>
<span class="sd">        A degree sampler function which is called without arguments, and returns</span>
<span class="sd">        a tuple of ints representing the in and out-degree of a given vertex (or</span>
<span class="sd">        a single int for undirected graphs, representing the out-degree). This</span>
<span class="sd">        function is called once per vertex, but may be called more times, if the</span>
<span class="sd">        degree sequence cannot be used to build a graph.</span>

<span class="sd">        Optionally, you can also pass a function which receives one or two</span>
<span class="sd">        arguments. If ``block_membership == None``, the single argument passed</span>
<span class="sd">        will be the index of the vertex which will receive the degree.  If</span>
<span class="sd">        ``block_membership != None``, the first value passed will be the vertex</span>
<span class="sd">        index, and the second will be the block value of the vertex.</span>
<span class="sd">    directed : bool (optional, default: ``True``)</span>
<span class="sd">        Whether the generated graph should be directed.</span>
<span class="sd">    parallel_edges : bool (optional, default: ``False``)</span>
<span class="sd">        If ``True``, parallel edges are allowed.</span>
<span class="sd">    self_loops : bool (optional, default: ``False``)</span>
<span class="sd">        If ``True``, self-loops are allowed.</span>
<span class="sd">    block_membership : list or :class:`~numpy.ndarray` or function (optional, default: ``None``)</span>
<span class="sd">        If supplied, the graph will be sampled from a stochastic blockmodel</span>
<span class="sd">        ensemble, and this parameter specifies the block membership of the</span>
<span class="sd">        vertices, which will be passed to the</span>
<span class="sd">        :func:`~graph_tool.generation.random_rewire` function.</span>

<span class="sd">        If the value is a list or a :class:`~numpy.ndarray`, it must have</span>
<span class="sd">        ``len(block_membership) == N``, and the values will define to which</span>
<span class="sd">        block each vertex belongs.</span>

<span class="sd">        If this value is a function, it will be used to sample the block</span>
<span class="sd">        types. It must be callable either with no arguments or with a single</span>
<span class="sd">        argument which will be the vertex index. In either case it must return</span>
<span class="sd">        a type compatible with the ``block_type`` parameter.</span>

<span class="sd">        See the documentation for the ``vertex_corr`` parameter of the</span>
<span class="sd">        :func:`~graph_tool.generation.random_rewire` function which specifies</span>
<span class="sd">        the correlation matrix.</span>
<span class="sd">    block_type : string (optional, default: ``&quot;int&quot;``)</span>
<span class="sd">        Value type of block labels. Valid only if ``block_membership != None``.</span>
<span class="sd">    degree_block : bool (optional, default: ``False``)</span>
<span class="sd">        If ``True``, the degree of each vertex will be appended to block labels</span>
<span class="sd">        when constructing the blockmodel, such that the resulting block type</span>
<span class="sd">        will be a pair :math:`(r, k)`, where :math:`r` is the original block</span>
<span class="sd">        label.</span>
<span class="sd">    random : bool (optional, default: ``True``)</span>
<span class="sd">        If ``True``, the returned graph is randomized. Otherwise a deterministic</span>
<span class="sd">        placement of the edges will be used.</span>
<span class="sd">    verbose : bool (optional, default: ``False``)</span>
<span class="sd">        If ``True``, verbose information is displayed.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    random_graph : :class:`~graph_tool.Graph`</span>
<span class="sd">        The generated graph.</span>
<span class="sd">    blocks : :class:`~graph_tool.PropertyMap`</span>
<span class="sd">        A vertex property map with the block values. This is only returned if</span>
<span class="sd">        ``block_membership != None``.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    random_rewire: in-place graph shuffling</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The algorithm makes sure the degree sequence is graphical (i.e. realizable)</span>
<span class="sd">    and keeps re-sampling the degrees if is not. With a valid degree sequence,</span>
<span class="sd">    the edges are placed deterministically, and later the graph is shuffled with</span>
<span class="sd">    the :func:`~graph_tool.generation.random_rewire` function, with all</span>
<span class="sd">    remaining parameters passed to it.</span>

<span class="sd">    The complexity is :math:`O(V + E)` if parallel edges are allowed, and</span>
<span class="sd">    :math:`O(V + E \times\text{n-iter})` if parallel edges are not allowed.</span>


<span class="sd">    .. note ::</span>

<span class="sd">        If ``parallel_edges == False`` this algorithm only guarantees that the</span>
<span class="sd">        returned graph will be a random sample from the desired ensemble if</span>
<span class="sd">        ``n_iter`` is sufficiently large. The algorithm implements an</span>
<span class="sd">        efficient Markov chain based on edge swaps, with a mixing time which</span>
<span class="sd">        depends on the degree distribution and correlations desired. If degree</span>
<span class="sd">        correlations are provided, the mixing time tends to be larger.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       from numpy.random import randint, random, seed, poisson</span>
<span class="sd">       from pylab import *</span>
<span class="sd">       seed(43)</span>
<span class="sd">       gt.seed_rng(42)</span>

<span class="sd">    This is a degree sampler which uses rejection sampling to sample from the</span>
<span class="sd">    distribution :math:`P(k)\propto 1/k`, up to a maximum.</span>

<span class="sd">    &gt;&gt;&gt; def sample_k(max):</span>
<span class="sd">    ...     accept = False</span>
<span class="sd">    ...     while not accept:</span>
<span class="sd">    ...         k = randint(1,max+1)</span>
<span class="sd">    ...         accept = random() &lt; 1.0/k</span>
<span class="sd">    ...     return k</span>
<span class="sd">    ...</span>

<span class="sd">    The following generates a random undirected graph with degree distribution</span>
<span class="sd">    :math:`P(k)\propto 1/k` (with k_max=40) and an *assortative* degree</span>
<span class="sd">    correlation of the form:</span>

<span class="sd">    .. math::</span>

<span class="sd">        P(i,k) \propto \frac{1}{1+|i-k|}</span>

<span class="sd">    &gt;&gt;&gt; g = gt.random_graph(1000, lambda: sample_k(40), model=&quot;probabilistic&quot;,</span>
<span class="sd">    ...                     vertex_corr=lambda i, k: 1.0 / (1 + abs(i - k)), directed=False,</span>
<span class="sd">    ...                     n_iter=100)</span>
<span class="sd">    &gt;&gt;&gt; gt.scalar_assortativity(g, &quot;out&quot;)</span>
<span class="sd">    (0.6377260889137862, 0.010604512511127259)</span>

<span class="sd">    The following samples an in,out-degree pair from the joint distribution:</span>

<span class="sd">    .. math::</span>

<span class="sd">        p(j,k) = \frac{1}{2}\frac{e^{-m_1}m_1^j}{j!}\frac{e^{-m_1}m_1^k}{k!} +</span>
<span class="sd">                 \frac{1}{2}\frac{e^{-m_2}m_2^j}{j!}\frac{e^{-m_2}m_2^k}{k!}</span>

<span class="sd">    with :math:`m_1 = 4` and :math:`m_2 = 20`.</span>

<span class="sd">    &gt;&gt;&gt; def deg_sample():</span>
<span class="sd">    ...    if random() &gt; 0.5:</span>
<span class="sd">    ...        return poisson(4), poisson(4)</span>
<span class="sd">    ...    else:</span>
<span class="sd">    ...        return poisson(20), poisson(20)</span>
<span class="sd">    ...</span>

<span class="sd">    The following generates a random directed graph with this distribution, and</span>
<span class="sd">    plots the combined degree correlation.</span>

<span class="sd">    &gt;&gt;&gt; g = gt.random_graph(20000, deg_sample)</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; hist = gt.combined_corr_hist(g, &quot;in&quot;, &quot;out&quot;)</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; figure()</span>
<span class="sd">    &lt;...&gt;</span>
<span class="sd">    &gt;&gt;&gt; imshow(hist[0].T, interpolation=&quot;nearest&quot;, origin=&quot;lower&quot;)</span>
<span class="sd">    &lt;...&gt;</span>
<span class="sd">    &gt;&gt;&gt; colorbar()</span>
<span class="sd">    &lt;...&gt;</span>
<span class="sd">    &gt;&gt;&gt; xlabel(&quot;in-degree&quot;)</span>
<span class="sd">    &lt;...&gt;</span>
<span class="sd">    &gt;&gt;&gt; ylabel(&quot;out-degree&quot;)</span>
<span class="sd">    &lt;...&gt;</span>
<span class="sd">    &gt;&gt;&gt; tight_layout()</span>
<span class="sd">    &gt;&gt;&gt; savefig(&quot;combined-deg-hist.pdf&quot;)</span>

<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       savefig(&quot;combined-deg-hist.png&quot;)</span>

<span class="sd">    .. figure:: combined-deg-hist.*</span>
<span class="sd">        :align: center</span>

<span class="sd">        Combined degree histogram.</span>

<span class="sd">    A correlated directed graph can be build as follows. Consider the following</span>
<span class="sd">    degree correlation:</span>

<span class="sd">    .. math::</span>

<span class="sd">         P(j&#39;,k&#39;|j,k)=\frac{e^{-k}k^{j&#39;}}{j&#39;!}</span>
<span class="sd">         \frac{e^{-(20-j)}(20-j)^{k&#39;}}{k&#39;!}</span>

<span class="sd">    i.e., the in-&gt;out correlation is &quot;disassortative&quot;, the out-&gt;in correlation</span>
<span class="sd">    is &quot;assortative&quot;, and everything else is uncorrelated.</span>
<span class="sd">    We will use a flat degree distribution in the range [1,20).</span>

<span class="sd">    &gt;&gt;&gt; p = scipy.stats.poisson</span>
<span class="sd">    &gt;&gt;&gt; g = gt.random_graph(20000, lambda: (sample_k(19), sample_k(19)),</span>
<span class="sd">    ...                     model=&quot;probabilistic&quot;,</span>
<span class="sd">    ...                     vertex_corr=lambda a,b: (p.pmf(a[0], b[1]) *</span>
<span class="sd">    ...                                              p.pmf(a[1], 20 - b[0])),</span>
<span class="sd">    ...                     n_iter=100)</span>

<span class="sd">    Lets plot the average degree correlations to check.</span>

<span class="sd">    &gt;&gt;&gt; figure()</span>
<span class="sd">    &lt;...&gt;</span>
<span class="sd">    &gt;&gt;&gt; corr = gt.avg_neighbour_corr(g, &quot;in&quot;, &quot;in&quot;)</span>
<span class="sd">    &gt;&gt;&gt; errorbar(corr[2][:-1], corr[0], yerr=corr[1], fmt=&quot;o-&quot;,</span>
<span class="sd">    ...         label=r&quot;$\left&lt;\text{in}\right&gt;$ vs in&quot;)</span>
<span class="sd">    &lt;...&gt;</span>
<span class="sd">    &gt;&gt;&gt; corr = gt.avg_neighbour_corr(g, &quot;in&quot;, &quot;out&quot;)</span>
<span class="sd">    &gt;&gt;&gt; errorbar(corr[2][:-1], corr[0], yerr=corr[1], fmt=&quot;o-&quot;,</span>
<span class="sd">    ...         label=r&quot;$\left&lt;\text{out}\right&gt;$ vs in&quot;)</span>
<span class="sd">    &lt;...&gt;</span>
<span class="sd">    &gt;&gt;&gt; corr = gt.avg_neighbour_corr(g, &quot;out&quot;, &quot;in&quot;)</span>
<span class="sd">    &gt;&gt;&gt; errorbar(corr[2][:-1], corr[0], yerr=corr[1], fmt=&quot;o-&quot;,</span>
<span class="sd">    ...          label=r&quot;$\left&lt;\text{in}\right&gt;$ vs out&quot;)</span>
<span class="sd">    &lt;...&gt;</span>
<span class="sd">    &gt;&gt;&gt; corr = gt.avg_neighbour_corr(g, &quot;out&quot;, &quot;out&quot;)</span>
<span class="sd">    &gt;&gt;&gt; errorbar(corr[2][:-1], corr[0], yerr=corr[1], fmt=&quot;o-&quot;,</span>
<span class="sd">    ...          label=r&quot;$\left&lt;\text{out}\right&gt;$ vs out&quot;)</span>
<span class="sd">    &lt;...&gt;</span>
<span class="sd">    &gt;&gt;&gt; legend(loc=&quot;lower right&quot;, borderaxespad=0., framealpha=0.8)</span>
<span class="sd">    &lt;...&gt;</span>
<span class="sd">    &gt;&gt;&gt; xlabel(&quot;Source degree&quot;)</span>
<span class="sd">    &lt;...&gt;</span>
<span class="sd">    &gt;&gt;&gt; ylabel(&quot;Average target degree&quot;)</span>
<span class="sd">    &lt;...&gt;</span>
<span class="sd">    &gt;&gt;&gt; tight_layout()</span>
<span class="sd">    &gt;&gt;&gt; savefig(&quot;deg-corr-dir.pdf&quot;)</span>

<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       savefig(&quot;deg-corr-dir.png&quot;)</span>

<span class="sd">    .. figure:: deg-corr-dir.*</span>
<span class="sd">        :align: center</span>

<span class="sd">        Average nearest neighbour correlations.</span>


<span class="sd">    **Stochastic blockmodels**</span>


<span class="sd">    The following example shows how a stochastic blockmodel</span>
<span class="sd">    [holland-stochastic-1983]_ [karrer-stochastic-2011]_ can be generated. We</span>
<span class="sd">    will consider a system of 10 blocks, which form communities. The connection</span>
<span class="sd">    probability will be given by</span>

<span class="sd">    &gt;&gt;&gt; def corr(a, b):</span>
<span class="sd">    ...    if a == b:</span>
<span class="sd">    ...        return 0.999</span>
<span class="sd">    ...    else:</span>
<span class="sd">    ...        return 0.001</span>

<span class="sd">    The blockmodel can be generated as follows.</span>

<span class="sd">    &gt;&gt;&gt; g, bm = gt.random_graph(2000, lambda: poisson(10), directed=False,</span>
<span class="sd">    ...                         model=&quot;blockmodel-traditional&quot;,</span>
<span class="sd">    ...                         block_membership=lambda: randint(10),</span>
<span class="sd">    ...                         vertex_corr=corr)</span>
<span class="sd">    &gt;&gt;&gt; gt.graph_draw(g, vertex_fill_color=bm, edge_color=&quot;black&quot;, output=&quot;blockmodel.pdf&quot;)</span>
<span class="sd">    &lt;...&gt;</span>

<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       gt.graph_draw(g, vertex_fill_color=bm, edge_color=&quot;black&quot;, output=&quot;blockmodel.png&quot;)</span>

<span class="sd">    .. figure:: blockmodel.*</span>
<span class="sd">        :align: center</span>

<span class="sd">        Simple blockmodel with 10 blocks.</span>


<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [metropolis-equations-1953]  Metropolis, N.; Rosenbluth, A.W.;</span>
<span class="sd">       Rosenbluth, M.N.; Teller, A.H.; Teller, E. &quot;Equations of State</span>
<span class="sd">       Calculations by Fast Computing Machines&quot;. Journal of Chemical Physics 21</span>
<span class="sd">       (6): 1087-1092 (1953). :doi:`10.1063/1.1699114`</span>
<span class="sd">    .. [hastings-monte-carlo-1970] Hastings, W.K. &quot;Monte Carlo Sampling Methods</span>
<span class="sd">       Using Markov Chains and Their Applications&quot;. Biometrika 57 (1): 97-109 (1970).</span>
<span class="sd">       :doi:`10.1093/biomet/57.1.97`</span>
<span class="sd">    .. [holland-stochastic-1983] Paul W. Holland, Kathryn Blackmond Laskey, and</span>
<span class="sd">       Samuel Leinhardt, &quot;Stochastic blockmodels: First steps,&quot; Social Networks</span>
<span class="sd">       5, no. 2: 109-13 (1983) :doi:`10.1016/0378-8733(83)90021-7`</span>
<span class="sd">    .. [karrer-stochastic-2011] Brian Karrer and M. E. J. Newman, &quot;Stochastic</span>
<span class="sd">       blockmodels and community structure in networks,&quot; Physical Review E 83,</span>
<span class="sd">       no. 1: 016107 (2011) :doi:`10.1103/PhysRevE.83.016107` :arxiv:`1008.3926`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span>

    <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">block_membership</span><span class="p">)</span> <span class="ow">is</span> <span class="n">types</span><span class="o">.</span><span class="n">FunctionType</span> <span class="ow">or</span>
        <span class="nb">type</span><span class="p">(</span><span class="n">block_membership</span><span class="p">)</span> <span class="ow">is</span> <span class="n">types</span><span class="o">.</span><span class="n">LambdaType</span><span class="p">):</span>
        <span class="n">btype</span> <span class="o">=</span> <span class="n">block_type</span>
        <span class="n">bm</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">inspect</span><span class="o">.</span><span class="n">getargspec</span><span class="p">(</span><span class="n">block_membership</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
                <span class="n">bm</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">block_membership</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
                <span class="n">bm</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">block_membership</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
        <span class="n">block_membership</span> <span class="o">=</span> <span class="n">bm</span>
    <span class="k">elif</span> <span class="n">block_membership</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">btype</span> <span class="o">=</span> <span class="n">_gt_type</span><span class="p">(</span><span class="n">block_membership</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">inspect</span><span class="o">.</span><span class="n">getargspec</span><span class="p">(</span><span class="n">deg_sampler</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">block_membership</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">sampler</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">deg_sampler</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">block_membership</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sampler</span> <span class="o">=</span> <span class="n">deg_sampler</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sampler</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">deg_sampler</span><span class="p">()</span>

    <span class="n">libgraph_tool_generation</span><span class="o">.</span><span class="n">gen_graph</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">sampler</span><span class="p">,</span>
                                       <span class="ow">not</span> <span class="n">parallel_edges</span><span class="p">,</span>
                                       <span class="ow">not</span> <span class="n">self_loops</span><span class="p">,</span> <span class="ow">not</span> <span class="n">directed</span><span class="p">,</span>
                                       <span class="n">_get_rng</span><span class="p">(),</span> <span class="n">verbose</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
    <span class="n">g</span><span class="o">.</span><span class="n">set_directed</span><span class="p">(</span><span class="n">directed</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">degree_block</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">btype</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&quot;object&quot;</span><span class="p">,</span> <span class="s">&quot;string&quot;</span><span class="p">]</span> <span class="ow">or</span> <span class="s">&quot;vector&quot;</span> <span class="ow">in</span> <span class="n">btype</span><span class="p">:</span>
            <span class="n">btype</span> <span class="o">=</span> <span class="s">&quot;object&quot;</span>
        <span class="k">elif</span> <span class="n">btype</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&quot;int&quot;</span><span class="p">,</span> <span class="s">&quot;int32_t&quot;</span><span class="p">,</span> <span class="s">&quot;bool&quot;</span><span class="p">]:</span>
            <span class="n">btype</span> <span class="o">=</span> <span class="s">&quot;vector&lt;int32_t&gt;&quot;</span>
        <span class="k">elif</span> <span class="n">btype</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&quot;long&quot;</span><span class="p">,</span> <span class="s">&quot;int64_t&quot;</span><span class="p">]:</span>
            <span class="n">btype</span> <span class="o">=</span> <span class="s">&quot;vector&lt;int64_t&gt;&quot;</span>
        <span class="k">elif</span> <span class="n">btype</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&quot;double&quot;</span><span class="p">]:</span>
            <span class="n">btype</span> <span class="o">=</span> <span class="s">&quot;vector&lt;double&gt;&quot;</span>
        <span class="k">elif</span> <span class="n">btype</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&quot;long double&quot;</span><span class="p">]:</span>
            <span class="n">btype</span> <span class="o">=</span> <span class="s">&quot;vector&lt;long double&gt;&quot;</span>

    <span class="k">if</span> <span class="n">block_membership</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">bm</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="n">btype</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">btype</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&quot;object&quot;</span><span class="p">,</span> <span class="s">&quot;string&quot;</span><span class="p">]</span> <span class="ow">or</span> <span class="s">&quot;vector&quot;</span> <span class="ow">in</span> <span class="n">btype</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">vertices</span><span class="p">():</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">degree_block</span><span class="p">:</span>
                    <span class="n">bm</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">block_membership</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">v</span><span class="p">)]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">is_directed</span><span class="p">():</span>
                        <span class="n">bm</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">block_membership</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">v</span><span class="p">)],</span> <span class="n">v</span><span class="o">.</span><span class="n">in_degree</span><span class="p">(),</span>
                                 <span class="n">v</span><span class="o">.</span><span class="n">out_degree</span><span class="p">())</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">bm</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">block_membership</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">v</span><span class="p">)],</span> <span class="n">v</span><span class="o">.</span><span class="n">out_degree</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">bm</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">block_membership</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="n">bm</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="s">&quot;object&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">vertices</span><span class="p">():</span>
                    <span class="n">bm</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">block_membership</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">v</span><span class="p">)]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">bm</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">if</span> <span class="n">random</span><span class="p">:</span>
        <span class="n">g</span><span class="o">.</span><span class="n">set_fast_edge_removal</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">random_rewire</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">parallel_edges</span><span class="o">=</span><span class="n">parallel_edges</span><span class="p">,</span>
                      <span class="n">self_loops</span><span class="o">=</span><span class="n">self_loops</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                      <span class="n">block_membership</span><span class="o">=</span><span class="n">bm</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">g</span><span class="o">.</span><span class="n">set_fast_edge_removal</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">bm</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">g</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">g</span><span class="p">,</span> <span class="n">bm</span>

</div>
<span class="nd">@_limit_args</span><span class="p">({</span><span class="s">&quot;model&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s">&quot;erdos&quot;</span><span class="p">,</span> <span class="s">&quot;correlated&quot;</span><span class="p">,</span> <span class="s">&quot;uncorrelated&quot;</span><span class="p">,</span>
                        <span class="s">&quot;probabilistic&quot;</span><span class="p">,</span> <span class="s">&quot;blockmodel&quot;</span><span class="p">,</span>
                        <span class="s">&quot;blockmodel-traditional&quot;</span><span class="p">]})</span>
<div class="viewcode-block" id="random_rewire"><a class="viewcode-back" href="../../generation.html#graph_tool.generation.random_rewire">[docs]</a><span class="k">def</span> <span class="nf">random_rewire</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s">&quot;uncorrelated&quot;</span><span class="p">,</span> <span class="n">n_iter</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">edge_sweep</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                  <span class="n">parallel_edges</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">self_loops</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">vertex_corr</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                  <span class="n">block_membership</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">alias</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">cache_probs</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                  <span class="n">persist</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">pin</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">ret_fail</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>

<span class="sd">    Shuffle the graph in-place, following a variety of possible statistical</span>
<span class="sd">    models, chosen via the parameter ``model``.</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    g : :class:`~graph_tool.Graph`</span>
<span class="sd">        Graph to be shuffled. The graph will be modified.</span>
<span class="sd">    model : string (optional, default: ``&quot;uncorrelated&quot;``)</span>
<span class="sd">        The following statistical models can be chosen, which determine how the</span>
<span class="sd">        edges are rewired.</span>

<span class="sd">        ``erdos``</span>
<span class="sd">           The edges will be rewired entirely randomly, and the resulting graph</span>
<span class="sd">           will correspond to the Erdős–Rényi model.</span>
<span class="sd">        ``uncorrelated``</span>
<span class="sd">           The edges will be rewired randomly, but the degree sequence of the</span>
<span class="sd">           graph will remain unmodified.</span>
<span class="sd">        ``correlated``</span>
<span class="sd">           The edges will be rewired randomly, but both the degree sequence of</span>
<span class="sd">           the graph and the *vertex-vertex (in,out)-degree correlations* will</span>
<span class="sd">           remain exactly preserved. If the ``block_membership`` parameter is</span>
<span class="sd">           passed, the block variables at the endpoints of the edges will be</span>
<span class="sd">           preserved (instead of the degrees), in addition to the degree</span>
<span class="sd">           sequence.</span>
<span class="sd">        ``probabilistic``</span>
<span class="sd">           This is similar to the ``correlated`` option, but the vertex-vertex</span>
<span class="sd">           correlations are not kept unmodified, but instead are sampled from an</span>
<span class="sd">           arbitrary degree-based probabilistic model specified via the</span>
<span class="sd">           ``vertex_corr`` parameter.</span>
<span class="sd">        ``blockmodel``</span>
<span class="sd">          This is just like ``probabilistic``, but the values passed to the</span>
<span class="sd">          ``vertex_corr`` function will correspond to the block membership</span>
<span class="sd">          values specified by the ``block_membership`` parameter.</span>
<span class="sd">        ``blockmodel-traditional``</span>
<span class="sd">          This is just like ``blockmodel``, but the degree sequence *is not*</span>
<span class="sd">          preserved during rewiring.</span>

<span class="sd">    n_iter : int (optional, default: ``1``)</span>
<span class="sd">        Number of iterations. If ``edge_sweep == True``, each iteration</span>
<span class="sd">        corresponds to an entire &quot;sweep&quot; over all edges. Otherwise this</span>
<span class="sd">        corresponds to the total number of edges which are randomly chosen for a</span>
<span class="sd">        swap attempt (which may repeat).</span>
<span class="sd">    edge_sweep : bool (optional, default: ``True``)</span>
<span class="sd">        If ``True``, each iteration will perform an entire &quot;sweep&quot; over the</span>
<span class="sd">        edges, where each edge is visited once in random order, and a edge swap</span>
<span class="sd">        is attempted.</span>
<span class="sd">    parallel_edges : bool (optional, default: ``False``)</span>
<span class="sd">        If ``True``, parallel edges are allowed.</span>
<span class="sd">    self_loops : bool (optional, default: ``False``)</span>
<span class="sd">        If ``True``, self-loops are allowed.</span>
<span class="sd">    vertex_corr : function or sequence of triples (optional, default: ``None``)</span>

<span class="sd">        A function which gives the vertex-vertex correlation of the edges in the</span>
<span class="sd">        graph. In general it should have the following signature:</span>

<span class="sd">        .. code::</span>

<span class="sd">            def vertex_corr(r, s):</span>
<span class="sd">                ...</span>
<span class="sd">                return p</span>

<span class="sd">        where the return value should be a scalar.</span>

<span class="sd">        Alternatively, this parameter can be a list of triples of the form</span>
<span class="sd">        ``(r, s, p)``, with the same meaning as the ``r``, ``s`` and ``p``</span>
<span class="sd">        values above. If a given ``(r, s)`` combination is not present in this</span>
<span class="sd">        list, the corresponding value of ``p`` is assumed to be zero. If the same</span>
<span class="sd">        ``(r, s)`` combination appears more than once, their ``p`` values will</span>
<span class="sd">        be summed together. This is useful when the correlation matrix is sparse,</span>
<span class="sd">        i.e. most entries are zero.</span>

<span class="sd">        If ``model == probabilistic`` the parameters ``r`` and ``s`` correspond</span>
<span class="sd">        respectively to the (in, out)-degree pair of the source vertex an edge,</span>
<span class="sd">        and the (in,out)-degree pair of the target of the same edge (for</span>
<span class="sd">        undirected graphs, both parameters are scalars instead). The value of</span>
<span class="sd">        ``p`` should be a number proportional to the probability of such an</span>
<span class="sd">        edge existing in the generated graph.</span>

<span class="sd">        If ``model == blockmodel`` or ``model == blockmodel-traditional``, the</span>
<span class="sd">        ``r`` and ``s`` values passed to the function will be the block values</span>
<span class="sd">        of the respective vertices, as specified via the ``block_membership``</span>
<span class="sd">        parameter. The value of  ``p`` should be a number proportional to the</span>
<span class="sd">        probability of such an edge existing in the generated graph.</span>
<span class="sd">    block_membership : :class:`~graph_tool.PropertyMap` (optional, default: ``None``)</span>
<span class="sd">        If supplied, the graph will be rewired to conform to a blockmodel</span>
<span class="sd">        ensemble. The value must be a vertex property map which defines the</span>
<span class="sd">        block of each vertex.</span>
<span class="sd">    alias : bool (optional, default: ``True``)</span>
<span class="sd">        If ``True``, and ``model`` is any of ``probabilistic``, ``blockmodel``,</span>
<span class="sd">        or ``blockmodel-traditional``, the alias method will be used to sample</span>
<span class="sd">        the candidate edges. In the case of ``blockmodel-traditional``, if</span>
<span class="sd">        ``parallel_edges == True`` and ``self_loops == True`` this makes the</span>
<span class="sd">        sampling of the edges direct (not rejection based), so that</span>
<span class="sd">        ``n_iter == 1`` is enough to get an uncorrelated sample.</span>
<span class="sd">    cache_probs : bool (optional, default: ``True``)</span>
<span class="sd">        If ``True``, the probabilities returned by the ``vertex_corr`` parameter</span>
<span class="sd">        will be cached internally. This is crucial for good performance, since</span>
<span class="sd">        in this case the supplied python function is called only a few times,</span>
<span class="sd">        and not at every attempted edge rewire move. However, in the case were</span>
<span class="sd">        the different parameter combinations to the probability function is very</span>
<span class="sd">        large, the memory and time requirements to keep the cache may not be</span>
<span class="sd">        worthwhile.</span>
<span class="sd">    persist : bool (optional, default: ``False``)</span>
<span class="sd">        If ``True``, an edge swap which is rejected will be attempted again</span>
<span class="sd">        until it succeeds. This may improve the quality of the shuffling for</span>
<span class="sd">        some probabilistic models, and should be sufficiently fast for sparse</span>
<span class="sd">        graphs, but otherwise it may result in many repeated attempts for</span>
<span class="sd">        certain corner-cases in which edges are difficult to swap.</span>
<span class="sd">    pin : :class:`~graph_tool.PropertyMap` (optional, default: ``None``)</span>
<span class="sd">        Edge property map which, if provided, specifies which edges are allowed</span>
<span class="sd">        to be rewired. Edges for which the property value is ``1`` (or ``True``)</span>
<span class="sd">        will be left unmodified in the graph.</span>
<span class="sd">    verbose : bool (optional, default: ``False``)</span>
<span class="sd">        If ``True``, verbose information is displayed.</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    rejection_count : int</span>
<span class="sd">        Number of rejected edge moves (due to parallel edges or self-loops, or</span>
<span class="sd">        the probabilistic model used).</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    random_graph: random graph generation</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This algorithm iterates through all the edges in the network and tries to</span>
<span class="sd">    swap its target or source with the target or source of another edge. The</span>
<span class="sd">    selected canditate swaps are chosen according to the ``model`` parameter.</span>

<span class="sd">    .. note::</span>

<span class="sd">        If ``parallel_edges = False``, parallel edges are not placed during</span>
<span class="sd">        rewiring. In this case, the returned graph will be a uncorrelated sample</span>
<span class="sd">        from the desired ensemble only if ``n_iter`` is sufficiently large. The</span>
<span class="sd">        algorithm implements an efficient Markov chain based on edge swaps, with</span>
<span class="sd">        a mixing time which depends on the degree distribution and correlations</span>
<span class="sd">        desired. If degree probabilistic correlations are provided, the mixing</span>
<span class="sd">        time tends to be larger.</span>

<span class="sd">        If ``model`` is either &quot;probabilistic&quot; or &quot;blockmodel&quot;, the Markov chain</span>
<span class="sd">        still needs to be mixed, even if parallel edges and self-loops are</span>
<span class="sd">        allowed. In this case the Markov chain is implemented using the</span>
<span class="sd">        Metropolis-Hastings [metropolis-equations-1953]_</span>
<span class="sd">        [hastings-monte-carlo-1970]_ acceptance/rejection algorithm. It will</span>
<span class="sd">        eventually converge to the desired probabilities for sufficiently large</span>
<span class="sd">        values of ``n_iter``.</span>


<span class="sd">    Each edge is tentatively swapped once per iteration, so the overall</span>
<span class="sd">    complexity is :math:`O(V + E \times \text{n-iter})`. If ``edge_sweep ==</span>
<span class="sd">    False``, the complexity becomes :math:`O(V + E + \text{n-iter})`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    Some small graphs for visualization.</span>

<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       from numpy.random import random, seed</span>
<span class="sd">       from pylab import *</span>
<span class="sd">       seed(43)</span>
<span class="sd">       gt.seed_rng(42)</span>

<span class="sd">    &gt;&gt;&gt; g, pos = gt.triangulation(random((1000,2)))</span>
<span class="sd">    &gt;&gt;&gt; pos = gt.arf_layout(g)</span>
<span class="sd">    &gt;&gt;&gt; gt.graph_draw(g, pos=pos, output=&quot;rewire_orig.pdf&quot;, output_size=(300, 300))</span>
<span class="sd">    &lt;...&gt;</span>

<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       gt.graph_draw(g, pos=pos, output=&quot;rewire_orig.png&quot;, output_size=(300, 300))</span>

<span class="sd">    &gt;&gt;&gt; gt.random_rewire(g, &quot;correlated&quot;)</span>
<span class="sd">    601</span>
<span class="sd">    &gt;&gt;&gt; pos = gt.arf_layout(g)</span>
<span class="sd">    &gt;&gt;&gt; gt.graph_draw(g, pos=pos, output=&quot;rewire_corr.pdf&quot;, output_size=(300, 300))</span>
<span class="sd">    &lt;...&gt;</span>

<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       gt.graph_draw(g, pos=pos, output=&quot;rewire_corr.png&quot;, output_size=(300, 300))</span>

<span class="sd">    &gt;&gt;&gt; gt.random_rewire(g)</span>
<span class="sd">    215</span>
<span class="sd">    &gt;&gt;&gt; pos = gt.arf_layout(g)</span>
<span class="sd">    &gt;&gt;&gt; gt.graph_draw(g, pos=pos, output=&quot;rewire_uncorr.pdf&quot;, output_size=(300, 300))</span>
<span class="sd">    &lt;...&gt;</span>

<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       gt.graph_draw(g, pos=pos, output=&quot;rewire_uncorr.png&quot;, output_size=(300, 300))</span>

<span class="sd">    &gt;&gt;&gt; gt.random_rewire(g, &quot;erdos&quot;)</span>
<span class="sd">    16</span>
<span class="sd">    &gt;&gt;&gt; pos = gt.arf_layout(g)</span>
<span class="sd">    &gt;&gt;&gt; gt.graph_draw(g, pos=pos, output=&quot;rewire_erdos.pdf&quot;, output_size=(300, 300))</span>
<span class="sd">    &lt;...&gt;</span>

<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       gt.graph_draw(g, pos=pos, output=&quot;rewire_erdos.png&quot;, output_size=(300, 300))</span>

<span class="sd">    Some `ridiculograms &lt;http://www.youtube.com/watch?v=YS-asmU3p_4&gt;`_ :</span>

<span class="sd">    .. image:: rewire_orig.*</span>
<span class="sd">    .. image:: rewire_corr.*</span>
<span class="sd">    .. image:: rewire_uncorr.*</span>
<span class="sd">    .. image:: rewire_erdos.*</span>

<span class="sd">    **From left to right**: Original graph; Shuffled graph, with degree correlations;</span>
<span class="sd">    Shuffled graph, without degree correlations; Shuffled graph, with random degrees.</span>

<span class="sd">    We can try with larger graphs to get better statistics, as follows.</span>

<span class="sd">    &gt;&gt;&gt; figure()</span>
<span class="sd">    &lt;...&gt;</span>
<span class="sd">    &gt;&gt;&gt; g = gt.random_graph(30000, lambda: sample_k(20), model=&quot;probabilistic&quot;,</span>
<span class="sd">    ...                     vertex_corr=lambda i, j: exp(abs(i-j)), directed=False,</span>
<span class="sd">    ...                     n_iter=100)</span>
<span class="sd">    &gt;&gt;&gt; corr = gt.avg_neighbour_corr(g, &quot;out&quot;, &quot;out&quot;)</span>
<span class="sd">    &gt;&gt;&gt; errorbar(corr[2][:-1], corr[0], yerr=corr[1], fmt=&quot;o-&quot;, label=&quot;Original&quot;)</span>
<span class="sd">    &lt;...&gt;</span>
<span class="sd">    &gt;&gt;&gt; gt.random_rewire(g, &quot;correlated&quot;)</span>
<span class="sd">    252</span>
<span class="sd">    &gt;&gt;&gt; corr = gt.avg_neighbour_corr(g, &quot;out&quot;, &quot;out&quot;)</span>
<span class="sd">    &gt;&gt;&gt; errorbar(corr[2][:-1], corr[0], yerr=corr[1], fmt=&quot;*&quot;, label=&quot;Correlated&quot;)</span>
<span class="sd">    &lt;...&gt;</span>
<span class="sd">    &gt;&gt;&gt; gt.random_rewire(g)</span>
<span class="sd">    92</span>
<span class="sd">    &gt;&gt;&gt; corr = gt.avg_neighbour_corr(g, &quot;out&quot;, &quot;out&quot;)</span>
<span class="sd">    &gt;&gt;&gt; errorbar(corr[2][:-1], corr[0], yerr=corr[1], fmt=&quot;o-&quot;, label=&quot;Uncorrelated&quot;)</span>
<span class="sd">    &lt;...&gt;</span>
<span class="sd">    &gt;&gt;&gt; gt.random_rewire(g, &quot;erdos&quot;)</span>
<span class="sd">    9</span>
<span class="sd">    &gt;&gt;&gt; corr = gt.avg_neighbour_corr(g, &quot;out&quot;, &quot;out&quot;)</span>
<span class="sd">    &gt;&gt;&gt; errorbar(corr[2][:-1], corr[0], yerr=corr[1], fmt=&quot;o-&quot;, label=r&quot;Erd\H{o}s&quot;)</span>
<span class="sd">    &lt;...&gt;</span>
<span class="sd">    &gt;&gt;&gt; xlabel(&quot;$k$&quot;)</span>
<span class="sd">    &lt;...&gt;</span>
<span class="sd">    &gt;&gt;&gt; ylabel(r&quot;$\left&lt;k_{nn}\right&gt;$&quot;)</span>
<span class="sd">    &lt;...&gt;</span>
<span class="sd">    &gt;&gt;&gt; legend(loc=&quot;best&quot;)</span>
<span class="sd">    &lt;...&gt;</span>
<span class="sd">    &gt;&gt;&gt; tight_layout()</span>
<span class="sd">    &gt;&gt;&gt; savefig(&quot;shuffled-stats.pdf&quot;)</span>

<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       savefig(&quot;shuffled-stats.png&quot;)</span>


<span class="sd">    .. figure:: shuffled-stats.*</span>
<span class="sd">        :align: center</span>

<span class="sd">        Average degree correlations for the different shuffled and non-shuffled</span>
<span class="sd">        graphs. The shuffled graph with correlations displays exactly the same</span>
<span class="sd">        correlation as the original graph.</span>

<span class="sd">    Now let&#39;s do it for a directed graph. See</span>
<span class="sd">    :func:`~graph_tool.generation.random_graph` for more details.</span>

<span class="sd">    &gt;&gt;&gt; p = scipy.stats.poisson</span>
<span class="sd">    &gt;&gt;&gt; g = gt.random_graph(20000, lambda: (sample_k(19), sample_k(19)),</span>
<span class="sd">    ...                     model=&quot;probabilistic&quot;,</span>
<span class="sd">    ...                     vertex_corr=lambda a, b: (p.pmf(a[0], b[1]) * p.pmf(a[1], 20 - b[0])),</span>
<span class="sd">    ...                     n_iter=100)</span>
<span class="sd">    &gt;&gt;&gt; figure()</span>
<span class="sd">    &lt;...&gt;</span>
<span class="sd">    &gt;&gt;&gt; corr = gt.avg_neighbour_corr(g, &quot;in&quot;, &quot;out&quot;)</span>
<span class="sd">    &gt;&gt;&gt; errorbar(corr[2][:-1], corr[0], yerr=corr[1], fmt=&quot;o-&quot;,</span>
<span class="sd">    ...          label=r&quot;$\left&lt;\text{o}\right&gt;$ vs i&quot;)</span>
<span class="sd">    &lt;...&gt;</span>
<span class="sd">    &gt;&gt;&gt; corr = gt.avg_neighbour_corr(g, &quot;out&quot;, &quot;in&quot;)</span>
<span class="sd">    &gt;&gt;&gt; errorbar(corr[2][:-1], corr[0], yerr=corr[1], fmt=&quot;o-&quot;,</span>
<span class="sd">    ...          label=r&quot;$\left&lt;\text{i}\right&gt;$ vs o&quot;)</span>
<span class="sd">    &lt;...&gt;</span>
<span class="sd">    &gt;&gt;&gt; gt.random_rewire(g, &quot;correlated&quot;)</span>
<span class="sd">    4199</span>
<span class="sd">    &gt;&gt;&gt; corr = gt.avg_neighbour_corr(g, &quot;in&quot;, &quot;out&quot;)</span>
<span class="sd">    &gt;&gt;&gt; errorbar(corr[2][:-1], corr[0], yerr=corr[1], fmt=&quot;o-&quot;,</span>
<span class="sd">    ...          label=r&quot;$\left&lt;\text{o}\right&gt;$ vs i, corr.&quot;)</span>
<span class="sd">    &lt;...&gt;</span>
<span class="sd">    &gt;&gt;&gt; corr = gt.avg_neighbour_corr(g, &quot;out&quot;, &quot;in&quot;)</span>
<span class="sd">    &gt;&gt;&gt; errorbar(corr[2][:-1], corr[0], yerr=corr[1], fmt=&quot;o-&quot;,</span>
<span class="sd">    ...          label=r&quot;$\left&lt;\text{i}\right&gt;$ vs o, corr.&quot;)</span>
<span class="sd">    &lt;...&gt;</span>
<span class="sd">    &gt;&gt;&gt; gt.random_rewire(g, &quot;uncorrelated&quot;)</span>
<span class="sd">    193</span>
<span class="sd">    &gt;&gt;&gt; corr = gt.avg_neighbour_corr(g, &quot;in&quot;, &quot;out&quot;)</span>
<span class="sd">    &gt;&gt;&gt; errorbar(corr[2][:-1], corr[0], yerr=corr[1], fmt=&quot;o-&quot;,</span>
<span class="sd">    ...          label=r&quot;$\left&lt;\text{o}\right&gt;$ vs i, uncorr.&quot;)</span>
<span class="sd">    &lt;...&gt;</span>
<span class="sd">    &gt;&gt;&gt; corr = gt.avg_neighbour_corr(g, &quot;out&quot;, &quot;in&quot;)</span>
<span class="sd">    &gt;&gt;&gt; errorbar(corr[2][:-1], corr[0], yerr=corr[1], fmt=&quot;o-&quot;,</span>
<span class="sd">    ...          label=r&quot;$\left&lt;\text{i}\right&gt;$ vs o, uncorr.&quot;)</span>
<span class="sd">    &lt;...&gt;</span>
<span class="sd">    &gt;&gt;&gt; legend(loc=&quot;lower right&quot;, borderaxespad=0., framealpha=0.8)</span>
<span class="sd">    &lt;...&gt;</span>
<span class="sd">    &gt;&gt;&gt; xlabel(&quot;Source degree&quot;)</span>
<span class="sd">    &lt;...&gt;</span>
<span class="sd">    &gt;&gt;&gt; ylabel(&quot;Average target degree&quot;)</span>
<span class="sd">    &lt;...&gt;</span>
<span class="sd">    &gt;&gt;&gt; tight_layout()</span>
<span class="sd">    &gt;&gt;&gt; savefig(&quot;shuffled-deg-corr-dir.pdf&quot;)</span>

<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       savefig(&quot;shuffled-deg-corr-dir.png&quot;)</span>

<span class="sd">    .. figure:: shuffled-deg-corr-dir.*</span>
<span class="sd">        :align: center</span>

<span class="sd">        Average degree correlations for the different shuffled and non-shuffled</span>
<span class="sd">        directed graphs. The shuffled graph with correlations displays exactly</span>
<span class="sd">        the same correlation as the original graph.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [metropolis-equations-1953]  Metropolis, N.; Rosenbluth, A.W.;</span>
<span class="sd">       Rosenbluth, M.N.; Teller, A.H.; Teller, E. &quot;Equations of State</span>
<span class="sd">       Calculations by Fast Computing Machines&quot;. Journal of Chemical Physics 21</span>
<span class="sd">       (6): 1087-1092 (1953). :doi:`10.1063/1.1699114`</span>
<span class="sd">    .. [hastings-monte-carlo-1970] Hastings, W.K. &quot;Monte Carlo Sampling Methods</span>
<span class="sd">       Using Markov Chains and Their Applications&quot;. Biometrika 57 (1): 97-109 (1970).</span>
<span class="sd">       :doi:`10.1093/biomet/57.1.97`</span>
<span class="sd">    .. [holland-stochastic-1983] Paul W. Holland, Kathryn Blackmond Laskey, and</span>
<span class="sd">       Samuel Leinhardt, &quot;Stochastic blockmodels: First steps,&quot; Social Networks</span>
<span class="sd">       5, no. 2: 109-13 (1983) :doi:`10.1016/0378-8733(83)90021-7`</span>
<span class="sd">    .. [karrer-stochastic-2011] Brian Karrer and M. E. J. Newman, &quot;Stochastic</span>
<span class="sd">       blockmodels and community structure in networks,&quot; Physical Review E 83,</span>
<span class="sd">       no. 1: 016107 (2011) :doi:`10.1103/PhysRevE.83.016107` :arxiv:`1008.3926`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># if not parallel_edges:</span>
    <span class="c">#     p = label_parallel_edges(g)</span>
    <span class="c">#     if p.a.max() != 0:</span>
    <span class="c">#         raise ValueError(&quot;Parallel edge detected. Can&#39;t rewire &quot; +</span>
    <span class="c">#                          &quot;graph without parallel edges if it &quot; +</span>
    <span class="c">#                          &quot;already contains parallel edges!&quot;)</span>

    <span class="c"># if not self_loops:</span>
    <span class="c">#     l = label_self_loops(g)</span>
    <span class="c">#     if l.a.max() != 0:</span>
    <span class="c">#         raise ValueError(&quot;Self-loop detected. Can&#39;t rewire graph &quot; +</span>
    <span class="c">#                          &quot;without self-loops if it already contains&quot; +</span>
    <span class="c">#                          &quot; self-loops!&quot;)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">vertex_corr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">g</span><span class="o">.</span><span class="n">is_directed</span><span class="p">())</span> <span class="ow">and</span> <span class="s">&quot;blockmodel&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">model</span><span class="p">:</span>
        <span class="n">corr</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="n">vertex_corr</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">j</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">corr</span> <span class="o">=</span> <span class="n">vertex_corr</span>

    <span class="k">if</span> <span class="n">model</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&quot;probabilistic&quot;</span><span class="p">,</span> <span class="s">&quot;blockmodel&quot;</span><span class="p">,</span> <span class="s">&quot;blockmodel-traditional&quot;</span><span class="p">]:</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">GraphView</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="nb">reversed</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">model</span> <span class="o">==</span> <span class="s">&quot;blockmodel&quot;</span> <span class="ow">and</span> <span class="n">alias</span> <span class="ow">and</span> <span class="n">edge_sweep</span><span class="p">:</span>
        <span class="n">edge_sweep</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">n_iter</span> <span class="o">*=</span> <span class="n">g</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()</span>

    <span class="n">traditional</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="k">if</span> <span class="n">model</span> <span class="o">==</span> <span class="s">&quot;blockmodel-traditional&quot;</span><span class="p">:</span>
        <span class="n">model</span> <span class="o">=</span> <span class="s">&quot;blockmodel&quot;</span>
        <span class="n">traditional</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="k">if</span> <span class="n">pin</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">pin</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_edge_property</span><span class="p">(</span><span class="s">&quot;bool&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">pin</span><span class="o">.</span><span class="n">value_type</span><span class="p">()</span> <span class="o">!=</span> <span class="s">&quot;bool&quot;</span><span class="p">:</span>
        <span class="n">pin</span> <span class="o">=</span> <span class="n">pin</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">value_type</span><span class="o">=</span><span class="s">&quot;bool&quot;</span><span class="p">)</span>

    <span class="n">pcount</span> <span class="o">=</span> <span class="n">libgraph_tool_generation</span><span class="o">.</span><span class="n">random_rewire</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span>
                                                    <span class="n">n_iter</span><span class="p">,</span> <span class="ow">not</span> <span class="n">edge_sweep</span><span class="p">,</span>
                                                    <span class="n">self_loops</span><span class="p">,</span> <span class="n">parallel_edges</span><span class="p">,</span>
                                                    <span class="n">alias</span><span class="p">,</span> <span class="n">traditional</span><span class="p">,</span> <span class="n">persist</span><span class="p">,</span>
                                                    <span class="n">corr</span><span class="p">,</span>
                                                    <span class="n">_prop</span><span class="p">(</span><span class="s">&quot;e&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">pin</span><span class="p">),</span>
                                                    <span class="n">_prop</span><span class="p">(</span><span class="s">&quot;v&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">block_membership</span><span class="p">),</span>
                                                    <span class="n">cache_probs</span><span class="p">,</span>
                                                    <span class="n">_get_rng</span><span class="p">(),</span> <span class="n">verbose</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">pcount</span>

</div>
<div class="viewcode-block" id="predecessor_tree"><a class="viewcode-back" href="../../generation.html#graph_tool.generation.predecessor_tree">[docs]</a><span class="k">def</span> <span class="nf">predecessor_tree</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">pred_map</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a graph from a list of predecessors given by the ``pred_map`` vertex property.&quot;&quot;&quot;</span>

    <span class="n">_check_prop_scalar</span><span class="p">(</span><span class="n">pred_map</span><span class="p">,</span> <span class="s">&quot;pred_map&quot;</span><span class="p">)</span>
    <span class="n">pg</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span>
    <span class="n">libgraph_tool_generation</span><span class="o">.</span><span class="n">predecessor_graph</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span>
                                               <span class="n">pg</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span>
                                               <span class="n">_prop</span><span class="p">(</span><span class="s">&quot;v&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">pred_map</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">pg</span>

</div>
<div class="viewcode-block" id="line_graph"><a class="viewcode-back" href="../../generation.html#graph_tool.generation.line_graph">[docs]</a><span class="k">def</span> <span class="nf">line_graph</span><span class="p">(</span><span class="n">g</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the line graph of the given graph `g`.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Given an undirected graph G, its line graph L(G) is a graph such that</span>

<span class="sd">        * each vertex of L(G) represents an edge of G; and</span>
<span class="sd">        * two vertices of L(G) are adjacent if and only if their corresponding</span>
<span class="sd">          edges share a common endpoint (&quot;are adjacent&quot;) in G.</span>

<span class="sd">    For a directed graph, the second criterion becomes:</span>

<span class="sd">       * Two vertices representing directed edges from u to v and from w to x in</span>
<span class="sd">         G are connected by an edge from uv to wx in the line digraph when v =</span>
<span class="sd">         w.</span>


<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    &gt;&gt;&gt; g = gt.collection.data[&quot;lesmis&quot;]</span>
<span class="sd">    &gt;&gt;&gt; lg, vmap = gt.line_graph(g)</span>
<span class="sd">    &gt;&gt;&gt; pos = gt.graph_draw(lg, output_size=(300, 300), output=&quot;lesmis-lg.pdf&quot;)</span>

<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       gt.graph_draw(lg, pos=pos, output_size=(300, 300), output=&quot;lesmis-lg.png&quot;)</span>



<span class="sd">    .. figure:: lesmis-lg.png</span>
<span class="sd">       :align: center</span>

<span class="sd">       Line graph of the coappearance of characters in Victor Hugo&#39;s novel &quot;Les</span>
<span class="sd">       Misérables&quot;.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [line-wiki] http://en.wikipedia.org/wiki/Line_graph</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lg</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">directed</span><span class="o">=</span><span class="n">g</span><span class="o">.</span><span class="n">is_directed</span><span class="p">())</span>

    <span class="n">vertex_map</span> <span class="o">=</span> <span class="n">lg</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="s">&quot;int64_t&quot;</span><span class="p">)</span>

    <span class="n">libgraph_tool_generation</span><span class="o">.</span><span class="n">line_graph</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span>
                                        <span class="n">lg</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span>
                                        <span class="n">_prop</span><span class="p">(</span><span class="s">&quot;v&quot;</span><span class="p">,</span> <span class="n">lg</span><span class="p">,</span> <span class="n">vertex_map</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">lg</span><span class="p">,</span> <span class="n">vertex_map</span>

</div>
<div class="viewcode-block" id="graph_union"><a class="viewcode-back" href="../../generation.html#graph_tool.generation.graph_union">[docs]</a><span class="k">def</span> <span class="nf">graph_union</span><span class="p">(</span><span class="n">g1</span><span class="p">,</span> <span class="n">g2</span><span class="p">,</span> <span class="n">intersection</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">props</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">include</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                <span class="n">internal_props</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the union of graphs ``g1`` and ``g2``, composed of all edges and</span>
<span class="sd">    vertices of ``g1`` and ``g2``, without overlap (if ``intersection ==</span>
<span class="sd">    None``).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    g1 : :class:`~graph_tool.Graph`</span>
<span class="sd">       First graph in the union.</span>
<span class="sd">    g2 : :class:`~graph_tool.Graph`</span>
<span class="sd">       Second graph in the union.</span>
<span class="sd">    intersection : :class:`~graph_tool.PropertyMap` (optional, default: ``None``)</span>
<span class="sd">       Vertex property map owned by `g2` which maps each of its vertices</span>
<span class="sd">       to vertex indexes belonging to `g1`. Negative values mean no mapping</span>
<span class="sd">       exists, and thus both vertices in `g1` and `g2` will be present in the</span>
<span class="sd">       union graph.</span>
<span class="sd">    props : list of tuples of :class:`~graph_tool.PropertyMap` (optional, default: ``None``)</span>
<span class="sd">       Each element in this list must be a tuple of two PropertyMap objects. The</span>
<span class="sd">       first element must be a property of `g1`, and the second of `g2`. If either</span>
<span class="sd">       value is ``None``, an empty map is created. The values of the property</span>
<span class="sd">       maps are propagated into the union graph, and returned.</span>
<span class="sd">    include : bool (optional, default: ``False``)</span>
<span class="sd">       If ``True``, graph `g2` is inserted into `g1` which is modified. If false, a</span>
<span class="sd">       new graph is created, and both graphs remain unmodified.</span>
<span class="sd">    internal_props : bool (optional, default: ``False``)</span>
<span class="sd">       If ``True``, all internal property maps are propagated, in addition</span>
<span class="sd">       to ``props``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ug : :class:`~graph_tool.Graph`</span>
<span class="sd">        The union graph</span>
<span class="sd">    props : list of :class:`~graph_tool.PropertyMap` objects</span>
<span class="sd">        List of propagated properties.  This is only returned if `props` is not</span>
<span class="sd">        empty.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       from numpy.random import random, seed</span>
<span class="sd">       from pylab import *</span>
<span class="sd">       seed(42)</span>
<span class="sd">       gt.seed_rng(42)</span>

<span class="sd">    &gt;&gt;&gt; g = gt.triangulation(random((300,2)))[0]</span>
<span class="sd">    &gt;&gt;&gt; ug = gt.graph_union(g, g)</span>
<span class="sd">    &gt;&gt;&gt; uug = gt.graph_union(g, ug)</span>
<span class="sd">    &gt;&gt;&gt; pos = gt.sfdp_layout(g)</span>
<span class="sd">    &gt;&gt;&gt; gt.graph_draw(g, pos=pos, output_size=(300,300), output=&quot;graph_original.pdf&quot;)</span>
<span class="sd">    &lt;...&gt;</span>

<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       gt.graph_draw(g, pos=pos, output_size=(300,300), output=&quot;graph_original.png&quot;)</span>

<span class="sd">    &gt;&gt;&gt; pos = gt.sfdp_layout(ug)</span>
<span class="sd">    &gt;&gt;&gt; gt.graph_draw(ug, pos=pos, output_size=(300,300), output=&quot;graph_union.pdf&quot;)</span>
<span class="sd">    &lt;...&gt;</span>

<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       gt.graph_draw(ug, pos=pos, output_size=(300,300), output=&quot;graph_union.png&quot;)</span>

<span class="sd">    &gt;&gt;&gt; pos = gt.sfdp_layout(uug)</span>
<span class="sd">    &gt;&gt;&gt; gt.graph_draw(uug, pos=pos, output_size=(300,300), output=&quot;graph_union2.pdf&quot;)</span>
<span class="sd">    &lt;...&gt;</span>

<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       gt.graph_draw(uug, pos=pos, output_size=(300,300), output=&quot;graph_union2.png&quot;)</span>


<span class="sd">    .. image:: graph_original.*</span>
<span class="sd">    .. image:: graph_union.*</span>
<span class="sd">    .. image:: graph_union2.*</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">pnames</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">if</span> <span class="n">props</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">props</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">internal_props</span><span class="p">:</span>
        <span class="n">pnames</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">name</span><span class="p">),</span> <span class="n">p1</span> <span class="ow">in</span> <span class="n">g1</span><span class="o">.</span><span class="n">properties</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="s">&#39;g&#39;</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">p2</span> <span class="o">=</span> <span class="n">g2</span><span class="o">.</span><span class="n">properties</span><span class="o">.</span><span class="n">get</span><span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="n">name</span><span class="p">),</span> <span class="bp">None</span><span class="p">)</span>
            <span class="n">props</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">))</span>
            <span class="n">pnames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">name</span><span class="p">),</span> <span class="n">p2</span> <span class="ow">in</span> <span class="n">g2</span><span class="o">.</span><span class="n">properties</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="s">&#39;g&#39;</span> <span class="ow">or</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="ow">in</span> <span class="n">g1</span><span class="o">.</span><span class="n">properties</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">props</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="bp">None</span><span class="p">,</span> <span class="n">p2</span><span class="p">))</span>
            <span class="n">pnames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="n">gprops</span> <span class="o">=</span> <span class="p">[[(</span><span class="n">name</span><span class="p">,</span> <span class="n">g1</span><span class="o">.</span><span class="n">properties</span><span class="p">[(</span><span class="s">&#39;g&#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">)])</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">g1</span><span class="o">.</span><span class="n">graph_properties</span><span class="o">.</span><span class="n">keys</span><span class="p">()],</span>
                  <span class="p">[(</span><span class="n">name</span><span class="p">,</span> <span class="n">g2</span><span class="o">.</span><span class="n">properties</span><span class="p">[(</span><span class="s">&#39;g&#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">)])</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">g2</span><span class="o">.</span><span class="n">graph_properties</span><span class="o">.</span><span class="n">keys</span><span class="p">()]]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">include</span><span class="p">:</span>
        <span class="n">g1</span> <span class="o">=</span> <span class="n">GraphView</span><span class="p">(</span><span class="n">g1</span><span class="p">,</span> <span class="n">skip_properties</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">p1s</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">props</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">p1</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">p1</span><span class="o">.</span><span class="n">key_type</span><span class="p">()</span> <span class="o">==</span> <span class="s">&quot;v&quot;</span><span class="p">:</span>
                <span class="n">g1</span><span class="o">.</span><span class="n">vp</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span> <span class="o">=</span> <span class="n">p1</span>
            <span class="k">elif</span> <span class="n">p1</span><span class="o">.</span><span class="n">key_type</span><span class="p">()</span> <span class="o">==</span> <span class="s">&quot;e&quot;</span><span class="p">:</span>
                <span class="n">g1</span><span class="o">.</span><span class="n">ep</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span> <span class="o">=</span> <span class="n">p1</span>

        <span class="n">g1</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">g1</span><span class="p">,</span> <span class="n">prune</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">props</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">p1</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="ow">in</span> <span class="n">g1</span><span class="o">.</span><span class="n">vp</span><span class="p">:</span>
                <span class="n">props</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">g1</span><span class="o">.</span><span class="n">vp</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)],</span> <span class="n">p2</span><span class="p">)</span>
                <span class="k">del</span> <span class="n">g1</span><span class="o">.</span><span class="n">vp</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">props</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">g1</span><span class="o">.</span><span class="n">ep</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)],</span> <span class="n">p2</span><span class="p">)</span>
                <span class="k">del</span> <span class="n">g1</span><span class="o">.</span><span class="n">ep</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">emask</span><span class="p">,</span> <span class="n">emask_flip</span> <span class="o">=</span> <span class="n">g1</span><span class="o">.</span><span class="n">get_edge_filter</span><span class="p">()</span>
        <span class="n">emask_flipped</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="n">emask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">emask_flip</span><span class="p">:</span>
            <span class="n">emask</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">emask</span><span class="o">.</span><span class="n">a</span><span class="p">)</span>
            <span class="n">emask_flipped</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="n">g1</span><span class="o">.</span><span class="n">set_edge_filter</span><span class="p">(</span><span class="n">emask</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>

        <span class="n">vmask</span><span class="p">,</span> <span class="n">vmask_flip</span> <span class="o">=</span> <span class="n">g1</span><span class="o">.</span><span class="n">get_vertex_filter</span><span class="p">()</span>
        <span class="n">vmask_flipped</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="n">vmask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">vmask_flip</span><span class="p">:</span>
            <span class="n">vmask</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">vmask</span><span class="o">.</span><span class="n">a</span>
            <span class="n">g1</span><span class="o">.</span><span class="n">set_vertex_filter</span><span class="p">(</span><span class="n">vmask</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
            <span class="n">vmask_flipped</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="k">if</span> <span class="n">intersection</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">intersection</span> <span class="o">=</span> <span class="n">g2</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="s">&quot;int64_t&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">intersection</span> <span class="o">=</span> <span class="n">intersection</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="s">&quot;int64_t&quot;</span><span class="p">)</span>

    <span class="n">u1</span> <span class="o">=</span> <span class="n">GraphView</span><span class="p">(</span><span class="n">g1</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">skip_properties</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">u2</span> <span class="o">=</span> <span class="n">GraphView</span><span class="p">(</span><span class="n">g2</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">skip_properties</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

    <span class="n">vmap</span><span class="p">,</span> <span class="n">emap</span> <span class="o">=</span> <span class="n">libgraph_tool_generation</span><span class="o">.</span><span class="n">graph_union</span><span class="p">(</span><span class="n">u1</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span>
                                                      <span class="n">u2</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span>
                                                      <span class="n">_prop</span><span class="p">(</span><span class="s">&quot;v&quot;</span><span class="p">,</span> <span class="n">g1</span><span class="p">,</span>
                                                            <span class="n">intersection</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">include</span><span class="p">:</span>
        <span class="n">emask</span><span class="p">,</span> <span class="n">emask_flip</span> <span class="o">=</span> <span class="n">g1</span><span class="o">.</span><span class="n">get_edge_filter</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">emask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">emask_flipped</span><span class="p">:</span>
            <span class="n">emask</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">emask</span><span class="o">.</span><span class="n">a</span><span class="p">)</span>
            <span class="n">g1</span><span class="o">.</span><span class="n">set_edge_filter</span><span class="p">(</span><span class="n">emask</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>

        <span class="n">vmask</span><span class="p">,</span> <span class="n">vmask_flip</span> <span class="o">=</span> <span class="n">g1</span><span class="o">.</span><span class="n">get_vertex_filter</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">vmask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">vmask_flipped</span><span class="p">:</span>
            <span class="n">vmask</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">vmask</span><span class="o">.</span><span class="n">a</span><span class="p">)</span>
            <span class="n">g1</span><span class="o">.</span><span class="n">set_vertex_filter</span><span class="p">(</span><span class="n">vmask</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>

    <span class="n">n_props</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span> <span class="ow">in</span> <span class="n">props</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">p1</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">p1</span> <span class="o">=</span> <span class="n">g1</span><span class="o">.</span><span class="n">new_property</span><span class="p">(</span><span class="n">p2</span><span class="o">.</span><span class="n">key_type</span><span class="p">(),</span> <span class="n">p2</span><span class="o">.</span><span class="n">value_type</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">p2</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">p2</span> <span class="o">=</span> <span class="n">g2</span><span class="o">.</span><span class="n">new_property</span><span class="p">(</span><span class="n">p1</span><span class="o">.</span><span class="n">key_type</span><span class="p">(),</span> <span class="n">p1</span><span class="o">.</span><span class="n">value_type</span><span class="p">())</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">include</span><span class="p">:</span>
            <span class="n">p1</span> <span class="o">=</span> <span class="n">g1</span><span class="o">.</span><span class="n">copy_property</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">p2</span><span class="o">.</span><span class="n">value_type</span><span class="p">()</span> <span class="o">!=</span> <span class="n">p1</span><span class="o">.</span><span class="n">value_type</span><span class="p">():</span>
            <span class="n">p2</span> <span class="o">=</span> <span class="n">g2</span><span class="o">.</span><span class="n">copy_property</span><span class="p">(</span><span class="n">p2</span><span class="p">,</span> <span class="n">value_type</span><span class="o">=</span><span class="n">p1</span><span class="o">.</span><span class="n">value_type</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">p1</span><span class="o">.</span><span class="n">key_type</span><span class="p">()</span> <span class="o">==</span> <span class="s">&#39;v&#39;</span><span class="p">:</span>
            <span class="n">libgraph_tool_generation</span><span class="o">.</span>\
                  <span class="n">vertex_property_union</span><span class="p">(</span><span class="n">u1</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span> <span class="n">u2</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span>
                                        <span class="n">vmap</span><span class="p">,</span> <span class="n">emap</span><span class="p">,</span>
                                        <span class="n">_prop</span><span class="p">(</span><span class="n">p1</span><span class="o">.</span><span class="n">key_type</span><span class="p">(),</span> <span class="n">g1</span><span class="p">,</span> <span class="n">p1</span><span class="p">),</span>
                                        <span class="n">_prop</span><span class="p">(</span><span class="n">p2</span><span class="o">.</span><span class="n">key_type</span><span class="p">(),</span> <span class="n">g2</span><span class="p">,</span> <span class="n">p2</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">libgraph_tool_generation</span><span class="o">.</span>\
                  <span class="n">edge_property_union</span><span class="p">(</span><span class="n">u1</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span> <span class="n">u2</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span>
                                      <span class="n">vmap</span><span class="p">,</span> <span class="n">emap</span><span class="p">,</span>
                                      <span class="n">_prop</span><span class="p">(</span><span class="n">p1</span><span class="o">.</span><span class="n">key_type</span><span class="p">(),</span> <span class="n">g1</span><span class="p">,</span> <span class="n">p1</span><span class="p">),</span>
                                      <span class="n">_prop</span><span class="p">(</span><span class="n">p2</span><span class="o">.</span><span class="n">key_type</span><span class="p">(),</span> <span class="n">g2</span><span class="p">,</span> <span class="n">p2</span><span class="p">))</span>
        <span class="n">n_props</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">pnames</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">pnames</span><span class="p">,</span> <span class="n">n_props</span><span class="p">):</span>
            <span class="n">g1</span><span class="o">.</span><span class="n">properties</span><span class="p">[(</span><span class="n">p</span><span class="o">.</span><span class="n">key_type</span><span class="p">(),</span> <span class="n">name</span><span class="p">)]</span> <span class="o">=</span> <span class="n">p</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">include</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">gprops</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">g1</span><span class="o">.</span><span class="n">graph_properties</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">gprops</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">g1</span><span class="o">.</span><span class="n">graph_properties</span><span class="p">:</span>
                <span class="n">g1</span><span class="o">.</span><span class="n">graph_properties</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">n_props</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">n_props</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">g1</span><span class="p">,</span> <span class="n">n_props</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">g1</span>

</div>
<span class="nd">@_limit_args</span><span class="p">({</span><span class="s">&quot;type&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s">&quot;simple&quot;</span><span class="p">,</span> <span class="s">&quot;delaunay&quot;</span><span class="p">]})</span>
<div class="viewcode-block" id="triangulation"><a class="viewcode-back" href="../../generation.html#graph_tool.generation.triangulation">[docs]</a><span class="k">def</span> <span class="nf">triangulation</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s">&quot;simple&quot;</span><span class="p">,</span> <span class="n">periodic</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Generate a 2D or 3D triangulation graph from a given point set.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    points : :class:`~numpy.ndarray`</span>
<span class="sd">        Point set for the triangulation. It may be either a N x d array, where N</span>
<span class="sd">        is the number of points, and d is the space dimension (either 2 or 3).</span>
<span class="sd">    type : string (optional, default: ``&#39;simple&#39;``)</span>
<span class="sd">        Type of triangulation. May be either &#39;simple&#39; or &#39;delaunay&#39;.</span>
<span class="sd">    periodic : bool (optional, default: ``False``)</span>
<span class="sd">        If ``True``, periodic boundary conditions will be used. This is</span>
<span class="sd">        parameter is valid only for type=&quot;delaunay&quot;, and is otherwise ignored.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    triangulation_graph : :class:`~graph_tool.Graph`</span>
<span class="sd">        The generated graph.</span>
<span class="sd">    pos : :class:`~graph_tool.PropertyMap`</span>
<span class="sd">        Vertex property map with the Cartesian coordinates.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    random_graph: random graph generation</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    A triangulation [cgal-triang]_ is a division of the convex hull of a point</span>
<span class="sd">    set into triangles, using only that set as triangle vertices.</span>

<span class="sd">    In simple triangulations (`type=&quot;simple&quot;`), the insertion of a point is done</span>
<span class="sd">    by locating a face that contains the point, and splitting this face into</span>
<span class="sd">    three new faces (the order of insertion is therefore important). If the</span>
<span class="sd">    point falls outside the convex hull, the triangulation is restored by</span>
<span class="sd">    flips. Apart from the location, insertion takes a time O(1). This bound is</span>
<span class="sd">    only an amortized bound for points located outside the convex hull.</span>

<span class="sd">    Delaunay triangulations (`type=&quot;delaunay&quot;`) have the specific empty sphere</span>
<span class="sd">    property, that is, the circumscribing sphere of each cell of such a</span>
<span class="sd">    triangulation does not contain any other vertex of the triangulation in its</span>
<span class="sd">    interior. These triangulations are uniquely defined except in degenerate</span>
<span class="sd">    cases where five points are co-spherical. Note however that the CGAL</span>
<span class="sd">    implementation computes a unique triangulation even in these cases.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       from numpy.random import random, seed</span>
<span class="sd">       from pylab import *</span>
<span class="sd">       seed(42)</span>
<span class="sd">       gt.seed_rng(42)</span>
<span class="sd">    &gt;&gt;&gt; points = random((500, 2)) * 4</span>
<span class="sd">    &gt;&gt;&gt; g, pos = gt.triangulation(points)</span>
<span class="sd">    &gt;&gt;&gt; weight = g.new_edge_property(&quot;double&quot;) # Edge weights corresponding to</span>
<span class="sd">    ...                                        # Euclidean distances</span>
<span class="sd">    &gt;&gt;&gt; for e in g.edges():</span>
<span class="sd">    ...    weight[e] = sqrt(sum((array(pos[e.source()]) -</span>
<span class="sd">    ...                          array(pos[e.target()]))**2))</span>
<span class="sd">    &gt;&gt;&gt; b = gt.betweenness(g, weight=weight)</span>
<span class="sd">    &gt;&gt;&gt; b[1].a *= 100</span>
<span class="sd">    &gt;&gt;&gt; gt.graph_draw(g, pos=pos, output_size=(300,300), vertex_fill_color=b[0],</span>
<span class="sd">    ...               edge_pen_width=b[1], output=&quot;triang.pdf&quot;)</span>
<span class="sd">    &lt;...&gt;</span>

<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       gt.graph_draw(g, pos=pos, output_size=(300,300), vertex_fill_color=b[0],</span>
<span class="sd">                     edge_pen_width=b[1], output=&quot;triang.png&quot;)</span>

<span class="sd">    &gt;&gt;&gt; g, pos = gt.triangulation(points, type=&quot;delaunay&quot;)</span>
<span class="sd">    &gt;&gt;&gt; weight = g.new_edge_property(&quot;double&quot;)</span>
<span class="sd">    &gt;&gt;&gt; for e in g.edges():</span>
<span class="sd">    ...    weight[e] = sqrt(sum((array(pos[e.source()]) -</span>
<span class="sd">    ...                          array(pos[e.target()]))**2))</span>
<span class="sd">    &gt;&gt;&gt; b = gt.betweenness(g, weight=weight)</span>
<span class="sd">    &gt;&gt;&gt; b[1].a *= 120</span>
<span class="sd">    &gt;&gt;&gt; gt.graph_draw(g, pos=pos, output_size=(300,300), vertex_fill_color=b[0],</span>
<span class="sd">    ...               edge_pen_width=b[1], output=&quot;triang-delaunay.pdf&quot;)</span>
<span class="sd">    &lt;...&gt;</span>

<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       gt.graph_draw(g, pos=pos, output_size=(300,300), vertex_fill_color=b[0],</span>
<span class="sd">                     edge_pen_width=b[1], output=&quot;triang-delaunay.png&quot;)</span>


<span class="sd">    2D triangulation of random points:</span>

<span class="sd">    .. image:: triang.*</span>
<span class="sd">    .. image:: triang-delaunay.*</span>

<span class="sd">    *Left:* Simple triangulation. *Right:* Delaunay triangulation. The vertex</span>
<span class="sd">    colors and the edge thickness correspond to the weighted betweenness</span>
<span class="sd">    centrality.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [cgal-triang] http://www.cgal.org/Manual/last/doc_html/cgal_manual/Triangulation_3/Chapter_main.html</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;points array must have shape N x d, with d either 2 or 3.&quot;</span><span class="p">)</span>
    <span class="c"># copy points to ensure continuity and correct data type</span>
    <span class="n">points</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;float64&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">npoints</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">3</span><span class="p">))</span>
        <span class="n">npoints</span><span class="p">[:,:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">points</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">npoints</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">directed</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="s">&quot;vector&lt;double&gt;&quot;</span><span class="p">)</span>
    <span class="n">libgraph_tool_generation</span><span class="o">.</span><span class="n">triangulation</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span>
                                           <span class="n">_prop</span><span class="p">(</span><span class="s">&quot;v&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">pos</span><span class="p">),</span> <span class="nb">type</span><span class="p">,</span> <span class="n">periodic</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">g</span><span class="p">,</span> <span class="n">pos</span>

</div>
<div class="viewcode-block" id="lattice"><a class="viewcode-back" href="../../generation.html#graph_tool.generation.lattice">[docs]</a><span class="k">def</span> <span class="nf">lattice</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">periodic</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Generate a N-dimensional square lattice.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    shape : list or :class:`~numpy.ndarray`</span>
<span class="sd">        List of sizes in each dimension.</span>
<span class="sd">    periodic : bool (optional, default: ``False``)</span>
<span class="sd">        If ``True``, periodic boundary conditions will be used.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    lattice_graph : :class:`~graph_tool.Graph`</span>
<span class="sd">        The generated graph.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    triangulation: 2D or 3D triangulation</span>
<span class="sd">    random_graph: random graph generation</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       gt.seed_rng(42)</span>

<span class="sd">    &gt;&gt;&gt; g = gt.lattice([10,10])</span>
<span class="sd">    &gt;&gt;&gt; pos = gt.sfdp_layout(g, cooling_step=0.95, epsilon=1e-2)</span>
<span class="sd">    &gt;&gt;&gt; gt.graph_draw(g, pos=pos, output_size=(300,300), output=&quot;lattice.pdf&quot;)</span>
<span class="sd">    &lt;...&gt;</span>

<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       gt.graph_draw(g, pos=pos, output_size=(300,300), output=&quot;lattice.png&quot;)</span>

<span class="sd">    &gt;&gt;&gt; g = gt.lattice([10,20], periodic=True)</span>
<span class="sd">    &gt;&gt;&gt; pos = gt.sfdp_layout(g, cooling_step=0.95, epsilon=1e-2)</span>
<span class="sd">    &gt;&gt;&gt; gt.graph_draw(g, pos=pos, output_size=(300,300), output=&quot;lattice_periodic.pdf&quot;)</span>
<span class="sd">    &lt;...&gt;</span>

<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       gt.graph_draw(g, pos=pos, output_size=(300,300), output=&quot;lattice_periodic.png&quot;)</span>

<span class="sd">    &gt;&gt;&gt; g = gt.lattice([10,10,10])</span>
<span class="sd">    &gt;&gt;&gt; pos = gt.sfdp_layout(g, cooling_step=0.95, epsilon=1e-2)</span>
<span class="sd">    &gt;&gt;&gt; gt.graph_draw(g, pos=pos, output_size=(300,300), output=&quot;lattice_3d.pdf&quot;)</span>
<span class="sd">    &lt;...&gt;</span>

<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       gt.graph_draw(g, pos=pos, output_size=(300,300), output=&quot;lattice_3d.png&quot;)</span>


<span class="sd">    .. image:: lattice.*</span>
<span class="sd">    .. image:: lattice_periodic.*</span>
<span class="sd">    .. image:: lattice_3d.*</span>

<span class="sd">    *Left:* 10x10 2D lattice. *Middle:* 10x20 2D periodic lattice (torus).</span>
<span class="sd">    *Right:* 10x10x10 3D lattice.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [lattice] http://en.wikipedia.org/wiki/Square_lattice</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">directed</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="n">libgraph_tool_generation</span><span class="o">.</span><span class="n">lattice</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">periodic</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">g</span>
</div>
<div class="viewcode-block" id="complete_graph"><a class="viewcode-back" href="../../generation.html#graph_tool.generation.complete_graph">[docs]</a><span class="k">def</span> <span class="nf">complete_graph</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">self_loops</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Generate complete graph.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    N : ``int``</span>
<span class="sd">        Number of vertices.</span>
<span class="sd">    self_loops : bool (optional, default: ``False``)</span>
<span class="sd">        If ``True``, self-loops are included.</span>
<span class="sd">    directed : bool (optional, default: ``False``)</span>
<span class="sd">        If ``True``, a directed graph is generated.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    complete_graph : :class:`~graph_tool.Graph`</span>
<span class="sd">        A complete graph.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    &gt;&gt;&gt; g = gt.complete_graph(30)</span>
<span class="sd">    &gt;&gt;&gt; pos = gt.sfdp_layout(g, cooling_step=0.95, epsilon=1e-2)</span>
<span class="sd">    &gt;&gt;&gt; gt.graph_draw(g, pos=pos, output_size=(300,300), output=&quot;complete.pdf&quot;)</span>
<span class="sd">    &lt;...&gt;</span>

<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       gt.graph_draw(g, pos=pos, output_size=(300,300), output=&quot;complete.png&quot;)</span>


<span class="sd">    .. figure:: complete.*</span>

<span class="sd">       A complete graph with :math:`N=30` vertices.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [complete] http://en.wikipedia.org/wiki/Complete_graph</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">directed</span><span class="o">=</span><span class="n">directed</span><span class="p">)</span>
    <span class="n">libgraph_tool_generation</span><span class="o">.</span><span class="n">complete</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">directed</span><span class="p">,</span> <span class="n">self_loops</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">g</span>
</div>
<div class="viewcode-block" id="circular_graph"><a class="viewcode-back" href="../../generation.html#graph_tool.generation.circular_graph">[docs]</a><span class="k">def</span> <span class="nf">circular_graph</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">self_loops</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Generate a circular graph.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    N : ``int``</span>
<span class="sd">        Number of vertices.</span>
<span class="sd">    k : ``int`` (optional, default: ``True``)</span>
<span class="sd">        Number of nearest neighbours to be connected.</span>
<span class="sd">    self_loops : bool (optional, default: ``False``)</span>
<span class="sd">        If ``True``, self-loops are included.</span>
<span class="sd">    directed : bool (optional, default: ``False``)</span>
<span class="sd">        If ``True``, a directed graph is generated.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    circular_graph : :class:`~graph_tool.Graph`</span>
<span class="sd">        A circular graph.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    &gt;&gt;&gt; g = gt.circular_graph(30, 2)</span>
<span class="sd">    &gt;&gt;&gt; pos = gt.sfdp_layout(g, cooling_step=0.95)</span>
<span class="sd">    &gt;&gt;&gt; gt.graph_draw(g, pos=pos, output_size=(300,300), output=&quot;circular.pdf&quot;)</span>
<span class="sd">    &lt;...&gt;</span>

<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       gt.graph_draw(g, pos=pos, output_size=(300,300), output=&quot;circular.png&quot;)</span>

<span class="sd">    .. figure:: circular.*</span>

<span class="sd">       A circular graph with :math:`N=30` vertices, and :math:`k=2`.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">directed</span><span class="o">=</span><span class="n">directed</span><span class="p">)</span>
    <span class="n">libgraph_tool_generation</span><span class="o">.</span><span class="n">circular</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">directed</span><span class="p">,</span> <span class="n">self_loops</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">g</span>

</div>
<div class="viewcode-block" id="geometric_graph"><a class="viewcode-back" href="../../generation.html#graph_tool.generation.geometric_graph">[docs]</a><span class="k">def</span> <span class="nf">geometric_graph</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">ranges</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Generate a geometric network form a set of N-dimensional points.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    points : list or :class:`~numpy.ndarray`</span>
<span class="sd">        List of points. This must be a two-dimensional array, where the rows are</span>
<span class="sd">        coordinates in a N-dimensional space.</span>
<span class="sd">    radius : float</span>
<span class="sd">        Pairs of points with an euclidean distance lower than this parameters</span>
<span class="sd">        will be connected.</span>
<span class="sd">    ranges : list or :class:`~numpy.ndarray` (optional, default: ``None``)</span>
<span class="sd">        If provided, periodic boundary conditions will be assumed, and the</span>
<span class="sd">        values of this parameter it will be used as the ranges in all</span>
<span class="sd">        dimensions. It must be a two-dimensional array, where each row will</span>
<span class="sd">        cointain the lower and upper bound of each dimension.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    geometric_graph : :class:`~graph_tool.Graph`</span>
<span class="sd">        The generated graph.</span>
<span class="sd">    pos : :class:`~graph_tool.PropertyMap`</span>
<span class="sd">        A vertex property map with the position of each vertex.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    A geometric graph [geometric-graph]_ is generated by connecting points</span>
<span class="sd">    embedded in a N-dimensional euclidean space which are at a distance equal to</span>
<span class="sd">    or smaller than a given radius.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    triangulation: 2D or 3D triangulation</span>
<span class="sd">    random_graph: random graph generation</span>
<span class="sd">    lattice : N-dimensional square lattice</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       from numpy.random import random, seed</span>
<span class="sd">       from pylab import *</span>
<span class="sd">       seed(42)</span>
<span class="sd">       gt.seed_rng(42)</span>

<span class="sd">    &gt;&gt;&gt; points = random((500, 2)) * 4</span>
<span class="sd">    &gt;&gt;&gt; g, pos = gt.geometric_graph(points, 0.3)</span>
<span class="sd">    &gt;&gt;&gt; gt.graph_draw(g, pos=pos, output_size=(300,300), output=&quot;geometric.pdf&quot;)</span>
<span class="sd">    &lt;...&gt;</span>

<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       gt.graph_draw(g, pos=pos, output_size=(300,300), output=&quot;geometric.png&quot;)</span>

<span class="sd">    &gt;&gt;&gt; g, pos = gt.geometric_graph(points, 0.3, [(0,4), (0,4)])</span>
<span class="sd">    &gt;&gt;&gt; pos = gt.graph_draw(g, output_size=(300,300), output=&quot;geometric_periodic.pdf&quot;)</span>

<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       gt.graph_draw(g, pos=pos, output_size=(300,300), output=&quot;geometric_periodic.png&quot;)</span>


<span class="sd">    .. image:: geometric.*</span>
<span class="sd">    .. image:: geometric_periodic.*</span>

<span class="sd">    *Left:* Geometric network with random points. *Right:* Same network, but</span>
<span class="sd">     with periodic boundary conditions.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [geometric-graph] Jesper Dall and Michael Christensen, &quot;Random geometric</span>
<span class="sd">       graphs&quot;, Phys. Rev. E 66, 016121 (2002), :doi:`10.1103/PhysRevE.66.016121`</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">directed</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="s">&quot;vector&lt;double&gt;&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">points</span><span class="p">)</span> <span class="o">!=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;points list must be a two-dimensional array!&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ranges</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">periodic</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">ranges</span><span class="p">)</span> <span class="o">!=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
            <span class="n">ranges</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ranges</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&quot;float&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ranges</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">ranges</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&quot;float&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">periodic</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">ranges</span> <span class="o">=</span> <span class="p">()</span>

    <span class="n">libgraph_tool_generation</span><span class="o">.</span><span class="n">geometric</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">radius</span><span class="p">),</span>
                                       <span class="n">ranges</span><span class="p">,</span> <span class="n">periodic</span><span class="p">,</span>
                                       <span class="n">_prop</span><span class="p">(</span><span class="s">&quot;v&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">pos</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">g</span><span class="p">,</span> <span class="n">pos</span>

</div>
<div class="viewcode-block" id="price_network"><a class="viewcode-back" href="../../generation.html#graph_tool.generation.price_network">[docs]</a><span class="k">def</span> <span class="nf">price_network</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">seed_graph</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;A generalized version of Price&#39;s -- or Barabási-Albert if undirected -- preferential attachment network model.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    N : int</span>
<span class="sd">        Size of the network.</span>
<span class="sd">    m : int (optional, default: ``1``)</span>
<span class="sd">        Out-degree of newly added vertices.</span>
<span class="sd">    c : float (optional, default: ``1 if directed == True else 0``)</span>
<span class="sd">        Constant factor added to the probability of a vertex receiving an edge</span>
<span class="sd">        (see notes below).</span>
<span class="sd">    gamma : float (optional, default: ``1``)</span>
<span class="sd">        Preferential attachment power (see notes below).</span>
<span class="sd">    directed : bool (optional, default: ``True``)</span>
<span class="sd">        If ``True``, a Price network is generated. If ``False``, a</span>
<span class="sd">        Barabási-Albert network is generated.</span>
<span class="sd">    seed_graph : :class:`~graph_tool.Graph` (optional, default: ``None``)</span>
<span class="sd">        If provided, this graph will be used as the starting point of the</span>
<span class="sd">        algorithm.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    price_graph : :class:`~graph_tool.Graph`</span>
<span class="sd">        The generated graph.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    The (generalized) [price]_ network is either a directed or undirected graph</span>
<span class="sd">    (the latter is called a Barabási-Albert network), generated dynamically by</span>
<span class="sd">    at each step adding a new vertex, and connecting it to :math:`m` other</span>
<span class="sd">    vertices, chosen with probability :math:`\pi` defined as:</span>

<span class="sd">    .. math::</span>

<span class="sd">        \pi \propto k^\gamma + c</span>

<span class="sd">    where :math:`k` is the in-degree of the vertex (or simply the degree in the</span>
<span class="sd">    undirected case). If :math:`\gamma=1`, the tail of resulting in-degree</span>
<span class="sd">    distribution of the directed case is given by</span>

<span class="sd">    .. math::</span>

<span class="sd">        P_{k_\text{in}} \sim k_\text{in}^{-(2 + c/m)},</span>

<span class="sd">    or for the undirected case</span>

<span class="sd">    .. math::</span>

<span class="sd">        P_{k} \sim k^{-(3 + c/m)}.</span>

<span class="sd">    However, if :math:`\gamma \ne 1`, the in-degree distribution is not</span>
<span class="sd">    scale-free (see [dorogovtsev-evolution]_ for details).</span>

<span class="sd">    Note that if `seed_graph` is not given, the algorithm will *always* start</span>
<span class="sd">    with one node if :math:`c &gt; 0`, or with two nodes with a link between them</span>
<span class="sd">    otherwise. If :math:`m &gt; 1`, the degree of the newly added vertices will be</span>
<span class="sd">    vary dynamically as :math:`m&#39;(t) = \min(m, N(t))`, where :math:`N(t)` is the</span>
<span class="sd">    number of vertices added so far. If this behaviour is undesired, a proper</span>
<span class="sd">    seed graph with :math:`N \ge m` vertices must be provided.</span>

<span class="sd">    This algorithm runs in :math:`O(N\log N)` time.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    triangulation: 2D or 3D triangulation</span>
<span class="sd">    random_graph: random graph generation</span>
<span class="sd">    lattice : N-dimensional square lattice</span>
<span class="sd">    geometric_graph : N-dimensional geometric network</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       gt.seed_rng(42)</span>

<span class="sd">    &gt;&gt;&gt; g = gt.price_network(20000)</span>
<span class="sd">    &gt;&gt;&gt; gt.graph_draw(g, pos=gt.sfdp_layout(g, cooling_step=0.99),</span>
<span class="sd">    ...               vertex_fill_color=g.vertex_index, vertex_size=2,</span>
<span class="sd">    ...               edge_pen_width=1, output=&quot;price-network.png&quot;)</span>
<span class="sd">    &lt;...&gt;</span>
<span class="sd">    &gt;&gt;&gt; g = gt.price_network(20000, c=0.1)</span>
<span class="sd">    &gt;&gt;&gt; gt.graph_draw(g, pos=gt.sfdp_layout(g, cooling_step=0.99),</span>
<span class="sd">    ...               vertex_fill_color=g.vertex_index, vertex_size=2,</span>
<span class="sd">    ...               edge_pen_width=1, output=&quot;price-network-broader.png&quot;)</span>
<span class="sd">    &lt;...&gt;</span>

<span class="sd">    .. figure:: price-network.png</span>
<span class="sd">        :align: center</span>

<span class="sd">        Price network with :math:`N=2\times 10^4` nodes and :math:`c=1`.  The colors</span>
<span class="sd">        represent the order in which vertices were added.</span>

<span class="sd">    .. figure:: price-network-broader.png</span>
<span class="sd">        :align: center</span>

<span class="sd">        Price network with :math:`N=2\times 10^4` nodes and :math:`c=0.1`.  The colors</span>
<span class="sd">        represent the order in which vertices were added.</span>


<span class="sd">    References</span>
<span class="sd">    ----------</span>

<span class="sd">    .. [yule] Yule, G. U. &quot;A Mathematical Theory of Evolution, based on the</span>
<span class="sd">       Conclusions of Dr. J. C. Willis, F.R.S.&quot;. Philosophical Transactions of</span>
<span class="sd">       the Royal Society of London, Ser. B 213: 21-87, 1925,</span>
<span class="sd">       :doi:`10.1098/rstb.1925.0002`</span>
<span class="sd">    .. [price] Derek De Solla Price, &quot;A general theory of bibliometric and other</span>
<span class="sd">       cumulative advantage processes&quot;, Journal of the American Society for</span>
<span class="sd">       Information Science, Volume 27, Issue 5, pages 292-306, September 1976,</span>
<span class="sd">       :doi:`10.1002/asi.4630270505`</span>
<span class="sd">    .. [barabasi-albert] Barabási, A.-L., and Albert, R., &quot;Emergence of</span>
<span class="sd">       scaling in random networks&quot;, Science, 286, 509, 1999,</span>
<span class="sd">       :doi:`10.1126/science.286.5439.509`</span>
<span class="sd">    .. [dorogovtsev-evolution] S. N. Dorogovtsev and J. F. F. Mendes, &quot;Evolution</span>
<span class="sd">       of networks&quot;, Advances in Physics, 2002, Vol. 51, No. 4, 1079-1187,</span>
<span class="sd">       :doi:`10.1080/00018730110112519`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">c</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">directed</span> <span class="k">else</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="n">seed_graph</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">directed</span><span class="o">=</span><span class="n">directed</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">c</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">g</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">g</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">g</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
        <span class="n">N</span> <span class="o">-=</span> <span class="n">g</span><span class="o">.</span><span class="n">num_vertices</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">seed_graph</span>
    <span class="n">libgraph_tool_generation</span><span class="o">.</span><span class="n">price</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">_get_rng</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">g</span>
</div>
<span class="k">class</span> <span class="nc">Sampler</span><span class="p">(</span><span class="n">libgraph_tool_generation</span><span class="o">.</span><span class="n">Sampler</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">probs</span><span class="p">):</span>
        <span class="n">libgraph_tool_generation</span><span class="o">.</span><span class="n">Sampler</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">probs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">libgraph_tool_generation</span><span class="o">.</span><span class="n">Sampler</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_get_rng</span><span class="p">())</span>

<span class="k">class</span> <span class="nc">DynamicSampler</span><span class="p">(</span><span class="n">libgraph_tool_generation</span><span class="o">.</span><span class="n">DynamicSampler</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">probs</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">values</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">probs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">libgraph_tool_generation</span><span class="o">.</span><span class="n">DynamicSampler</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">probs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">libgraph_tool_generation</span><span class="o">.</span><span class="n">DynamicSampler</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_get_rng</span><span class="p">())</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">

<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
<!-- <a href="graph-tool.pdf">(Download PDF version)</a> -->

<p/>
Latest <a href="/doc/dev/">development version docs</a> are also available.

        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
    <li><img src="../../_static/graph-icon.png" alt="logo" style="margin-right: 5px; margin-bottom:-2px;" /><a href="/">Project Homepage</a> &raquo;</li>
    
        <li class="nav-item nav-item-0"><a href="../../index.html">graph-tool 2.2.44 documentation</a> &raquo;</li>

          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &raquo;</li>
          <li class="nav-item nav-item-2"><a href="../graph_tool.html" >graph_tool</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2015, Tiago de Paula Peixoto &lt;tiago@skewed.de&gt;.
      Last updated on Jul 02, 2015.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
  </body>
</html>