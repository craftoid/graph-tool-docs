<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>graph_tool.topology &mdash; graph-tool 2.2.44 documentation</title>
    
    <link rel="stylesheet" href="../../_static/gt_style.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '2.2.44',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/MathJax/MathJax.js?config=default"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within graph-tool 2.2.44 documentation"
          href="../../_static/opensearch.xml"/>
    <link rel="shortcut icon" href="../../_static/graph-icon.ico"/>
    <link rel="top" title="graph-tool 2.2.44 documentation" href="../../index.html" />
    <link rel="up" title="graph_tool" href="../graph_tool.html" />
    <script type="text/javascript">
      var _gaq = _gaq || [];
      var pluginUrl =
        '//www.google-analytics.com/plugins/ga/inpage_linkid.js';
      _gaq.push(['_require', 'inpage_linkid', pluginUrl]);
      _gaq.push(['_setAccount', 'UA-248813-2']);
      _gaq.push(['_setDomainName', '.skewed.de']);
      _gaq.push(['_trackPageview']);
      (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
     

  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
    <li><img src="../../_static/graph-icon.png" alt="logo" style="margin-right: 5px; margin-bottom:-2px;" /><a href="/">Project Homepage</a> &raquo;</li>
    
        <li class="nav-item nav-item-0"><a href="../../index.html">graph-tool 2.2.44 documentation</a> &raquo;</li>

          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &raquo;</li>
          <li class="nav-item nav-item-2"><a href="../graph_tool.html" accesskey="U">graph_tool</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for graph_tool.topology</h1><div class="highlight"><pre>
<span class="c">#! /usr/bin/env python</span>
<span class="c"># -*- coding: utf-8 -*-</span>
<span class="c">#</span>
<span class="c"># graph_tool -- a general graph manipulation python module</span>
<span class="c">#</span>
<span class="c"># Copyright (C) 2006-2015 Tiago de Paula Peixoto &lt;tiago@skewed.de&gt;</span>
<span class="c">#</span>
<span class="c"># This program is free software: you can redistribute it and/or modify</span>
<span class="c"># it under the terms of the GNU General Public License as published by</span>
<span class="c"># the Free Software Foundation, either version 3 of the License, or</span>
<span class="c"># (at your option) any later version.</span>
<span class="c">#</span>
<span class="c"># This program is distributed in the hope that it will be useful,</span>
<span class="c"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c"># GNU General Public License for more details.</span>
<span class="c">#</span>
<span class="c"># You should have received a copy of the GNU General Public License</span>
<span class="c"># along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">``graph_tool.topology`` - Assessing graph topology</span>
<span class="sd">--------------------------------------------------</span>

<span class="sd">Summary</span>
<span class="sd">+++++++</span>

<span class="sd">.. autosummary::</span>
<span class="sd">   :nosignatures:</span>

<span class="sd">   shortest_distance</span>
<span class="sd">   shortest_path</span>
<span class="sd">   pseudo_diameter</span>
<span class="sd">   similarity</span>
<span class="sd">   isomorphism</span>
<span class="sd">   subgraph_isomorphism</span>
<span class="sd">   mark_subgraph</span>
<span class="sd">   max_cardinality_matching</span>
<span class="sd">   max_independent_vertex_set</span>
<span class="sd">   min_spanning_tree</span>
<span class="sd">   random_spanning_tree</span>
<span class="sd">   dominator_tree</span>
<span class="sd">   topological_sort</span>
<span class="sd">   transitive_closure</span>
<span class="sd">   tsp_tour</span>
<span class="sd">   sequential_vertex_coloring</span>
<span class="sd">   label_components</span>
<span class="sd">   label_biconnected_components</span>
<span class="sd">   label_largest_component</span>
<span class="sd">   label_out_component</span>
<span class="sd">   kcore_decomposition</span>
<span class="sd">   is_bipartite</span>
<span class="sd">   is_DAG</span>
<span class="sd">   is_planar</span>
<span class="sd">   make_maximal_planar</span>
<span class="sd">   edge_reciprocity</span>

<span class="sd">Contents</span>
<span class="sd">++++++++</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span><span class="p">,</span> <span class="n">absolute_import</span><span class="p">,</span> <span class="n">print_function</span>

<span class="kn">from</span> <span class="nn">..</span> <span class="nn">dl_import</span> <span class="kn">import</span> <span class="n">dl_import</span>
<span class="n">dl_import</span><span class="p">(</span><span class="s">&quot;from . import libgraph_tool_topology&quot;</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">_prop</span><span class="p">,</span> <span class="n">Vector_int32_t</span><span class="p">,</span> <span class="n">_check_prop_writable</span><span class="p">,</span> \
     <span class="n">_check_prop_scalar</span><span class="p">,</span> <span class="n">_check_prop_vector</span><span class="p">,</span> <span class="n">Graph</span><span class="p">,</span> <span class="n">PropertyMap</span><span class="p">,</span> <span class="n">GraphView</span><span class="p">,</span>\
     <span class="n">libcore</span><span class="p">,</span> <span class="n">_get_rng</span><span class="p">,</span> <span class="n">_degree</span><span class="p">,</span> <span class="n">perfect_prop_hash</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="nn">stats</span> <span class="kn">import</span> <span class="n">label_self_loops</span>
<span class="kn">import</span> <span class="nn">random</span><span class="o">,</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">numpy</span><span class="o">,</span> <span class="nn">collections</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;isomorphism&quot;</span><span class="p">,</span> <span class="s">&quot;subgraph_isomorphism&quot;</span><span class="p">,</span> <span class="s">&quot;mark_subgraph&quot;</span><span class="p">,</span>
           <span class="s">&quot;max_cardinality_matching&quot;</span><span class="p">,</span> <span class="s">&quot;max_independent_vertex_set&quot;</span><span class="p">,</span>
           <span class="s">&quot;min_spanning_tree&quot;</span><span class="p">,</span> <span class="s">&quot;random_spanning_tree&quot;</span><span class="p">,</span> <span class="s">&quot;dominator_tree&quot;</span><span class="p">,</span>
           <span class="s">&quot;topological_sort&quot;</span><span class="p">,</span> <span class="s">&quot;transitive_closure&quot;</span><span class="p">,</span> <span class="s">&quot;tsp_tour&quot;</span><span class="p">,</span>
           <span class="s">&quot;sequential_vertex_coloring&quot;</span><span class="p">,</span> <span class="s">&quot;label_components&quot;</span><span class="p">,</span>
           <span class="s">&quot;label_largest_component&quot;</span><span class="p">,</span> <span class="s">&quot;label_biconnected_components&quot;</span><span class="p">,</span>
           <span class="s">&quot;label_out_component&quot;</span><span class="p">,</span> <span class="s">&quot;kcore_decomposition&quot;</span><span class="p">,</span> <span class="s">&quot;shortest_distance&quot;</span><span class="p">,</span>
           <span class="s">&quot;shortest_path&quot;</span><span class="p">,</span> <span class="s">&quot;pseudo_diameter&quot;</span><span class="p">,</span> <span class="s">&quot;is_bipartite&quot;</span><span class="p">,</span> <span class="s">&quot;is_DAG&quot;</span><span class="p">,</span>
           <span class="s">&quot;is_planar&quot;</span><span class="p">,</span> <span class="s">&quot;make_maximal_planar&quot;</span><span class="p">,</span> <span class="s">&quot;similarity&quot;</span><span class="p">,</span> <span class="s">&quot;edge_reciprocity&quot;</span><span class="p">]</span>


<div class="viewcode-block" id="similarity"><a class="viewcode-back" href="../../topology.html#graph_tool.topology.similarity">[docs]</a><span class="k">def</span> <span class="nf">similarity</span><span class="p">(</span><span class="n">g1</span><span class="p">,</span> <span class="n">g2</span><span class="p">,</span> <span class="n">label1</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">label2</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;Return the adjacency similarity between the two graphs.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    g1 : :class:`~graph_tool.Graph`</span>
<span class="sd">        First graph to be compared.</span>
<span class="sd">    g2 : :class:`~graph_tool.Graph`</span>
<span class="sd">        Second graph to be compared.</span>
<span class="sd">    label1 : :class:`~graph_tool.PropertyMap` (optional, default: ``None``)</span>
<span class="sd">        Vertex labels for the first graph to be used in comparison. If not</span>
<span class="sd">        supplied, the vertex indexes are used.</span>
<span class="sd">    label2 : :class:`~graph_tool.PropertyMap` (optional, default: ``None``)</span>
<span class="sd">        Vertex labels for the second graph to be used in comparison. If not</span>
<span class="sd">        supplied, the vertex indexes are used.</span>
<span class="sd">    norm : bool (optional, default: ``True``)</span>
<span class="sd">        If ``True``, the returned value is normalized by the total number of</span>
<span class="sd">        edges.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    similarity : float</span>
<span class="sd">        Adjacency similarity value.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The adjacency similarity is the sum of equal entries in the adjacency</span>
<span class="sd">    matrix, given a vertex ordering determined by the vertex labels. In other</span>
<span class="sd">    words it counts the number of edges which have the same source and target</span>
<span class="sd">    labels in both graphs.</span>

<span class="sd">    The algorithm runs with complexity :math:`O(E_1 + V_1 + E_2 + V_2)`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       import numpy.random</span>
<span class="sd">       numpy.random.seed(42)</span>
<span class="sd">       gt.seed_rng(42)</span>

<span class="sd">    &gt;&gt;&gt; g = gt.random_graph(100, lambda: (3,3))</span>
<span class="sd">    &gt;&gt;&gt; u = g.copy()</span>
<span class="sd">    &gt;&gt;&gt; gt.similarity(u, g)</span>
<span class="sd">    1.0</span>
<span class="sd">    &gt;&gt;&gt; gt.random_rewire(u)</span>
<span class="sd">    24</span>
<span class="sd">    &gt;&gt;&gt; gt.similarity(u, g)</span>
<span class="sd">    0.04666666666666667</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">label1</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">label1</span> <span class="o">=</span> <span class="n">g1</span><span class="o">.</span><span class="n">vertex_index</span>
    <span class="k">if</span> <span class="n">label2</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">label2</span> <span class="o">=</span> <span class="n">g2</span><span class="o">.</span><span class="n">vertex_index</span>
    <span class="k">if</span> <span class="n">label1</span><span class="o">.</span><span class="n">value_type</span><span class="p">()</span> <span class="o">!=</span> <span class="n">label2</span><span class="o">.</span><span class="n">value_type</span><span class="p">():</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">label2</span> <span class="o">=</span> <span class="n">label2</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">label1</span><span class="o">.</span><span class="n">value_type</span><span class="p">())</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="n">label1</span> <span class="o">=</span> <span class="n">label1</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">label2</span><span class="o">.</span><span class="n">value_type</span><span class="p">())</span>
    <span class="k">if</span> <span class="n">label1</span><span class="o">.</span><span class="n">is_writable</span><span class="p">()</span> <span class="ow">or</span> <span class="n">label2</span><span class="o">.</span><span class="n">is_writable</span><span class="p">():</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">libgraph_tool_topology</span><span class="o">.</span>\
               <span class="n">similarity</span><span class="p">(</span><span class="n">g1</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span> <span class="n">g2</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span>
                          <span class="n">_prop</span><span class="p">(</span><span class="s">&quot;v&quot;</span><span class="p">,</span> <span class="n">g1</span><span class="p">,</span> <span class="n">label1</span><span class="p">),</span> <span class="n">_prop</span><span class="p">(</span><span class="s">&quot;v&quot;</span><span class="p">,</span> <span class="n">g2</span><span class="p">,</span> <span class="n">label2</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">libgraph_tool_topology</span><span class="o">.</span>\
               <span class="n">similarity_fast</span><span class="p">(</span><span class="n">g1</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span> <span class="n">g2</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span>
                               <span class="n">_prop</span><span class="p">(</span><span class="s">&quot;v&quot;</span><span class="p">,</span> <span class="n">g1</span><span class="p">,</span> <span class="n">label1</span><span class="p">),</span> <span class="n">_prop</span><span class="p">(</span><span class="s">&quot;v&quot;</span><span class="p">,</span> <span class="n">g2</span><span class="p">,</span> <span class="n">label2</span><span class="p">))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">g1</span><span class="o">.</span><span class="n">is_directed</span><span class="p">()</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">g2</span><span class="o">.</span><span class="n">is_directed</span><span class="p">():</span>
        <span class="n">s</span> <span class="o">/=</span> <span class="mi">2</span>
    <span class="k">if</span> <span class="n">norm</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">/=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">g1</span><span class="o">.</span><span class="n">num_edges</span><span class="p">(),</span> <span class="n">g2</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()))</span>
    <span class="k">return</span> <span class="n">s</span>

</div>
<div class="viewcode-block" id="isomorphism"><a class="viewcode-back" href="../../topology.html#graph_tool.topology.isomorphism">[docs]</a><span class="k">def</span> <span class="nf">isomorphism</span><span class="p">(</span><span class="n">g1</span><span class="p">,</span> <span class="n">g2</span><span class="p">,</span> <span class="n">vertex_inv1</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">vertex_inv2</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">isomap</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;Check whether two graphs are isomorphic.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    g1 : :class:`~graph_tool.Graph`</span>
<span class="sd">        First graph.</span>
<span class="sd">    g2 : :class:`~graph_tool.Graph`</span>
<span class="sd">        Second graph.</span>
<span class="sd">    vertex_inv1 : :class:`~graph_tool.PropertyMap` (optional, default: `None`)</span>
<span class="sd">        Vertex invariant of the first graph. Only vertices with with the same</span>
<span class="sd">        invariants are considered in the isomorphism.</span>
<span class="sd">    vertex_inv2 : :class:`~graph_tool.PropertyMap` (optional, default: `None`)</span>
<span class="sd">        Vertex invariant of the second graph. Only vertices with with the same</span>
<span class="sd">        invariants are considered in the isomorphism.</span>
<span class="sd">    isomap : ``bool`` (optional, default: ``False``)</span>
<span class="sd">        If ``True``, a vertex :class:`~graph_tool.PropertyMap` with the</span>
<span class="sd">        isomorphism mapping is returned as well.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    is_isomorphism : ``bool``</span>
<span class="sd">        ``True`` if both graphs are isomorphic, otherwise ``False``.</span>
<span class="sd">    isomap : :class:`~graph_tool.PropertyMap`</span>
<span class="sd">         Isomorphism mapping corresponding to a property map belonging to the</span>
<span class="sd">         first graph which maps its vertices to their corresponding vertices of</span>
<span class="sd">         the second graph.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       import numpy.random</span>
<span class="sd">       numpy.random.seed(42)</span>
<span class="sd">       gt.seed_rng(42)</span>

<span class="sd">    &gt;&gt;&gt; g = gt.random_graph(100, lambda: (3,3))</span>
<span class="sd">    &gt;&gt;&gt; g2 = gt.Graph(g)</span>
<span class="sd">    &gt;&gt;&gt; gt.isomorphism(g, g2)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; g.add_edge(g.vertex(0), g.vertex(1))</span>
<span class="sd">    &lt;...&gt;</span>
<span class="sd">    &gt;&gt;&gt; gt.isomorphism(g, g2)</span>
<span class="sd">    False</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">imap</span> <span class="o">=</span> <span class="n">g1</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="s">&quot;int32_t&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">vertex_inv1</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">vertex_inv1</span> <span class="o">=</span> <span class="n">g1</span><span class="o">.</span><span class="n">degree_property_map</span><span class="p">(</span><span class="s">&quot;total&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="s">&quot;int64_t&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">vertex_inv1</span> <span class="o">=</span> <span class="n">vertex_inv1</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="s">&quot;int64_t&quot;</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">g1</span><span class="o">.</span><span class="n">degree_property_map</span><span class="p">(</span><span class="s">&quot;total&quot;</span><span class="p">)</span>
        <span class="n">vertex_inv1</span><span class="o">.</span><span class="n">fa</span> <span class="o">+=</span> <span class="p">(</span><span class="n">vertex_inv1</span><span class="o">.</span><span class="n">fa</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">d</span><span class="o">.</span><span class="n">a</span>
    <span class="k">if</span> <span class="n">vertex_inv2</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">vertex_inv2</span> <span class="o">=</span> <span class="n">g2</span><span class="o">.</span><span class="n">degree_property_map</span><span class="p">(</span><span class="s">&quot;total&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="s">&quot;int64_t&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">vertex_inv2</span> <span class="o">=</span> <span class="n">vertex_inv2</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="s">&quot;int64_t&quot;</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">g2</span><span class="o">.</span><span class="n">degree_property_map</span><span class="p">(</span><span class="s">&quot;total&quot;</span><span class="p">)</span>
        <span class="n">vertex_inv2</span><span class="o">.</span><span class="n">fa</span> <span class="o">+=</span> <span class="p">(</span><span class="n">vertex_inv2</span><span class="o">.</span><span class="n">fa</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">d</span><span class="o">.</span><span class="n">a</span>

    <span class="n">inv_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">vertex_inv1</span><span class="o">.</span><span class="n">fa</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span><span class="n">vertex_inv2</span><span class="o">.</span><span class="n">fa</span><span class="o">.</span><span class="n">max</span><span class="p">())</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="n">l1</span> <span class="o">=</span> <span class="n">label_self_loops</span><span class="p">(</span><span class="n">g1</span><span class="p">,</span> <span class="n">mark_only</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">l1</span><span class="o">.</span><span class="n">fa</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">g1</span> <span class="o">=</span> <span class="n">GraphView</span><span class="p">(</span><span class="n">g1</span><span class="p">,</span> <span class="n">efilt</span><span class="o">=</span><span class="mi">1</span> <span class="o">-</span> <span class="n">l1</span><span class="o">.</span><span class="n">fa</span><span class="p">)</span>

    <span class="n">l2</span> <span class="o">=</span> <span class="n">label_self_loops</span><span class="p">(</span><span class="n">g2</span><span class="p">,</span> <span class="n">mark_only</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">l2</span><span class="o">.</span><span class="n">fa</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">g2</span> <span class="o">=</span> <span class="n">GraphView</span><span class="p">(</span><span class="n">g2</span><span class="p">,</span> <span class="n">efilt</span><span class="o">=</span><span class="mi">1</span> <span class="o">-</span> <span class="n">l2</span><span class="o">.</span><span class="n">fa</span><span class="p">)</span>

    <span class="n">iso</span> <span class="o">=</span> <span class="n">libgraph_tool_topology</span><span class="o">.</span>\
           <span class="n">check_isomorphism</span><span class="p">(</span><span class="n">g1</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span> <span class="n">g2</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span>
                             <span class="n">_prop</span><span class="p">(</span><span class="s">&quot;v&quot;</span><span class="p">,</span> <span class="n">g1</span><span class="p">,</span> <span class="n">vertex_inv1</span><span class="p">),</span>
                             <span class="n">_prop</span><span class="p">(</span><span class="s">&quot;v&quot;</span><span class="p">,</span> <span class="n">g2</span><span class="p">,</span> <span class="n">vertex_inv2</span><span class="p">),</span>
                             <span class="n">inv_max</span><span class="p">,</span>
                             <span class="n">_prop</span><span class="p">(</span><span class="s">&quot;v&quot;</span><span class="p">,</span> <span class="n">g1</span><span class="p">,</span> <span class="n">imap</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">isomap</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">iso</span><span class="p">,</span> <span class="n">imap</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">iso</span>

</div>
<div class="viewcode-block" id="subgraph_isomorphism"><a class="viewcode-back" href="../../topology.html#graph_tool.topology.subgraph_isomorphism">[docs]</a><span class="k">def</span> <span class="nf">subgraph_isomorphism</span><span class="p">(</span><span class="n">sub</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">max_n</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">vertex_label</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">edge_label</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                         <span class="n">induced</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">subgraph</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;Obtain all subgraph isomorphisms of `sub` in `g` (or at most `max_n` subgraphs, if `max_n &gt; 0`).</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sub : :class:`~graph_tool.Graph`</span>
<span class="sd">        Subgraph for which to be searched.</span>
<span class="sd">    g : :class:`~graph_tool.Graph`</span>
<span class="sd">        Graph in which the search is performed.</span>
<span class="sd">    max_n : int (optional, default: `0`)</span>
<span class="sd">        Maximum number of matches to find. If `max_n == 0`, all matches are</span>
<span class="sd">        found.</span>
<span class="sd">    vertex_label : pair of :class:`~graph_tool.PropertyMap` (optional, default: `None`)</span>
<span class="sd">        If provided, this should be a pair of :class:`~graph_tool.PropertyMap`</span>
<span class="sd">        objects, belonging to `sub` and `g` (in this order), which specify vertex labels</span>
<span class="sd">        which should match, in addition to the topological isomorphism.</span>
<span class="sd">    edge_label : pair of :class:`~graph_tool.PropertyMap` (optional, default: `None`)</span>
<span class="sd">        If provided, this should be a pair of :class:`~graph_tool.PropertyMap`</span>
<span class="sd">        objects, belonging to `sub` and `g` (in this order), which specify edge labels</span>
<span class="sd">        which should match, in addition to the topological isomorphism.</span>
<span class="sd">    induced : bool (optional, default: False)</span>
<span class="sd">        If `True`, only node-induced subgraphs are found.</span>
<span class="sd">    subgraph : bool (optional, default: True)</span>
<span class="sd">        If `False`, all non-subgraph isomorphisms between `sub` and `g` are</span>
<span class="sd">        found.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    vertex_maps : list of :class:`~graph_tool.PropertyMap` objects</span>
<span class="sd">        List containing vertex property map objects which indicate different</span>
<span class="sd">        isomorphism mappings. The property maps vertices in `sub` to the</span>
<span class="sd">        corresponding vertex index in `g`.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The implementation is based on the VF2 algorithm, introduced by Cordella et al.</span>
<span class="sd">    [cordella-improved-2001]_ [cordella-subgraph-2004]_. The spatial complexity</span>
<span class="sd">    is of order :math:`O(V)`, where :math:`V` is the (maximum) number of vertices</span>
<span class="sd">    of the two graphs. Time complexity is :math:`O(V^2)` in the best case and</span>
<span class="sd">    :math:`O(V!\times V)` in the worst case.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from numpy.random import poisson</span>
<span class="sd">    &gt;&gt;&gt; g = gt.complete_graph(30)</span>
<span class="sd">    &gt;&gt;&gt; sub = gt.complete_graph(10)</span>
<span class="sd">    &gt;&gt;&gt; vm = gt.subgraph_isomorphism(sub, g, max_n=100)</span>
<span class="sd">    &gt;&gt;&gt; print(len(vm))</span>
<span class="sd">    100</span>
<span class="sd">    &gt;&gt;&gt; for i in range(len(vm)):</span>
<span class="sd">    ...   g.set_vertex_filter(None)</span>
<span class="sd">    ...   g.set_edge_filter(None)</span>
<span class="sd">    ...   vmask, emask = gt.mark_subgraph(g, sub, vm[i])</span>
<span class="sd">    ...   g.set_vertex_filter(vmask)</span>
<span class="sd">    ...   g.set_edge_filter(emask)</span>
<span class="sd">    ...   assert gt.isomorphism(g, sub)</span>
<span class="sd">    &gt;&gt;&gt; g.set_vertex_filter(None)</span>
<span class="sd">    &gt;&gt;&gt; g.set_edge_filter(None)</span>
<span class="sd">    &gt;&gt;&gt; ewidth = g.copy_property(emask, value_type=&quot;double&quot;)</span>
<span class="sd">    &gt;&gt;&gt; ewidth.a += 0.5</span>
<span class="sd">    &gt;&gt;&gt; ewidth.a *= 2</span>
<span class="sd">    &gt;&gt;&gt; gt.graph_draw(g, vertex_fill_color=vmask, edge_color=emask,</span>
<span class="sd">    ...               edge_pen_width=ewidth, output_size=(200, 200),</span>
<span class="sd">    ...               output=&quot;subgraph-iso-embed.pdf&quot;)</span>
<span class="sd">    &lt;...&gt;</span>
<span class="sd">    &gt;&gt;&gt; gt.graph_draw(sub, output_size=(200, 200), output=&quot;subgraph-iso.pdf&quot;)</span>
<span class="sd">    &lt;...&gt;</span>

<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       gt.graph_draw(g, vertex_fill_color=vmask, edge_color=emask,</span>
<span class="sd">                     edge_pen_width=ewidth, output_size=(200, 200),</span>
<span class="sd">                     output=&quot;subgraph-iso-embed.png&quot;)</span>
<span class="sd">       gt.graph_draw(sub, output_size=(200, 200), output=&quot;subgraph-iso.png&quot;)</span>

<span class="sd">    .. image:: subgraph-iso.*</span>
<span class="sd">    .. image:: subgraph-iso-embed.*</span>


<span class="sd">    **Left:** Subgraph searched, **Right:** One isomorphic subgraph found in main graph.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [cordella-improved-2001] L. P. Cordella, P. Foggia, C. Sansone, and M. Vento,</span>
<span class="sd">       &quot;An improved algorithm for matching large graphs.&quot;, 3rd IAPR-TC15 Workshop</span>
<span class="sd">       on Graph-based Representations in Pattern Recognition, pp. 149-159, Cuen, 2001.</span>
<span class="sd">       http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.101.5342</span>
<span class="sd">    .. [cordella-subgraph-2004] L. P. Cordella, P. Foggia, C. Sansone, and M. Vento,</span>
<span class="sd">       &quot;A (Sub)Graph Isomorphism Algorithm for Matching Large Graphs.&quot;,</span>
<span class="sd">       IEEE Trans. Pattern Anal. Mach. Intell., vol. 26, no. 10, pp. 1367-1372, 2004. </span>
<span class="sd">       :doi:`10.1109/TPAMI.2004.75`</span>
<span class="sd">    .. [boost-subgraph-iso] http://www.boost.org/libs/graph/doc/vf2_sub_graph_iso.html</span>
<span class="sd">    .. [subgraph-isormophism-wikipedia] http://en.wikipedia.org/wiki/Subgraph_isomorphism_problem</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">sub</span><span class="o">.</span><span class="n">num_vertices</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Cannot search for an empty subgraph.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">vertex_label</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">vertex_label</span> <span class="o">=</span> <span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">vertex_label</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">value_type</span><span class="p">()</span> <span class="o">!=</span> <span class="n">vertex_label</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">value_type</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Both vertex label property maps must be of the same type!&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">vertex_label</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">value_type</span><span class="p">()</span> <span class="o">!=</span> <span class="s">&quot;int32_t&quot;</span><span class="p">:</span>
        <span class="n">vertex_label</span> <span class="o">=</span> <span class="n">perfect_prop_hash</span><span class="p">(</span><span class="n">vertex_label</span><span class="p">,</span> <span class="n">htype</span><span class="o">=</span><span class="s">&quot;int32_t&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">edge_label</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">edge_label</span> <span class="o">=</span> <span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">edge_label</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">value_type</span><span class="p">()</span> <span class="o">!=</span> <span class="n">edge_label</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">value_type</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Both edge label property maps must be of the same type!&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">edge_label</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">value_type</span><span class="p">()</span> <span class="o">!=</span> <span class="s">&quot;int32_t&quot;</span><span class="p">:</span>
        <span class="n">edge_label</span> <span class="o">=</span> <span class="n">perfect_prop_hash</span><span class="p">(</span><span class="n">edge_label</span><span class="p">,</span> <span class="n">htype</span><span class="o">=</span><span class="s">&quot;int32_t&quot;</span><span class="p">)</span>

    <span class="n">vmaps</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">libgraph_tool_topology</span><span class="o">.</span>\
           <span class="n">subgraph_isomorphism</span><span class="p">(</span><span class="n">sub</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span>
                                <span class="n">_prop</span><span class="p">(</span><span class="s">&quot;v&quot;</span><span class="p">,</span> <span class="n">sub</span><span class="p">,</span> <span class="n">vertex_label</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                                <span class="n">_prop</span><span class="p">(</span><span class="s">&quot;v&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">vertex_label</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                                <span class="n">_prop</span><span class="p">(</span><span class="s">&quot;e&quot;</span><span class="p">,</span> <span class="n">sub</span><span class="p">,</span> <span class="n">edge_label</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                                <span class="n">_prop</span><span class="p">(</span><span class="s">&quot;e&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">edge_label</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                                <span class="n">vmaps</span><span class="p">,</span> <span class="n">max_n</span><span class="p">,</span> <span class="n">induced</span><span class="p">,</span> <span class="ow">not</span> <span class="n">subgraph</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vmaps</span><span class="p">)):</span>
        <span class="n">vmaps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">PropertyMap</span><span class="p">(</span><span class="n">vmaps</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">sub</span><span class="p">,</span> <span class="s">&quot;v&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">vmaps</span>

</div>
<div class="viewcode-block" id="mark_subgraph"><a class="viewcode-back" href="../../topology.html#graph_tool.topology.mark_subgraph">[docs]</a><span class="k">def</span> <span class="nf">mark_subgraph</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">sub</span><span class="p">,</span> <span class="n">vmap</span><span class="p">,</span> <span class="n">vmask</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">emask</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Mark a given subgraph `sub` on the graph `g`.</span>

<span class="sd">    The mapping must be provided by the `vmap` and `emap` parameters,</span>
<span class="sd">    which map vertices/edges of `sub` to indexes of the corresponding</span>
<span class="sd">    vertices/edges in `g`.</span>

<span class="sd">    This returns a vertex and an edge property map, with value type &#39;bool&#39;,</span>
<span class="sd">    indicating whether or not a vertex/edge in `g` corresponds to the subgraph</span>
<span class="sd">    `sub`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">vmask</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">vmask</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="s">&quot;bool&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">emask</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">emask</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_edge_property</span><span class="p">(</span><span class="s">&quot;bool&quot;</span><span class="p">)</span>

    <span class="n">vmask</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="n">emask</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">sub</span><span class="o">.</span><span class="n">vertices</span><span class="p">():</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="n">vmap</span><span class="p">[</span><span class="n">v</span><span class="p">])</span>
        <span class="n">vmask</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="n">us</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">g</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="n">vmap</span><span class="p">[</span><span class="n">x</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">out_neighbours</span><span class="p">()])</span>

        <span class="k">for</span> <span class="n">ew</span> <span class="ow">in</span> <span class="n">w</span><span class="o">.</span><span class="n">out_edges</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">ew</span><span class="o">.</span><span class="n">target</span><span class="p">()</span> <span class="ow">in</span> <span class="n">us</span><span class="p">:</span>
                <span class="n">emask</span><span class="p">[</span><span class="n">ew</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="k">return</span> <span class="n">vmask</span><span class="p">,</span> <span class="n">emask</span>

</div>
<div class="viewcode-block" id="min_spanning_tree"><a class="viewcode-back" href="../../topology.html#graph_tool.topology.min_spanning_tree">[docs]</a><span class="k">def</span> <span class="nf">min_spanning_tree</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">tree_map</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the minimum spanning tree of a given graph.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    g : :class:`~graph_tool.Graph`</span>
<span class="sd">        Graph to be used.</span>
<span class="sd">    weights : :class:`~graph_tool.PropertyMap` (optional, default: `None`)</span>
<span class="sd">        The edge weights. If provided, the minimum spanning tree will minimize</span>
<span class="sd">        the edge weights.</span>
<span class="sd">    root : :class:`~graph_tool.Vertex` (optional, default: `None`)</span>
<span class="sd">        Root of the minimum spanning tree. If this is provided, Prim&#39;s algorithm</span>
<span class="sd">        is used. Otherwise, Kruskal&#39;s algorithm is used.</span>
<span class="sd">    tree_map : :class:`~graph_tool.PropertyMap` (optional, default: `None`)</span>
<span class="sd">        If provided, the edge tree map will be written in this property map.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tree_map : :class:`~graph_tool.PropertyMap`</span>
<span class="sd">        Edge property map with mark the tree edges: 1 for tree edge, 0</span>
<span class="sd">        otherwise.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The algorithm runs with :math:`O(E\log E)` complexity, or :math:`O(E\log V)`</span>
<span class="sd">    if `root` is specified.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       import numpy.random</span>
<span class="sd">       numpy.random.seed(42)</span>
<span class="sd">       gt.seed_rng(42)</span>

<span class="sd">    &gt;&gt;&gt; from numpy.random import random</span>
<span class="sd">    &gt;&gt;&gt; g, pos = gt.triangulation(random((400, 2)) * 10, type=&quot;delaunay&quot;)</span>
<span class="sd">    &gt;&gt;&gt; weight = g.new_edge_property(&quot;double&quot;)</span>
<span class="sd">    &gt;&gt;&gt; for e in g.edges():</span>
<span class="sd">    ...    weight[e] = linalg.norm(pos[e.target()].a - pos[e.source()].a)</span>
<span class="sd">    &gt;&gt;&gt; tree = gt.min_spanning_tree(g, weights=weight)</span>
<span class="sd">    &gt;&gt;&gt; gt.graph_draw(g, pos=pos, output=&quot;triang_orig.pdf&quot;)</span>
<span class="sd">    &lt;...&gt;</span>
<span class="sd">    &gt;&gt;&gt; g.set_edge_filter(tree)</span>
<span class="sd">    &gt;&gt;&gt; gt.graph_draw(g, pos=pos, output=&quot;triang_min_span_tree.pdf&quot;)</span>
<span class="sd">    &lt;...&gt;</span>

<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       gt.graph_draw(g, pos=pos, output=&quot;triang_orig.png&quot;)</span>
<span class="sd">       gt.graph_draw(g, pos=pos, output=&quot;triang_min_span_tree.png&quot;)</span>

<span class="sd">    .. image:: triang_orig.*</span>
<span class="sd">        :width: 400px</span>
<span class="sd">    .. image:: triang_min_span_tree.*</span>
<span class="sd">        :width: 400px</span>

<span class="sd">    *Left:* Original graph, *Right:* The minimum spanning tree.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [kruskal-shortest-1956] J. B. Kruskal.  &quot;On the shortest spanning subtree</span>
<span class="sd">       of a graph and the traveling salesman problem&quot;,  In Proceedings of the</span>
<span class="sd">       American Mathematical Society, volume 7, pages 48-50, 1956.</span>
<span class="sd">       :doi:`10.1090/S0002-9939-1956-0078686-7`</span>
<span class="sd">    .. [prim-shortest-1957] R. Prim.  &quot;Shortest connection networks and some</span>
<span class="sd">       generalizations&quot;,  Bell System Technical Journal, 36:1389-1401, 1957.</span>
<span class="sd">    .. [boost-mst] http://www.boost.org/libs/graph/doc/graph_theory_review.html#sec:minimum-spanning-tree</span>
<span class="sd">    .. [mst-wiki] http://en.wikipedia.org/wiki/Minimum_spanning_tree</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">tree_map</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">tree_map</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_edge_property</span><span class="p">(</span><span class="s">&quot;bool&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">tree_map</span><span class="o">.</span><span class="n">value_type</span><span class="p">()</span> <span class="o">!=</span> <span class="s">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;edge property &#39;tree_map&#39; must be of value type bool.&quot;</span><span class="p">)</span>

    <span class="n">u</span> <span class="o">=</span> <span class="n">GraphView</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">libgraph_tool_topology</span><span class="o">.</span>\
               <span class="n">get_kruskal_spanning_tree</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span>
                                         <span class="n">_prop</span><span class="p">(</span><span class="s">&quot;e&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">weights</span><span class="p">),</span>
                                         <span class="n">_prop</span><span class="p">(</span><span class="s">&quot;e&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">tree_map</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">libgraph_tool_topology</span><span class="o">.</span>\
               <span class="n">get_prim_spanning_tree</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">root</span><span class="p">),</span>
                                      <span class="n">_prop</span><span class="p">(</span><span class="s">&quot;e&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">weights</span><span class="p">),</span>
                                      <span class="n">_prop</span><span class="p">(</span><span class="s">&quot;e&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">tree_map</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">tree_map</span>

</div>
<div class="viewcode-block" id="random_spanning_tree"><a class="viewcode-back" href="../../topology.html#graph_tool.topology.random_spanning_tree">[docs]</a><span class="k">def</span> <span class="nf">random_spanning_tree</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">tree_map</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a random spanning tree of a given graph, which can be directed or</span>
<span class="sd">    undirected.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    g : :class:`~graph_tool.Graph`</span>
<span class="sd">        Graph to be used.</span>
<span class="sd">    weights : :class:`~graph_tool.PropertyMap` (optional, default: `None`)</span>
<span class="sd">        The edge weights. If provided, the probability of a particular spanning</span>
<span class="sd">        tree being selected is the product of its edge weights.</span>
<span class="sd">    root : :class:`~graph_tool.Vertex` (optional, default: `None`)</span>
<span class="sd">        Root of the spanning tree. If not provided, it will be selected randomly.</span>
<span class="sd">    tree_map : :class:`~graph_tool.PropertyMap` (optional, default: `None`)</span>
<span class="sd">        If provided, the edge tree map will be written in this property map.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tree_map : :class:`~graph_tool.PropertyMap`</span>
<span class="sd">        Edge property map with mark the tree edges: 1 for tree edge, 0</span>
<span class="sd">        otherwise.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The typical running time for random graphs is :math:`O(N\log N)`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       import numpy.random</span>
<span class="sd">       numpy.random.seed(42)</span>
<span class="sd">       gt.seed_rng(42)</span>

<span class="sd">    &gt;&gt;&gt; from numpy.random import random</span>
<span class="sd">    &gt;&gt;&gt; g, pos = gt.triangulation(random((400, 2)) * 10, type=&quot;delaunay&quot;)</span>
<span class="sd">    &gt;&gt;&gt; weight = g.new_edge_property(&quot;double&quot;)</span>
<span class="sd">    &gt;&gt;&gt; for e in g.edges():</span>
<span class="sd">    ...    weight[e] = linalg.norm(pos[e.target()].a - pos[e.source()].a)</span>
<span class="sd">    &gt;&gt;&gt; tree = gt.random_spanning_tree(g, weights=weight)</span>
<span class="sd">    &gt;&gt;&gt; gt.graph_draw(g, pos=pos, output=&quot;rtriang_orig.pdf&quot;)</span>
<span class="sd">    &lt;...&gt;</span>
<span class="sd">    &gt;&gt;&gt; g.set_edge_filter(tree)</span>
<span class="sd">    &gt;&gt;&gt; gt.graph_draw(g, pos=pos, output=&quot;triang_random_span_tree.pdf&quot;)</span>
<span class="sd">    &lt;...&gt;</span>

<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       gt.graph_draw(g, pos=pos, output=&quot;rtriang_orig.png&quot;)</span>
<span class="sd">       gt.graph_draw(g, pos=pos, output=&quot;triang_random_span_tree.png&quot;)</span>

<span class="sd">    .. image:: rtriang_orig.*</span>
<span class="sd">        :width: 400px</span>
<span class="sd">    .. image:: triang_random_span_tree.*</span>
<span class="sd">        :width: 400px</span>

<span class="sd">    *Left:* Original graph, *Right:* A random spanning tree.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>

<span class="sd">    .. [wilson-generating-1996] David Bruce Wilson, &quot;Generating random spanning</span>
<span class="sd">       trees more quickly than the cover time&quot;, Proceedings of the twenty-eighth</span>
<span class="sd">       annual ACM symposium on Theory of computing, Pages 296-303, ACM New York,</span>
<span class="sd">       1996, :doi:`10.1145/237814.237880`</span>
<span class="sd">    .. [boost-rst] http://www.boost.org/libs/graph/doc/random_spanning_tree.html</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">tree_map</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">tree_map</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_edge_property</span><span class="p">(</span><span class="s">&quot;bool&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">tree_map</span><span class="o">.</span><span class="n">value_type</span><span class="p">()</span> <span class="o">!=</span> <span class="s">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;edge property &#39;tree_map&#39; must be of value type bool.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">num_vertices</span><span class="p">()),</span>
                        <span class="n">use_index</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

    <span class="c"># we need to restrict ourselves to the in-component of root</span>
    <span class="n">l</span> <span class="o">=</span> <span class="n">label_out_component</span><span class="p">(</span><span class="n">GraphView</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="nb">reversed</span><span class="o">=</span><span class="bp">True</span><span class="p">),</span> <span class="n">root</span><span class="p">)</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">GraphView</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">vfilt</span><span class="o">=</span><span class="n">l</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">u</span><span class="o">.</span><span class="n">num_vertices</span><span class="p">()</span> <span class="o">!=</span> <span class="n">g</span><span class="o">.</span><span class="n">num_vertices</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;There must be a path from all vertices to the root vertex: </span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="nb">int</span><span class="p">(</span><span class="n">root</span><span class="p">)</span> <span class="p">)</span>

    <span class="n">libgraph_tool_topology</span><span class="o">.</span>\
        <span class="n">random_spanning_tree</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">root</span><span class="p">),</span>
                             <span class="n">_prop</span><span class="p">(</span><span class="s">&quot;e&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">weights</span><span class="p">),</span>
                             <span class="n">_prop</span><span class="p">(</span><span class="s">&quot;e&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">tree_map</span><span class="p">),</span> <span class="n">_get_rng</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">tree_map</span>

</div>
<div class="viewcode-block" id="dominator_tree"><a class="viewcode-back" href="../../topology.html#graph_tool.topology.dominator_tree">[docs]</a><span class="k">def</span> <span class="nf">dominator_tree</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">dom_map</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a vertex property map the dominator vertices for each vertex.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    g : :class:`~graph_tool.Graph`</span>
<span class="sd">        Graph to be used.</span>
<span class="sd">    root : :class:`~graph_tool.Vertex`</span>
<span class="sd">        The root vertex.</span>
<span class="sd">    dom_map : :class:`~graph_tool.PropertyMap` (optional, default: None)</span>
<span class="sd">        If provided, the dominator map will be written in this property map.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dom_map : :class:`~graph_tool.PropertyMap`</span>
<span class="sd">        The dominator map. It contains for each vertex, the index of its</span>
<span class="sd">        dominator vertex.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    A vertex u dominates a vertex v, if every path of directed graph from the</span>
<span class="sd">    entry to v must go through u.</span>

<span class="sd">    The algorithm runs with :math:`O((V+E)\log (V+E))` complexity.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       import numpy.random</span>
<span class="sd">       numpy.random.seed(42)</span>
<span class="sd">       gt.seed_rng(42)</span>

<span class="sd">    &gt;&gt;&gt; g = gt.random_graph(100, lambda: (2, 2))</span>
<span class="sd">    &gt;&gt;&gt; tree = gt.min_spanning_tree(g)</span>
<span class="sd">    &gt;&gt;&gt; g.set_edge_filter(tree)</span>
<span class="sd">    &gt;&gt;&gt; root = [v for v in g.vertices() if v.in_degree() == 0]</span>
<span class="sd">    &gt;&gt;&gt; dom = gt.dominator_tree(g, root[0])</span>
<span class="sd">    &gt;&gt;&gt; print(dom.a)</span>
<span class="sd">    [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span>
<span class="sd">     0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span>
<span class="sd">     0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [dominator-bgl] http://www.boost.org/libs/graph/doc/lengauer_tarjan_dominator.htm</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">dom_map</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">dom_map</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="s">&quot;int32_t&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">dom_map</span><span class="o">.</span><span class="n">value_type</span><span class="p">()</span> <span class="o">!=</span> <span class="s">&quot;int32_t&quot;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;vertex property &#39;dom_map&#39; must be of value type&quot;</span> <span class="o">+</span>
                         <span class="s">&quot; int32_t.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">g</span><span class="o">.</span><span class="n">is_directed</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;dominator tree requires a directed graph.&quot;</span><span class="p">)</span>
    <span class="n">libgraph_tool_topology</span><span class="o">.</span>\
               <span class="n">dominator_tree</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">root</span><span class="p">),</span>
                              <span class="n">_prop</span><span class="p">(</span><span class="s">&quot;v&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">dom_map</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">dom_map</span>

</div>
<div class="viewcode-block" id="topological_sort"><a class="viewcode-back" href="../../topology.html#graph_tool.topology.topological_sort">[docs]</a><span class="k">def</span> <span class="nf">topological_sort</span><span class="p">(</span><span class="n">g</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the topological sort of the given graph. It is returned as an array</span>
<span class="sd">    of vertex indexes, in the sort order.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The topological sort algorithm creates a linear ordering of the vertices</span>
<span class="sd">    such that if edge (u,v) appears in the graph, then u comes before v in the</span>
<span class="sd">    ordering. The graph must be a directed acyclic graph (DAG).</span>

<span class="sd">    The time complexity is :math:`O(V + E)`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       import numpy.random</span>
<span class="sd">       numpy.random.seed(42)</span>
<span class="sd">       gt.seed_rng(42)</span>

<span class="sd">    &gt;&gt;&gt; g = gt.random_graph(30, lambda: (3, 3))</span>
<span class="sd">    &gt;&gt;&gt; tree = gt.min_spanning_tree(g)</span>
<span class="sd">    &gt;&gt;&gt; g.set_edge_filter(tree)</span>
<span class="sd">    &gt;&gt;&gt; sort = gt.topological_sort(g)</span>
<span class="sd">    &gt;&gt;&gt; print(sort)</span>
<span class="sd">    [29 28 27 26 23 24 22 21 20 18 17 16 15 14 11 10  9  6  5  4 19 12 13  3  2</span>
<span class="sd">     25  1  0  7  8]</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [topological-boost] http://www.boost.org/libs/graph/doc/topological_sort.html</span>
<span class="sd">    .. [topological-wiki] http://en.wikipedia.org/wiki/Topological_sorting</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">topological_order</span> <span class="o">=</span> <span class="n">Vector_int32_t</span><span class="p">()</span>
    <span class="n">is_DAG</span> <span class="o">=</span> <span class="n">libgraph_tool_topology</span><span class="o">.</span>\
        <span class="n">topological_sort</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span> <span class="n">topological_order</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_DAG</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Graph is not a directed acylic graph (DAG).&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">topological_order</span><span class="o">.</span><span class="n">a</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

</div>
<div class="viewcode-block" id="transitive_closure"><a class="viewcode-back" href="../../topology.html#graph_tool.topology.transitive_closure">[docs]</a><span class="k">def</span> <span class="nf">transitive_closure</span><span class="p">(</span><span class="n">g</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the transitive closure graph of g.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The transitive closure of a graph G = (V,E) is a graph G* = (V,E*) such that</span>
<span class="sd">    E* contains an edge (u,v) if and only if G contains a path (of at least one</span>
<span class="sd">    edge) from u to v. The transitive_closure() function transforms the input</span>
<span class="sd">    graph g into the transitive closure graph tc.</span>

<span class="sd">    The time complexity (worst-case) is :math:`O(VE)`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       import numpy.random</span>
<span class="sd">       numpy.random.seed(42)</span>
<span class="sd">       gt.seed_rng(42)</span>

<span class="sd">    &gt;&gt;&gt; g = gt.random_graph(30, lambda: (3, 3))</span>
<span class="sd">    &gt;&gt;&gt; tc = gt.transitive_closure(g)</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [transitive-boost] http://www.boost.org/libs/graph/doc/transitive_closure.html</span>
<span class="sd">    .. [transitive-wiki] http://en.wikipedia.org/wiki/Transitive_closure</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">g</span><span class="o">.</span><span class="n">is_directed</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;graph must be directed for transitive closure.&quot;</span><span class="p">)</span>
    <span class="n">tg</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span>
    <span class="n">libgraph_tool_topology</span><span class="o">.</span><span class="n">transitive_closure</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span>
                                              <span class="n">tg</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">tg</span>

</div>
<div class="viewcode-block" id="label_components"><a class="viewcode-back" href="../../topology.html#graph_tool.topology.label_components">[docs]</a><span class="k">def</span> <span class="nf">label_components</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">vprop</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">attractors</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Label the components to which each vertex in the graph belongs. If the</span>
<span class="sd">    graph is directed, it finds the strongly connected components.</span>

<span class="sd">    A property map with the component labels is returned, together with an</span>
<span class="sd">    histogram of component labels.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    g : :class:`~graph_tool.Graph`</span>
<span class="sd">        Graph to be used.</span>
<span class="sd">    vprop : :class:`~graph_tool.PropertyMap` (optional, default: ``None``)</span>
<span class="sd">        Vertex property to store the component labels. If none is supplied, one</span>
<span class="sd">        is created.</span>
<span class="sd">    directed : bool (optional, default: ``None``)</span>
<span class="sd">        Treat graph as directed or not, independently of its actual</span>
<span class="sd">        directionality.</span>
<span class="sd">    attractors : bool (optional, default: ``False``)</span>
<span class="sd">        If ``True``, and the graph is directed, an additional array with Boolean</span>
<span class="sd">        values is returned, specifying if the strongly connected components are</span>
<span class="sd">        attractors or not.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    comp : :class:`~graph_tool.PropertyMap`</span>
<span class="sd">        Vertex property map with component labels.</span>
<span class="sd">    hist : :class:`~numpy.ndarray`</span>
<span class="sd">        Histogram of component labels.</span>
<span class="sd">    is_attractor : :class:`~numpy.ndarray`</span>
<span class="sd">        A Boolean array specifying if the strongly connected components are</span>
<span class="sd">        attractors or not. This returned only if ``attractors == True``, and the</span>
<span class="sd">        graph is directed.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The components are arbitrarily labeled from 0 to N-1, where N is the total</span>
<span class="sd">    number of components.</span>

<span class="sd">    The algorithm runs in :math:`O(V + E)` time.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       numpy.random.seed(43)</span>
<span class="sd">       gt.seed_rng(43)</span>

<span class="sd">    &gt;&gt;&gt; g = gt.random_graph(100, lambda: (poisson(2), poisson(2)))</span>
<span class="sd">    &gt;&gt;&gt; comp, hist, is_attractor = gt.label_components(g, attractors=True)</span>
<span class="sd">    &gt;&gt;&gt; print(comp.a)</span>
<span class="sd">    [13 13 13 13 14 12 13 15 16 13 17 19 13 13 13 20 13 13 13 10 13 13 22 13 13</span>
<span class="sd">      4 13 13  2 23 13 13 24 13 13 26 27 13 13 13 13  0 13 13  3 13 13 13 28  1</span>
<span class="sd">      6 13 13 13 13  5 13 13 13 13 13 13 13  9 13 11 13 29 13 13 13 13 18 13 30</span>
<span class="sd">     31 13 13 32 13 33 34 35 13 13 21 13 25  8 36 13 13 13 13 13 37 13 13  7 13]</span>
<span class="sd">    &gt;&gt;&gt; print(hist)</span>
<span class="sd">    [ 1  1  1  1  1  1  1  1  1  1  1  1  1 63  1  1  1  1  1  1  1  1  1  1  1</span>
<span class="sd">      1  1  1  1  1  1  1  1  1  1  1  1  1]</span>
<span class="sd">    &gt;&gt;&gt; print(is_attractor)</span>
<span class="sd">    [ True False  True  True  True False False  True False  True  True  True</span>
<span class="sd">      True False  True False False False False False False False False False</span>
<span class="sd">     False False False False False False False False False  True False  True</span>
<span class="sd">     False False]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">vprop</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">vprop</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="s">&quot;int32_t&quot;</span><span class="p">)</span>

    <span class="n">_check_prop_writable</span><span class="p">(</span><span class="n">vprop</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;vprop&quot;</span><span class="p">)</span>
    <span class="n">_check_prop_scalar</span><span class="p">(</span><span class="n">vprop</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;vprop&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">directed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">GraphView</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="n">directed</span><span class="p">)</span>

    <span class="n">hist</span> <span class="o">=</span> <span class="n">libgraph_tool_topology</span><span class="o">.</span>\
               <span class="n">label_components</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span> <span class="n">_prop</span><span class="p">(</span><span class="s">&quot;v&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">vprop</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">attractors</span> <span class="ow">and</span> <span class="n">g</span><span class="o">.</span><span class="n">is_directed</span><span class="p">()</span> <span class="ow">and</span> <span class="n">directed</span> <span class="o">!=</span> <span class="bp">False</span><span class="p">:</span>
        <span class="n">is_attractor</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">hist</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&quot;bool&quot;</span><span class="p">)</span>
        <span class="n">libgraph_tool_topology</span><span class="o">.</span>\
               <span class="n">label_attractors</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span> <span class="n">_prop</span><span class="p">(</span><span class="s">&quot;v&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">vprop</span><span class="p">),</span>
                                <span class="n">is_attractor</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">vprop</span><span class="p">,</span> <span class="n">hist</span><span class="p">,</span> <span class="n">is_attractor</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">vprop</span><span class="p">,</span> <span class="n">hist</span>

</div>
<div class="viewcode-block" id="label_largest_component"><a class="viewcode-back" href="../../topology.html#graph_tool.topology.label_largest_component">[docs]</a><span class="k">def</span> <span class="nf">label_largest_component</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Label the largest component in the graph. If the graph is directed, then the</span>
<span class="sd">    largest strongly connected component is labelled.</span>

<span class="sd">    A property map with a boolean label is returned.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    g : :class:`~graph_tool.Graph`</span>
<span class="sd">        Graph to be used.</span>
<span class="sd">    directed : bool (optional, default:None)</span>
<span class="sd">        Treat graph as directed or not, independently of its actual</span>
<span class="sd">        directionality.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    comp : :class:`~graph_tool.PropertyMap`</span>
<span class="sd">         Boolean vertex property map which labels the largest component.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The algorithm runs in :math:`O(V + E)` time.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       import numpy.random</span>
<span class="sd">       numpy.random.seed(42)</span>
<span class="sd">       gt.seed_rng(42)</span>

<span class="sd">    &gt;&gt;&gt; g = gt.random_graph(100, lambda: poisson(1), directed=False)</span>
<span class="sd">    &gt;&gt;&gt; l = gt.label_largest_component(g)</span>
<span class="sd">    &gt;&gt;&gt; print(l.a)</span>
<span class="sd">    [0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 1 0 0 0 0 0 0 0</span>
<span class="sd">     1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0</span>
<span class="sd">     0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 1 1 0 0 0 0 1 0 0 1 0]</span>
<span class="sd">    &gt;&gt;&gt; u = gt.GraphView(g, vfilt=l)   # extract the largest component as a graph</span>
<span class="sd">    &gt;&gt;&gt; print(u.num_vertices())</span>
<span class="sd">    18</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">label</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="s">&quot;bool&quot;</span><span class="p">)</span>
    <span class="n">c</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="n">label_components</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="n">directed</span><span class="p">)</span>
    <span class="n">vfilt</span><span class="p">,</span> <span class="n">inv</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">get_vertex_filter</span><span class="p">()</span>
    <span class="n">label</span><span class="o">.</span><span class="n">fa</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">fa</span> <span class="o">==</span> <span class="n">h</span><span class="o">.</span><span class="n">argmax</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">label</span>

</div>
<div class="viewcode-block" id="label_out_component"><a class="viewcode-back" href="../../topology.html#graph_tool.topology.label_out_component">[docs]</a><span class="k">def</span> <span class="nf">label_out_component</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Label the out-component (or simply the component for undirected graphs) of a</span>
<span class="sd">    root vertex.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    g : :class:`~graph_tool.Graph`</span>
<span class="sd">        Graph to be used.</span>
<span class="sd">    root : :class:`~graph_tool.Vertex`</span>
<span class="sd">        The root vertex.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    comp : :class:`~graph_tool.PropertyMap`</span>
<span class="sd">         Boolean vertex property map which labels the out-component.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The algorithm runs in :math:`O(V + E)` time.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       import numpy.random</span>
<span class="sd">       numpy.random.seed(42)</span>
<span class="sd">       gt.seed_rng(42)</span>

<span class="sd">    &gt;&gt;&gt; g = gt.random_graph(100, lambda: poisson(2.2), directed=False)</span>
<span class="sd">    &gt;&gt;&gt; l = gt.label_out_component(g, g.vertex(2))</span>
<span class="sd">    &gt;&gt;&gt; print(l.a)</span>
<span class="sd">    [1 1 1 1 1 1 1 0 1 1 1 0 1 1 0 1 1 1 0 1 1 0 1 1 1 1 1 1 1 1 0 0 0 1 1 1 1</span>
<span class="sd">     1 1 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1 1 0 0 1 1 1 1 1 0 0</span>
<span class="sd">     1 1 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 0 1 1 1 0]</span>

<span class="sd">    The in-component can be obtained by reversing the graph.</span>

<span class="sd">    &gt;&gt;&gt; l = gt.label_out_component(gt.GraphView(g, reversed=True, directed=True),</span>
<span class="sd">    ...                            g.vertex(1))</span>
<span class="sd">    &gt;&gt;&gt; print(l.a)</span>
<span class="sd">    [0 1 1 1 1 0 1 0 0 0 0 0 0 0 0 0 1 1 0 0 1 0 0 1 1 0 0 0 1 1 0 0 0 0 1 0 1</span>
<span class="sd">     1 0 0 0 0 0 0 0 1 0 0 0 1 0 1 0 1 0 1 1 1 1 0 0 0 1 1 0 0 0 0 0 0 0 1 0 0</span>
<span class="sd">     1 0 0 0 0 1 1 1 0 0 1 1 0 0 0 1 1 0 1 1 0 0 1 0 1 0]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">label</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="s">&quot;bool&quot;</span><span class="p">)</span>
    <span class="n">libgraph_tool_topology</span><span class="o">.</span>\
             <span class="n">label_out_component</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">root</span><span class="p">),</span>
                                 <span class="n">_prop</span><span class="p">(</span><span class="s">&quot;v&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">label</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">label</span>

</div>
<div class="viewcode-block" id="label_biconnected_components"><a class="viewcode-back" href="../../topology.html#graph_tool.topology.label_biconnected_components">[docs]</a><span class="k">def</span> <span class="nf">label_biconnected_components</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">eprop</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">vprop</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Label the edges of biconnected components, and the vertices which are</span>
<span class="sd">    articulation points.</span>

<span class="sd">    An edge property map with the component labels is returned, together a</span>
<span class="sd">    boolean vertex map marking the articulation points, and an histogram of</span>
<span class="sd">    component labels.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    g : :class:`~graph_tool.Graph`</span>
<span class="sd">        Graph to be used.</span>

<span class="sd">    eprop : :class:`~graph_tool.PropertyMap` (optional, default: None)</span>
<span class="sd">        Edge property to label the biconnected components.</span>

<span class="sd">    vprop : :class:`~graph_tool.PropertyMap` (optional, default: None)</span>
<span class="sd">        Vertex property to mark the articulation points. If none is supplied,</span>
<span class="sd">        one is created.</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    bicomp : :class:`~graph_tool.PropertyMap`</span>
<span class="sd">        Edge property map with the biconnected component labels.</span>
<span class="sd">    articulation : :class:`~graph_tool.PropertyMap`</span>
<span class="sd">        Boolean vertex property map which has value 1 for each vertex which is</span>
<span class="sd">        an articulation point, and zero otherwise.</span>
<span class="sd">    nc : int</span>
<span class="sd">        Number of biconnected components.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    A connected graph is biconnected if the removal of any single vertex (and</span>
<span class="sd">    all edges incident on that vertex) can not disconnect the graph. More</span>
<span class="sd">    generally, the biconnected components of a graph are the maximal subsets of</span>
<span class="sd">    vertices such that the removal of a vertex from a particular component will</span>
<span class="sd">    not disconnect the component. Unlike connected components, vertices may</span>
<span class="sd">    belong to multiple biconnected components: those vertices that belong to</span>
<span class="sd">    more than one biconnected component are called &quot;articulation points&quot; or,</span>
<span class="sd">    equivalently, &quot;cut vertices&quot;. Articulation points are vertices whose removal</span>
<span class="sd">    would increase the number of connected components in the graph. Thus, a</span>
<span class="sd">    graph without articulation points is biconnected. Vertices can be present in</span>
<span class="sd">    multiple biconnected components, but each edge can only be contained in a</span>
<span class="sd">    single biconnected component.</span>

<span class="sd">    The algorithm runs in :math:`O(V + E)` time.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       import numpy.random</span>
<span class="sd">       numpy.random.seed(42)</span>
<span class="sd">       gt.seed_rng(42)</span>

<span class="sd">    &gt;&gt;&gt; g = gt.random_graph(100, lambda: poisson(2), directed=False)</span>
<span class="sd">    &gt;&gt;&gt; comp, art, hist = gt.label_biconnected_components(g)</span>
<span class="sd">    &gt;&gt;&gt; print(comp.a)</span>
<span class="sd">    [31 42 41 41 41 21  2 41 41 19 41 33 41 41 12 41 40 41 41 41 41 41 41  8 41</span>
<span class="sd">     10 41 32 28 30 41 41 41  5 41 41 41 41 39 38 41 41 41 41 45 44 41 41 22 41</span>
<span class="sd">     41 41  0 41 41 41 41 41 41 41 41  7 13 41 20 41 41 41 41 34  9 41 41  4 43</span>
<span class="sd">     18 41 41 15 29  1 41 41 41 41  6 41 25 23 35 16 24 37 11  3 36 17 26 27 14</span>
<span class="sd">     41]</span>
<span class="sd">    &gt;&gt;&gt; print(art.a)</span>
<span class="sd">    [1 0 1 1 0 1 0 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 1 1 0 0</span>
<span class="sd">     1 1 0 0 1 0 0 0 1 1 0 0 0 1 0 1 0 1 0 0 1 0 0 0 0 1 1 0 1 0 0 0 0 0 0 1 1</span>
<span class="sd">     1 0 0 0 0 0 0 1 1 0 0 0 1 0 1 1 0 0 0 1 0 0 0 1 0 0]</span>
<span class="sd">    &gt;&gt;&gt; print(hist)</span>
<span class="sd">    [ 1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1</span>
<span class="sd">      1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1 56  1  1  1  1]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">vprop</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">vprop</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="s">&quot;bool&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">eprop</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">eprop</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_edge_property</span><span class="p">(</span><span class="s">&quot;int32_t&quot;</span><span class="p">)</span>

    <span class="n">_check_prop_writable</span><span class="p">(</span><span class="n">vprop</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;vprop&quot;</span><span class="p">)</span>
    <span class="n">_check_prop_scalar</span><span class="p">(</span><span class="n">vprop</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;vprop&quot;</span><span class="p">)</span>
    <span class="n">_check_prop_writable</span><span class="p">(</span><span class="n">eprop</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;eprop&quot;</span><span class="p">)</span>
    <span class="n">_check_prop_scalar</span><span class="p">(</span><span class="n">eprop</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;eprop&quot;</span><span class="p">)</span>

    <span class="n">g</span> <span class="o">=</span> <span class="n">GraphView</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="n">hist</span> <span class="o">=</span> <span class="n">libgraph_tool_topology</span><span class="o">.</span>\
             <span class="n">label_biconnected_components</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span> <span class="n">_prop</span><span class="p">(</span><span class="s">&quot;e&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">eprop</span><span class="p">),</span>
                                          <span class="n">_prop</span><span class="p">(</span><span class="s">&quot;v&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">vprop</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">eprop</span><span class="p">,</span> <span class="n">vprop</span><span class="p">,</span> <span class="n">hist</span>
</div>
<div class="viewcode-block" id="kcore_decomposition"><a class="viewcode-back" href="../../topology.html#graph_tool.topology.kcore_decomposition">[docs]</a><span class="k">def</span> <span class="nf">kcore_decomposition</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">deg</span><span class="o">=</span><span class="s">&quot;out&quot;</span><span class="p">,</span> <span class="n">vprop</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform a k-core decomposition of the given graph.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    g : :class:`~graph_tool.Graph`</span>
<span class="sd">        Graph to be used.</span>
<span class="sd">    deg : string</span>
<span class="sd">        Degree to be used for the decomposition. It can be either &quot;in&quot;, &quot;out&quot; or</span>
<span class="sd">        &quot;total&quot;, for in-, out-, or total degree of the vertices.</span>
<span class="sd">    vprop : :class:`~graph_tool.PropertyMap` (optional, default: ``None``)</span>
<span class="sd">        Vertex property to store the decomposition. If ``None`` is supplied,</span>
<span class="sd">        one is created.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    kval : :class:`~graph_tool.PropertyMap`</span>
<span class="sd">        Vertex property map with the k-core decomposition, i.e. a given vertex v</span>
<span class="sd">        belongs to the ``kval[v]``-core.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    The k-core is a maximal set of vertices such that its induced subgraph only</span>
<span class="sd">    contains vertices with degree larger than or equal to k.</span>

<span class="sd">    This algorithm is described in [batagelk-algorithm]_ and runs in :math:`O(V + E)`</span>
<span class="sd">    time.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    &gt;&gt;&gt; g = gt.collection.data[&quot;netscience&quot;]</span>
<span class="sd">    &gt;&gt;&gt; g = gt.GraphView(g, vfilt=gt.label_largest_component(g))</span>
<span class="sd">    &gt;&gt;&gt; kcore = gt.kcore_decomposition(g)</span>
<span class="sd">    &gt;&gt;&gt; gt.graph_draw(g, pos=g.vp[&quot;pos&quot;], vertex_fill_color=kcore, vertex_text=kcore, output=&quot;netsci-kcore.pdf&quot;)</span>
<span class="sd">    &lt;...&gt;</span>

<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       gt.graph_draw(g, pos=g.vp[&quot;pos&quot;], vertex_fill_color=kcore, vertex_text=kcore, output=&quot;netsci-kcore.png&quot;)</span>

<span class="sd">    .. figure:: netsci-kcore.*</span>
<span class="sd">        :align: center</span>

<span class="sd">        K-core decomposition of a network of network scientists.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [k-core] http://en.wikipedia.org/wiki/Degeneracy_%28graph_theory%29</span>
<span class="sd">    .. [batagelk-algorithm]  Vladimir Batagelj, Matja Zavernik, &quot;Fast</span>
<span class="sd">       algorithms for determining (generalized) core groups in social</span>
<span class="sd">       networks&quot;, Advances in Data Analysis and Classification</span>
<span class="sd">       Volume 5, Issue 2, pp 129-145 (2011), :DOI:`10.1007/s11634-010-0079-y`,</span>
<span class="sd">       :arxiv:`cs/0310049`</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">vprop</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">vprop</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="s">&quot;int32_t&quot;</span><span class="p">)</span>

    <span class="n">_check_prop_writable</span><span class="p">(</span><span class="n">vprop</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;vprop&quot;</span><span class="p">)</span>
    <span class="n">_check_prop_scalar</span><span class="p">(</span><span class="n">vprop</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;vprop&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">deg</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&quot;in&quot;</span><span class="p">,</span> <span class="s">&quot;out&quot;</span><span class="p">,</span> <span class="s">&quot;total&quot;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;invalid degree: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">deg</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">is_directed</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">deg</span> <span class="o">==</span> <span class="s">&quot;out&quot;</span><span class="p">:</span>
            <span class="n">g</span> <span class="o">=</span> <span class="n">GraphView</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="nb">reversed</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">deg</span> <span class="o">==</span> <span class="s">&quot;total&quot;</span><span class="p">:</span>
            <span class="n">g</span> <span class="o">=</span> <span class="n">GraphView</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

    <span class="n">libgraph_tool_topology</span><span class="o">.</span>\
               <span class="n">kcore_decomposition</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span> <span class="n">_prop</span><span class="p">(</span><span class="s">&quot;v&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">vprop</span><span class="p">),</span>
                                   <span class="n">_degree</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">deg</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">vprop</span>

</div>
<div class="viewcode-block" id="shortest_distance"><a class="viewcode-back" href="../../topology.html#graph_tool.topology.shortest_distance">[docs]</a><span class="k">def</span> <span class="nf">shortest_distance</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">max_dist</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                      <span class="n">directed</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">dense</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">dist_map</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                      <span class="n">pred_map</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate the distance from a source to a target vertex, or to of all</span>
<span class="sd">    vertices from a given source, or the all pairs shortest paths, if the source</span>
<span class="sd">    is not specified.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    g : :class:`~graph_tool.Graph`</span>
<span class="sd">        Graph to be used.</span>
<span class="sd">    source : :class:`~graph_tool.Vertex` (optional, default: None)</span>
<span class="sd">        Source vertex of the search. If unspecified, the all pairs shortest</span>
<span class="sd">        distances are computed.</span>
<span class="sd">    target : :class:`~graph_tool.Vertex` or iterable of such objects (optional, default: None)</span>
<span class="sd">        Target vertex (or vertices) of the search. If unspecified, the distance</span>
<span class="sd">        to all vertices from the source will be computed.</span>
<span class="sd">    weights : :class:`~graph_tool.PropertyMap` (optional, default: None)</span>
<span class="sd">        The edge weights. If provided, the minimum spanning tree will minimize</span>
<span class="sd">        the edge weights.</span>
<span class="sd">    max_dist : scalar value (optional, default: None)</span>
<span class="sd">        If specified, this limits the maximum distance of the vertices</span>
<span class="sd">        searched. This parameter has no effect if source is None.</span>
<span class="sd">    directed : bool (optional, default:None)</span>
<span class="sd">        Treat graph as directed or not, independently of its actual</span>
<span class="sd">        directionality.</span>
<span class="sd">    dense : bool (optional, default: False)</span>
<span class="sd">        If true, and source is None, the Floyd-Warshall algorithm is used,</span>
<span class="sd">        otherwise the Johnson algorithm is used. If source is not None, this option</span>
<span class="sd">        has no effect.</span>
<span class="sd">    dist_map : :class:`~graph_tool.PropertyMap` (optional, default: None)</span>
<span class="sd">        Vertex property to store the distances. If none is supplied, one</span>
<span class="sd">        is created.</span>
<span class="sd">    pred_map : bool (optional, default: False)</span>
<span class="sd">        If true, a vertex property map with the predecessors is returned.</span>
<span class="sd">        Ignored if source=None.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dist_map : :class:`~graph_tool.PropertyMap`</span>
<span class="sd">        Vertex property map with the distances from source. If source is &#39;None&#39;,</span>
<span class="sd">        it will have a vector value type, with the distances to every vertex.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    If a source is given, the distances are calculated with a breadth-first</span>
<span class="sd">    search (BFS) or Dijkstra&#39;s algorithm [dijkstra]_, if weights are given. If</span>
<span class="sd">    source is not given, the distances are calculated with Johnson&#39;s algorithm</span>
<span class="sd">    [johnson-apsp]_. If dense=True, the Floyd-Warshall algorithm</span>
<span class="sd">    [floyd-warshall-apsp]_ is used instead.</span>

<span class="sd">    If source is specified, the algorithm runs in :math:`O(V + E)` time, or</span>
<span class="sd">    :math:`O(V \log V)` if weights are given. If source is not specified, it</span>
<span class="sd">    runs in :math:`O(VE\log V)` time, or :math:`O(V^3)` if dense == True.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       import numpy.random</span>
<span class="sd">       numpy.random.seed(42)</span>
<span class="sd">       gt.seed_rng(42)</span>

<span class="sd">    &gt;&gt;&gt; from numpy.random import poisson</span>
<span class="sd">    &gt;&gt;&gt; g = gt.random_graph(100, lambda: (poisson(3), poisson(3)))</span>
<span class="sd">    &gt;&gt;&gt; dist = gt.shortest_distance(g, source=g.vertex(0))</span>
<span class="sd">    &gt;&gt;&gt; print(dist.a)</span>
<span class="sd">    [         0          1          5          4 2147483647          4</span>
<span class="sd">              9          5          8          5          7          6</span>
<span class="sd">              3          5          6          8          3          3</span>
<span class="sd">              5          6 2147483647          1          4          5</span>
<span class="sd">              5          2          5          7          4          5</span>
<span class="sd">              5          5          4          4          5          2</span>
<span class="sd">              5 2147483647          5          2 2147483647          6</span>
<span class="sd">              5          6          6          2          5          4</span>
<span class="sd">              3          6          5          4          4          5</span>
<span class="sd">              3          3          5          5          1          5</span>
<span class="sd">              4          6          3          4          3          3</span>
<span class="sd">              7          5          5          4 2147483647 2147483647</span>
<span class="sd">              2          5          3          5          5          6</span>
<span class="sd">              3          5          6          6          5          4</span>
<span class="sd">              5          3          6          3          4 2147483647</span>
<span class="sd">              4          6          4          4          4          4</span>
<span class="sd">              6          5          4          4]</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; dist = gt.shortest_distance(g)</span>
<span class="sd">    &gt;&gt;&gt; print(dist[g.vertex(0)].a)</span>
<span class="sd">    [         0          1          5          4 2147483647          4</span>
<span class="sd">              9          5          8          5          7          6</span>
<span class="sd">              3          5          6          8          3          3</span>
<span class="sd">              5          6 2147483647          1          4          5</span>
<span class="sd">              5          2          5          7          4          5</span>
<span class="sd">              5          5          4          4          5          2</span>
<span class="sd">              5 2147483647          5          2 2147483647          6</span>
<span class="sd">              5          6          6          2          5          4</span>
<span class="sd">              3          6          5          4          4          5</span>
<span class="sd">              3          3          5          5          1          5</span>
<span class="sd">              4          6          3          4          3          3</span>
<span class="sd">              7          5          5          4 2147483647 2147483647</span>
<span class="sd">              2          5          3          5          5          6</span>
<span class="sd">              3          5          6          6          5          4</span>
<span class="sd">              5          3          6          3          4 2147483647</span>
<span class="sd">              4          6          4          4          4          4</span>
<span class="sd">              6          5          4          4]</span>
<span class="sd">    &gt;&gt;&gt; dist = gt.shortest_distance(g, source=g.vertex(0), target=g.vertex(2))</span>
<span class="sd">    &gt;&gt;&gt; print (dist)</span>
<span class="sd">    5</span>
<span class="sd">    &gt;&gt;&gt; dist = gt.shortest_distance(g, source=g.vertex(0), target=[g.vertex(2), g.vertex(6)])</span>
<span class="sd">    &gt;&gt;&gt; print (dist)</span>
<span class="sd">    [5 9]</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [bfs] Edward Moore, &quot;The shortest path through a maze&quot;, International</span>
<span class="sd">       Symposium on the Theory of Switching (1959), Harvard University Press.</span>
<span class="sd">    .. [bfs-boost] http://www.boost.org/libs/graph/doc/breadth_first_search.html</span>
<span class="sd">    .. [dijkstra] E. Dijkstra, &quot;A note on two problems in connexion with</span>
<span class="sd">       graphs.&quot; Numerische Mathematik, 1:269-271, 1959.</span>
<span class="sd">    .. [dijkstra-boost] http://www.boost.org/libs/graph/doc/dijkstra_shortest_paths.html</span>
<span class="sd">    .. [johnson-apsp] http://www.boost.org/libs/graph/doc/johnson_all_pairs_shortest.html</span>
<span class="sd">    .. [floyd-warshall-apsp] http://www.boost.org/libs/graph/doc/floyd_warshall_shortest.html</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">Iterable</span><span class="p">):</span>
        <span class="n">target</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&quot;int64&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">target</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">target</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&quot;int64&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">target</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">target</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&quot;int64&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">dist_type</span> <span class="o">=</span> <span class="s">&#39;int32_t&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dist_type</span> <span class="o">=</span> <span class="n">weights</span><span class="o">.</span><span class="n">value_type</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">dist_map</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">source</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">dist_map</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="n">dist_type</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dist_map</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="s">&quot;vector&lt;</span><span class="si">%s</span><span class="s">&gt;&quot;</span> <span class="o">%</span> <span class="n">dist_type</span><span class="p">)</span>

    <span class="n">_check_prop_writable</span><span class="p">(</span><span class="n">dist_map</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;dist_map&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">source</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">_check_prop_scalar</span><span class="p">(</span><span class="n">dist_map</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;dist_map&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">_check_prop_vector</span><span class="p">(</span><span class="n">dist_map</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;dist_map&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">max_dist</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">max_dist</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="n">directed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">GraphView</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="n">directed</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">g</span>

    <span class="k">if</span> <span class="n">source</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">pmap</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">copy_property</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">vertex_index</span><span class="p">,</span> <span class="n">value_type</span><span class="o">=</span><span class="s">&quot;int64_t&quot;</span><span class="p">)</span>
        <span class="n">libgraph_tool_topology</span><span class="o">.</span><span class="n">get_dists</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span>
                                         <span class="nb">int</span><span class="p">(</span><span class="n">source</span><span class="p">),</span>
                                         <span class="n">target</span><span class="p">,</span>
                                         <span class="n">_prop</span><span class="p">(</span><span class="s">&quot;v&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">dist_map</span><span class="p">),</span>
                                         <span class="n">_prop</span><span class="p">(</span><span class="s">&quot;e&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">weights</span><span class="p">),</span>
                                         <span class="n">_prop</span><span class="p">(</span><span class="s">&quot;v&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">pmap</span><span class="p">),</span>
                                         <span class="nb">float</span><span class="p">(</span><span class="n">max_dist</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">libgraph_tool_topology</span><span class="o">.</span><span class="n">get_all_dists</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span>
                                             <span class="n">_prop</span><span class="p">(</span><span class="s">&quot;v&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">dist_map</span><span class="p">),</span>
                                             <span class="n">_prop</span><span class="p">(</span><span class="s">&quot;e&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">weights</span><span class="p">),</span> <span class="n">dense</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">source</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">target</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">target</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">dist_map</span> <span class="o">=</span> <span class="n">dist_map</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="n">target</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dist_map</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dist_map</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="n">target</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">source</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">pred_map</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">dist_map</span><span class="p">,</span> <span class="n">pmap</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">dist_map</span>
</div>
<div class="viewcode-block" id="shortest_path"><a class="viewcode-back" href="../../topology.html#graph_tool.topology.shortest_path">[docs]</a><span class="k">def</span> <span class="nf">shortest_path</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">pred_map</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the shortest path from `source` to `target`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    g : :class:`~graph_tool.Graph`</span>
<span class="sd">        Graph to be used.</span>
<span class="sd">    source : :class:`~graph_tool.Vertex`</span>
<span class="sd">        Source vertex of the search.</span>
<span class="sd">    target : :class:`~graph_tool.Vertex`</span>
<span class="sd">        Target vertex of the search.</span>
<span class="sd">    weights : :class:`~graph_tool.PropertyMap` (optional, default: None)</span>
<span class="sd">        The edge weights.</span>
<span class="sd">    pred_map :  :class:`~graph_tool.PropertyMap` (optional, default: None)</span>
<span class="sd">        Vertex property map with the predecessors in the search tree. If this is</span>
<span class="sd">        provided, the shortest paths are not computed, and are obtained directly</span>
<span class="sd">        from this map.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    vertex_list : list of :class:`~graph_tool.Vertex`</span>
<span class="sd">        List of vertices from `source` to `target` in the shortest path.</span>
<span class="sd">    edge_list : list of :class:`~graph_tool.Edge`</span>
<span class="sd">        List of edges from `source` to `target` in the shortest path.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    The paths are computed with a breadth-first search (BFS) or Dijkstra&#39;s</span>
<span class="sd">    algorithm [dijkstra]_, if weights are given.</span>

<span class="sd">    The algorithm runs in :math:`O(V + E)` time, or :math:`O(V \log V)` if</span>
<span class="sd">    weights are given.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       import numpy.random</span>
<span class="sd">       numpy.random.seed(43)</span>
<span class="sd">       gt.seed_rng(43)</span>

<span class="sd">    &gt;&gt;&gt; from numpy.random import poisson</span>
<span class="sd">    &gt;&gt;&gt; g = gt.random_graph(300, lambda: (poisson(4), poisson(4)))</span>
<span class="sd">    &gt;&gt;&gt; vlist, elist = gt.shortest_path(g, g.vertex(10), g.vertex(11))</span>
<span class="sd">    &gt;&gt;&gt; print([str(v) for v in vlist])</span>
<span class="sd">    [&#39;10&#39;, &#39;11&#39;]</span>
<span class="sd">    &gt;&gt;&gt; print([str(e) for e in elist])</span>
<span class="sd">    [&#39;(10, 11)&#39;]</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [bfs] Edward Moore, &quot;The shortest path through a maze&quot;, International</span>
<span class="sd">       Symposium on the Theory of Switching (1959), Harvard University</span>
<span class="sd">       Press</span>
<span class="sd">    .. [bfs-boost] http://www.boost.org/libs/graph/doc/breadth_first_search.html</span>
<span class="sd">    .. [dijkstra] E. Dijkstra, &quot;A note on two problems in connexion with</span>
<span class="sd">       graphs.&quot; Numerische Mathematik, 1:269-271, 1959.</span>
<span class="sd">    .. [dijkstra-boost] http://www.boost.org/libs/graph/doc/dijkstra_shortest_paths.html</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">pred_map</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">pred_map</span> <span class="o">=</span> <span class="n">shortest_distance</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span>
                                     <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span>
                                     <span class="n">pred_map</span><span class="o">=</span><span class="bp">True</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">pred_map</span><span class="p">[</span><span class="n">target</span><span class="p">]</span> <span class="o">==</span> <span class="nb">int</span><span class="p">(</span><span class="n">target</span><span class="p">):</span>  <span class="c"># no path to target</span>
        <span class="k">return</span> <span class="p">[],</span> <span class="p">[]</span>

    <span class="n">vlist</span> <span class="o">=</span> <span class="p">[</span><span class="n">target</span><span class="p">]</span>
    <span class="n">elist</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">max_w</span> <span class="o">=</span> <span class="n">weights</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">max_w</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="n">v</span> <span class="o">=</span> <span class="n">target</span>
    <span class="k">while</span> <span class="n">v</span> <span class="o">!=</span> <span class="n">source</span><span class="p">:</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="n">pred_map</span><span class="p">[</span><span class="n">v</span><span class="p">])</span>
        <span class="n">min_w</span> <span class="o">=</span> <span class="n">max_w</span>
        <span class="n">pe</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">s</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">in_edges</span><span class="p">()</span> <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">is_directed</span><span class="p">()</span> <span class="k">else</span> <span class="n">v</span><span class="o">.</span><span class="n">out_edges</span><span class="p">():</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">source</span><span class="p">()</span> <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">is_directed</span><span class="p">()</span> <span class="k">else</span> <span class="n">e</span><span class="o">.</span><span class="n">target</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="n">p</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">weights</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min_w</span><span class="p">:</span>
                        <span class="n">min_w</span> <span class="o">=</span> <span class="n">weights</span><span class="p">[</span><span class="n">e</span><span class="p">]</span>
                        <span class="n">pe</span> <span class="o">=</span> <span class="n">e</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">pe</span> <span class="o">=</span> <span class="n">e</span>
                    <span class="k">break</span>
        <span class="n">elist</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">pe</span><span class="p">)</span>
        <span class="n">vlist</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">p</span>
    <span class="k">return</span> <span class="n">vlist</span><span class="p">,</span> <span class="n">elist</span>

</div>
<div class="viewcode-block" id="pseudo_diameter"><a class="viewcode-back" href="../../topology.html#graph_tool.topology.pseudo_diameter">[docs]</a><span class="k">def</span> <span class="nf">pseudo_diameter</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the pseudo-diameter of the graph.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    g : :class:`~graph_tool.Graph`</span>
<span class="sd">        Graph to be used.</span>
<span class="sd">    source : :class:`~graph_tool.Vertex` (optional, default: `None`)</span>
<span class="sd">        Source vertex of the search. If not supplied, the first vertex</span>
<span class="sd">        in the graph will be chosen.</span>
<span class="sd">    weights : :class:`~graph_tool.PropertyMap` (optional, default: `None`)</span>
<span class="sd">        The edge weights.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pseudo_diameter : int</span>
<span class="sd">        The pseudo-diameter of the graph.</span>
<span class="sd">    end_points : pair of :class:`~graph_tool.Vertex`</span>
<span class="sd">        The two vertices which correspond to the pseudo-diameter found.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    The pseudo-diameter is an approximate graph diameter. It is obtained by</span>
<span class="sd">    starting from a vertex `source`, and finds a vertex `target` that is</span>
<span class="sd">    farthest away from `source`. This process is repeated by treating</span>
<span class="sd">    `target` as the new starting vertex, and ends when the graph distance no</span>
<span class="sd">    longer increases. A vertex from the last level set that has the smallest</span>
<span class="sd">    degree is chosen as the final starting vertex u, and a traversal is done</span>
<span class="sd">    to see if the graph distance can be increased. This graph distance is</span>
<span class="sd">    taken to be the pseudo-diameter.</span>

<span class="sd">    The paths are computed with a breadth-first search (BFS) or Dijkstra&#39;s</span>
<span class="sd">    algorithm [dijkstra]_, if weights are given.</span>

<span class="sd">    The algorithm runs in :math:`O(V + E)` time, or :math:`O(V \log V)` if</span>
<span class="sd">    weights are given.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       import numpy.random</span>
<span class="sd">       numpy.random.seed(42)</span>
<span class="sd">       gt.seed_rng(42)</span>

<span class="sd">    &gt;&gt;&gt; from numpy.random import poisson</span>
<span class="sd">    &gt;&gt;&gt; g = gt.random_graph(300, lambda: (poisson(3), poisson(3)))</span>
<span class="sd">    &gt;&gt;&gt; dist, ends = gt.pseudo_diameter(g)</span>
<span class="sd">    &gt;&gt;&gt; print(dist)</span>
<span class="sd">    10.0</span>
<span class="sd">    &gt;&gt;&gt; print(int(ends[0]), int(ends[1]))</span>
<span class="sd">    0 165</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [pseudo-diameter] http://en.wikipedia.org/wiki/Distance_%28graph_theory%29</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">source</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">source</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">use_index</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="n">dist</span><span class="p">,</span> <span class="n">target</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">source</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">new_source</span> <span class="o">=</span> <span class="n">target</span>
        <span class="n">new_target</span><span class="p">,</span> <span class="n">new_dist</span> <span class="o">=</span> <span class="n">libgraph_tool_topology</span><span class="o">.</span><span class="n">get_diam</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span>
                                                               <span class="nb">int</span><span class="p">(</span><span class="n">new_source</span><span class="p">),</span>
                                                               <span class="n">_prop</span><span class="p">(</span><span class="s">&quot;e&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">weights</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">new_dist</span> <span class="o">&gt;</span> <span class="n">dist</span><span class="p">:</span>
            <span class="n">target</span> <span class="o">=</span> <span class="n">new_target</span>
            <span class="n">source</span> <span class="o">=</span> <span class="n">new_source</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">new_dist</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">break</span>
    <span class="k">return</span> <span class="n">dist</span><span class="p">,</span> <span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="n">source</span><span class="p">),</span> <span class="n">g</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="n">target</span><span class="p">))</span>

</div>
<div class="viewcode-block" id="is_bipartite"><a class="viewcode-back" href="../../topology.html#graph_tool.topology.is_bipartite">[docs]</a><span class="k">def</span> <span class="nf">is_bipartite</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">partition</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Test if the graph is bipartite.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    g : :class:`~graph_tool.Graph`</span>
<span class="sd">        Graph to be used.</span>
<span class="sd">    partition : bool (optional, default: ``False``)</span>
<span class="sd">        If ``True``, return the two partitions in case the graph is bipartite.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    is_bipartite : bool</span>
<span class="sd">        Whether or not the graph is bipartite.</span>
<span class="sd">    partition : :class:`~graph_tool.PropertyMap` (only if `partition=True`)</span>
<span class="sd">        A vertex property map with the graph partitioning (or `None`) if the</span>
<span class="sd">        graph is not bipartite.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    An undirected graph is bipartite if one can partition its set of vertices</span>
<span class="sd">    into two sets, such that all edges go from one set to the other.</span>

<span class="sd">    This algorithm runs in :math:`O(V + E)` time.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; g = gt.lattice([10, 10])</span>
<span class="sd">    &gt;&gt;&gt; is_bi, part = gt.is_bipartite(g, partition=True)</span>
<span class="sd">    &gt;&gt;&gt; print(is_bi)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; gt.graph_draw(g, vertex_fill_color=part, output_size=(300, 300), output=&quot;bipartite.pdf&quot;)</span>
<span class="sd">    &lt;...&gt;</span>

<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       gt.graph_draw(g, vertex_fill_color=part, output_size=(300, 300), output=&quot;bipartite.png&quot;)</span>

<span class="sd">    .. figure:: bipartite.*</span>
<span class="sd">        :align: center</span>

<span class="sd">        Bipartition of a 2D lattice.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [boost-bipartite] http://www.boost.org/libs/graph/doc/is_bipartite.html</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">partition</span><span class="p">:</span>
        <span class="n">part</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="s">&quot;bool&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">part</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">GraphView</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="n">is_bi</span> <span class="o">=</span> <span class="n">libgraph_tool_topology</span><span class="o">.</span><span class="n">is_bipartite</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span>
                                                <span class="n">_prop</span><span class="p">(</span><span class="s">&quot;v&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">part</span><span class="p">))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_bi</span> <span class="ow">and</span> <span class="n">part</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">part</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="n">partition</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">is_bi</span><span class="p">,</span> <span class="n">part</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">is_bi</span>

</div>
<div class="viewcode-block" id="is_planar"><a class="viewcode-back" href="../../topology.html#graph_tool.topology.is_planar">[docs]</a><span class="k">def</span> <span class="nf">is_planar</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">embedding</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">kuratowski</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Test if the graph is planar.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    g : :class:`~graph_tool.Graph`</span>
<span class="sd">        Graph to be used.</span>
<span class="sd">    embedding : bool (optional, default: False)</span>
<span class="sd">        If true, return a mapping from vertices to the clockwise order of</span>
<span class="sd">        out-edges in the planar embedding.</span>
<span class="sd">    kuratowski : bool (optional, default: False)</span>
<span class="sd">        If true, the minimal set of edges that form the obstructing Kuratowski</span>
<span class="sd">        subgraph will be returned as a property map, if the graph is not planar.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    is_planar : bool</span>
<span class="sd">        Whether or not the graph is planar.</span>
<span class="sd">    embedding : :class:`~graph_tool.PropertyMap` (only if `embedding=True`)</span>
<span class="sd">        A vertex property map with the out-edges indexes in clockwise order in</span>
<span class="sd">        the planar embedding,</span>
<span class="sd">    kuratowski : :class:`~graph_tool.PropertyMap` (only if `kuratowski=True`)</span>
<span class="sd">        An edge property map with the minimal set of edges that form the</span>
<span class="sd">        obstructing Kuratowski subgraph (if the value of kuratowski[e] is 1,</span>
<span class="sd">        the edge belongs to the set)</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    A graph is planar if it can be drawn in two-dimensional space without any of</span>
<span class="sd">    its edges crossing. This algorithm performs the Boyer-Myrvold planarity</span>
<span class="sd">    testing [boyer-myrvold]_. See [boost-planarity]_ for more details.</span>

<span class="sd">    This algorithm runs in :math:`O(V)` time.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       import numpy.random</span>
<span class="sd">       numpy.random.seed(42)</span>
<span class="sd">       gt.seed_rng(42)</span>

<span class="sd">    &gt;&gt;&gt; from numpy.random import random</span>
<span class="sd">    &gt;&gt;&gt; g = gt.triangulation(random((100,2)))[0]</span>
<span class="sd">    &gt;&gt;&gt; p, embed_order = gt.is_planar(g, embedding=True)</span>
<span class="sd">    &gt;&gt;&gt; print(p)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; print(list(embed_order[g.vertex(0)]))</span>
<span class="sd">    [0, 1, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2]</span>
<span class="sd">    &gt;&gt;&gt; g = gt.random_graph(100, lambda: 4, directed=False)</span>
<span class="sd">    &gt;&gt;&gt; p, kur = gt.is_planar(g, kuratowski=True)</span>
<span class="sd">    &gt;&gt;&gt; print(p)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; g.set_edge_filter(kur, True)</span>
<span class="sd">    &gt;&gt;&gt; gt.graph_draw(g, output_size=(300, 300), output=&quot;kuratowski.pdf&quot;)</span>
<span class="sd">    &lt;...&gt;</span>

<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       gt.graph_draw(g, output_size=(300, 300), output=&quot;kuratowski.png&quot;)</span>

<span class="sd">    .. figure:: kuratowski.*</span>
<span class="sd">        :align: center</span>

<span class="sd">        Obstructing Kuratowski subgraph of a random graph.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [boyer-myrvold] John M. Boyer and Wendy J. Myrvold, &quot;On the Cutting Edge:</span>
<span class="sd">       Simplified O(n) Planarity by Edge Addition&quot; Journal of Graph Algorithms</span>
<span class="sd">       and Applications, 8(2): 241-273, 2004. http://www.emis.ams.org/journals/JGAA/accepted/2004/BoyerMyrvold2004.8.3.pdf</span>
<span class="sd">    .. [boost-planarity] http://www.boost.org/libs/graph/doc/boyer_myrvold.html</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">u</span> <span class="o">=</span> <span class="n">GraphView</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">embedding</span><span class="p">:</span>
        <span class="n">embed</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="s">&quot;vector&lt;int&gt;&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">embed</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">if</span> <span class="n">kuratowski</span><span class="p">:</span>
        <span class="n">kur</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_edge_property</span><span class="p">(</span><span class="s">&quot;bool&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">kur</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="n">is_planar</span> <span class="o">=</span> <span class="n">libgraph_tool_topology</span><span class="o">.</span><span class="n">is_planar</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span>
                                                 <span class="n">_prop</span><span class="p">(</span><span class="s">&quot;v&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">embed</span><span class="p">),</span>
                                                 <span class="n">_prop</span><span class="p">(</span><span class="s">&quot;e&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">kur</span><span class="p">))</span>

    <span class="n">ret</span> <span class="o">=</span> <span class="p">[</span><span class="n">is_planar</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">embed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">embed</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">kur</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">kur</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="make_maximal_planar"><a class="viewcode-back" href="../../topology.html#graph_tool.topology.make_maximal_planar">[docs]</a><span class="k">def</span> <span class="nf">make_maximal_planar</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">unfilter</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Add edges to the graph to make it maximally planar.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    g : :class:`~graph_tool.Graph`</span>
<span class="sd">        Graph to be used. It must be a biconnected planar graph with at least 3</span>
<span class="sd">        vertices.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    A graph is maximal planar if no additional edges can be added to it without</span>
<span class="sd">    creating a non-planar graph. By Euler&#39;s formula, a maximal planar graph with</span>
<span class="sd">    V &gt; 2 vertices always has 3V - 6 edges and 2V - 4 faces.</span>

<span class="sd">    The input graph to make_maximal_planar() must be a biconnected planar graph</span>
<span class="sd">    with at least 3 vertices.</span>

<span class="sd">    This algorithm runs in :math:`O(V + E)` time.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; g = gt.lattice([42, 42])</span>
<span class="sd">    &gt;&gt;&gt; gt.make_maximal_planar(g)</span>
<span class="sd">    &gt;&gt;&gt; gt.is_planar(g)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; print(g.num_vertices(), g.num_edges())</span>
<span class="sd">    1764 5286</span>
<span class="sd">    &gt;&gt;&gt; gt.graph_draw(g, output_size=(300, 300), output=&quot;maximal_planar.pdf&quot;)</span>
<span class="sd">    &lt;...&gt;</span>

<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       gt.graph_draw(g, output_size=(300, 300), output=&quot;maximal_planar.png&quot;)</span>

<span class="sd">    .. figure:: maximal_planar.*</span>
<span class="sd">        :align: center</span>

<span class="sd">        A maximally planar graph.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [boost-planarity] http://www.boost.org/libs/graph/doc/make_maximal_planar.html</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">g</span> <span class="o">=</span> <span class="n">GraphView</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="n">libgraph_tool_topology</span><span class="o">.</span><span class="n">maximal_planar</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="is_DAG"><a class="viewcode-back" href="../../topology.html#graph_tool.topology.is_DAG">[docs]</a><span class="k">def</span> <span class="nf">is_DAG</span><span class="p">(</span><span class="n">g</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return `True` if the graph is a directed acyclic graph (DAG).</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The time complexity is :math:`O(V + E)`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       import numpy.random</span>
<span class="sd">       numpy.random.seed(42)</span>
<span class="sd">       gt.seed_rng(42)</span>

<span class="sd">    &gt;&gt;&gt; g = gt.random_graph(30, lambda: (3, 3))</span>
<span class="sd">    &gt;&gt;&gt; print(gt.is_DAG(g))</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; tree = gt.min_spanning_tree(g)</span>
<span class="sd">    &gt;&gt;&gt; g.set_edge_filter(tree)</span>
<span class="sd">    &gt;&gt;&gt; print(gt.is_DAG(g))</span>
<span class="sd">    True</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [DAG-wiki] http://en.wikipedia.org/wiki/Directed_acyclic_graph</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">topological_order</span> <span class="o">=</span> <span class="n">Vector_int32_t</span><span class="p">()</span>
    <span class="n">is_DAG</span> <span class="o">=</span> <span class="n">libgraph_tool_topology</span><span class="o">.</span>\
        <span class="n">topological_sort</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span> <span class="n">topological_order</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">is_DAG</span>

</div>
<div class="viewcode-block" id="max_cardinality_matching"><a class="viewcode-back" href="../../topology.html#graph_tool.topology.max_cardinality_matching">[docs]</a><span class="k">def</span> <span class="nf">max_cardinality_matching</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">heuristic</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">minimize</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                             <span class="n">match</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;Find a maximum cardinality matching in the graph.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    g : :class:`~graph_tool.Graph`</span>
<span class="sd">        Graph to be used.</span>
<span class="sd">    heuristic : bool (optional, default: `False`)</span>
<span class="sd">        If true, a random heuristic will be used, which runs in linear time.</span>
<span class="sd">    weight : :class:`~graph_tool.PropertyMap` (optional, default: `None`)</span>
<span class="sd">        If provided, the matching will minimize the edge weights (or maximize</span>
<span class="sd">        if ``minimize == False``). This option has no effect if</span>
<span class="sd">        ``heuristic == False``.</span>
<span class="sd">    minimize : bool (optional, default: `True`)</span>
<span class="sd">        If `True`, the matching will minimize the weights, otherwise they will</span>
<span class="sd">        be maximized. This option has no effect if ``heuristic == False``.</span>
<span class="sd">    match : :class:`~graph_tool.PropertyMap` (optional, default: `None`)</span>
<span class="sd">        Edge property map where the matching will be specified.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    match : :class:`~graph_tool.PropertyMap`</span>
<span class="sd">        Boolean edge property map where the matching is specified.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    A *matching* is a subset of the edges of a graph such that no two edges</span>
<span class="sd">    share a common vertex. A *maximum cardinality matching* has maximum size</span>
<span class="sd">    over all matchings in the graph.</span>

<span class="sd">    If the parameter ``weight`` is provided, as well as ``heuristic == True`` a</span>
<span class="sd">    matching with maximum cardinality *and* maximum (or minimum) weight is</span>
<span class="sd">    returned.</span>

<span class="sd">    If ``heuristic == True`` the algorithm does not necessarily return the</span>
<span class="sd">    maximum matching, instead the focus is to run on linear time.</span>

<span class="sd">    This algorithm runs in time :math:`O(EV\times\alpha(E,V))`, where</span>
<span class="sd">    :math:`\alpha(m,n)` is a slow growing function that is at most 4 for any</span>
<span class="sd">    feasible input. If `heuristic == True`, the algorithm runs in time</span>
<span class="sd">    :math:`O(V + E)`.</span>

<span class="sd">    For a more detailed description, see [boost-max-matching]_.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       numpy.random.seed(43)</span>
<span class="sd">       gt.seed_rng(43)</span>

<span class="sd">    &gt;&gt;&gt; g = gt.GraphView(gt.price_network(300), directed=False)</span>
<span class="sd">    &gt;&gt;&gt; res = gt.max_cardinality_matching(g)</span>
<span class="sd">    &gt;&gt;&gt; print(res[1])</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; w = res[0].copy(&quot;double&quot;)</span>
<span class="sd">    &gt;&gt;&gt; w.a = 2 * w.a + 2</span>
<span class="sd">    &gt;&gt;&gt; gt.graph_draw(g, edge_color=res[0], edge_pen_width=w, vertex_fill_color=&quot;grey&quot;,</span>
<span class="sd">    ...               output=&quot;max_card_match.pdf&quot;)</span>
<span class="sd">    &lt;...&gt;</span>

<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       gt.graph_draw(g, edge_color=res[0], edge_pen_width=w, vertex_fill_color=&quot;grey&quot;,</span>
<span class="sd">                     output=&quot;max_card_match.png&quot;)</span>

<span class="sd">    .. figure:: max_card_match.*</span>
<span class="sd">        :align: center</span>

<span class="sd">        Edges belonging to the matching are in yellow.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [boost-max-matching] http://www.boost.org/libs/graph/doc/maximum_matching.html</span>
<span class="sd">    .. [matching-heuristic] B. Hendrickson and R. Leland. &quot;A Multilevel Algorithm</span>
<span class="sd">       for Partitioning Graphs.&quot; In S. Karin, editor, Proc. Supercomputing 95,</span>
<span class="sd">       San Diego. ACM Press, New York, 1995, :doi:`10.1145/224170.224228`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">match</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">match</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_edge_property</span><span class="p">(</span><span class="s">&quot;bool&quot;</span><span class="p">)</span>
    <span class="n">_check_prop_scalar</span><span class="p">(</span><span class="n">match</span><span class="p">,</span> <span class="s">&quot;match&quot;</span><span class="p">)</span>
    <span class="n">_check_prop_writable</span><span class="p">(</span><span class="n">match</span><span class="p">,</span> <span class="s">&quot;match&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">weight</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">_check_prop_scalar</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="s">&quot;weight&quot;</span><span class="p">)</span>

    <span class="n">u</span> <span class="o">=</span> <span class="n">GraphView</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">heuristic</span><span class="p">:</span>
        <span class="n">check</span> <span class="o">=</span> <span class="n">libgraph_tool_flow</span><span class="o">.</span>\
                <span class="n">max_cardinality_matching</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span> <span class="n">_prop</span><span class="p">(</span><span class="s">&quot;e&quot;</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">match</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">match</span><span class="p">,</span> <span class="n">check</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">libgraph_tool_topology</span><span class="o">.</span>\
                <span class="n">random_matching</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span> <span class="n">_prop</span><span class="p">(</span><span class="s">&quot;e&quot;</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">weight</span><span class="p">),</span>
                                 <span class="n">_prop</span><span class="p">(</span><span class="s">&quot;e&quot;</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">match</span><span class="p">),</span> <span class="n">minimize</span><span class="p">,</span> <span class="n">_get_rng</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">match</span>

</div>
<div class="viewcode-block" id="max_independent_vertex_set"><a class="viewcode-back" href="../../topology.html#graph_tool.topology.max_independent_vertex_set">[docs]</a><span class="k">def</span> <span class="nf">max_independent_vertex_set</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">high_deg</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">mivs</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;Find a maximal independent vertex set in the graph.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    g : :class:`~graph_tool.Graph`</span>
<span class="sd">        Graph to be used.</span>
<span class="sd">    high_deg : bool (optional, default: `False`)</span>
<span class="sd">        If `True`, vertices with high degree will be included first in the set,</span>
<span class="sd">        otherwise they will be included last.</span>
<span class="sd">    mivs : :class:`~graph_tool.PropertyMap` (optional, default: `None`)</span>
<span class="sd">        Vertex property map where the vertex set will be specified.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    mivs : :class:`~graph_tool.PropertyMap`</span>
<span class="sd">        Boolean vertex property map where the set is specified.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    A maximal independent vertex set is an independent set such that adding any</span>
<span class="sd">    other vertex to the set forces the set to contain an edge between two</span>
<span class="sd">    vertices of the set.</span>

<span class="sd">    This implements the algorithm described in [mivs-luby]_, which runs in time</span>
<span class="sd">    :math:`O(V + E)`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       numpy.random.seed(43)</span>
<span class="sd">       gt.seed_rng(43)</span>

<span class="sd">    &gt;&gt;&gt; g = gt.GraphView(gt.price_network(300), directed=False)</span>
<span class="sd">    &gt;&gt;&gt; res = gt.max_independent_vertex_set(g)</span>
<span class="sd">    &gt;&gt;&gt; gt.graph_draw(g, vertex_fill_color=res, output=&quot;mivs.pdf&quot;)</span>
<span class="sd">    &lt;...&gt;</span>

<span class="sd">    .. testcode::</span>
<span class="sd">       :hide:</span>

<span class="sd">       gt.graph_draw(g, vertex_fill_color=res, output=&quot;mivs.png&quot;)</span>

<span class="sd">    .. figure:: mivs.*</span>
<span class="sd">        :align: center</span>

<span class="sd">        Vertices belonging to the set are in yellow.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [mivs-wikipedia] http://en.wikipedia.org/wiki/Independent_set_%28graph_theory%29</span>
<span class="sd">    .. [mivs-luby] Luby, M., &quot;A simple parallel algorithm for the maximal independent set problem&quot;,</span>
<span class="sd">       Proc. 17th Symposium on Theory of Computing, Association for Computing Machinery, pp. 1-10, (1985)</span>
<span class="sd">       :doi:`10.1145/22145.22146`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">mivs</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">mivs</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="s">&quot;bool&quot;</span><span class="p">)</span>
    <span class="n">_check_prop_scalar</span><span class="p">(</span><span class="n">mivs</span><span class="p">,</span> <span class="s">&quot;mivs&quot;</span><span class="p">)</span>
    <span class="n">_check_prop_writable</span><span class="p">(</span><span class="n">mivs</span><span class="p">,</span> <span class="s">&quot;mivs&quot;</span><span class="p">)</span>

    <span class="n">u</span> <span class="o">=</span> <span class="n">GraphView</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="n">libgraph_tool_topology</span><span class="o">.</span>\
        <span class="n">maximal_vertex_set</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span> <span class="n">_prop</span><span class="p">(</span><span class="s">&quot;v&quot;</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">mivs</span><span class="p">),</span> <span class="n">high_deg</span><span class="p">,</span>
                           <span class="n">_get_rng</span><span class="p">())</span>
    <span class="n">mivs</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">own_property</span><span class="p">(</span><span class="n">mivs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mivs</span>

</div>
<div class="viewcode-block" id="edge_reciprocity"><a class="viewcode-back" href="../../topology.html#graph_tool.topology.edge_reciprocity">[docs]</a><span class="k">def</span> <span class="nf">edge_reciprocity</span><span class="p">(</span><span class="n">g</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;Calculate the edge reciprocity of the graph.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    g : :class:`~graph_tool.Graph`</span>
<span class="sd">        Graph to be used</span>
<span class="sd">        edges.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    reciprocity : float</span>
<span class="sd">        The reciprocity value.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    The edge [reciprocity]_ is defined as :math:`E^\leftrightarrow/E`, where</span>
<span class="sd">    :math:`E^\leftrightarrow` and :math:`E` are the number of bidirectional and</span>
<span class="sd">    all edges in the graph, respectively.</span>

<span class="sd">    The algorithm runs with complexity :math:`O(E + V)`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    &gt;&gt;&gt; g = gt.Graph()</span>
<span class="sd">    &gt;&gt;&gt; g.add_vertex(2)</span>
<span class="sd">    &lt;...&gt;</span>
<span class="sd">    &gt;&gt;&gt; g.add_edge(g.vertex(0), g.vertex(1))</span>
<span class="sd">    &lt;Edge object with source &#39;0&#39; and target &#39;1&#39; at 0x33bc710&gt;</span>
<span class="sd">    &gt;&gt;&gt; gt.edge_reciprocity(g)</span>
<span class="sd">    0.0</span>
<span class="sd">    &gt;&gt;&gt; g.add_edge(g.vertex(1), g.vertex(0))</span>
<span class="sd">    &lt;Edge object with source &#39;1&#39; and target &#39;0&#39; at 0x33bc7a0&gt;</span>
<span class="sd">    &gt;&gt;&gt; gt.edge_reciprocity(g)</span>
<span class="sd">    1.0</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [reciprocity] S. Wasserman and K. Faust, &quot;Social Network Analysis&quot;.</span>
<span class="sd">       (Cambridge University Press, Cambridge, 1994)</span>
<span class="sd">    .. [lopez-reciprocity-2007] Gorka Zamora-Lpez, Vinko Zlati, Changsong Zhou, Hrvoje tefani, and Jrgen Kurths</span>
<span class="sd">       &quot;Reciprocity of networks with degree correlations and arbitrary degree sequences&quot;, Phys. Rev. E 77, 016106 (2008)</span>
<span class="sd">       :doi:`10.1103/PhysRevE.77.016106`, :arxiv:`0706.3372`</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">r</span> <span class="o">=</span> <span class="n">libgraph_tool_topology</span><span class="o">.</span><span class="n">reciprocity</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">r</span>

</div>
<div class="viewcode-block" id="tsp_tour"><a class="viewcode-back" href="../../topology.html#graph_tool.topology.tsp_tour">[docs]</a><span class="k">def</span> <span class="nf">tsp_tour</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a traveling salesman tour of the graph, which is guaranteed to be</span>
<span class="sd">    twice as long as the optimal tour in the worst case.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    g : :class:`~graph_tool.Graph`</span>
<span class="sd">        Graph to be used.</span>
<span class="sd">    src : :class:`~graph_tool.Vertex`</span>
<span class="sd">        The source (and target) of the tour.</span>
<span class="sd">    weight : :class:`~graph_tool.PropertyMap` (optional, default: None)</span>
<span class="sd">        Edge weights.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tour : :class:`numpy.ndarray`</span>
<span class="sd">        List of vertex indexes corresponding to the tour.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The algorithm runs with :math:`O(E\log V)` complexity.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; g = gt.lattice([10, 10])</span>
<span class="sd">    &gt;&gt;&gt; tour = gt.tsp_tour(g, g.vertex(0))</span>
<span class="sd">    &gt;&gt;&gt; print(tour)</span>
<span class="sd">    [ 0  1  2 11 12 21 22 31 32 41 42 51 52 61 62 71 72 81 82 83 73 84 74 85 75</span>
<span class="sd">     86 76 87 77 88 78 68 58 67 57 66 56 65 55 64 54 63 53 43 33 23 13  3  4  5</span>
<span class="sd">      6  7  8 89 79 69 59 49 39 48 38 47 37 46 36 45 35 44 34 24 14 25 15 26 16</span>
<span class="sd">     27 17 28 18 29 19  9 91 92 93 94 95 96 97 98 99 10 20 30 40 50 60 70 80 90</span>
<span class="sd">      0]</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [tsp-bgl] http://www.boost.org/libs/graph/doc/metric_tsp_approx.html</span>
<span class="sd">    .. [tsp] http://en.wikipedia.org/wiki/Travelling_salesman_problem</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">tour</span> <span class="o">=</span> <span class="n">libgraph_tool_topology</span><span class="o">.</span>\
        <span class="n">get_tsp</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">src</span><span class="p">),</span> <span class="n">_prop</span><span class="p">(</span><span class="s">&quot;e&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">weight</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">tour</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

</div>
<div class="viewcode-block" id="sequential_vertex_coloring"><a class="viewcode-back" href="../../topology.html#graph_tool.topology.sequential_vertex_coloring">[docs]</a><span class="k">def</span> <span class="nf">sequential_vertex_coloring</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns a vertex coloring of the graph.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    g : :class:`~graph_tool.Graph`</span>
<span class="sd">        Graph to be used.</span>
<span class="sd">    order : :class:`~graph_tool.PropertyMap` (optional, default: None)</span>
<span class="sd">        Order with which the vertices will be colored.</span>
<span class="sd">    color : :class:`~graph_tool.PropertyMap` (optional, default: None)</span>
<span class="sd">        Integer-valued vertex property map to store the colors.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    color : :class:`~graph_tool.PropertyMap`</span>
<span class="sd">        Integer-valued vertex property map with the vertex colors.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The time complexity is :math:`O(V(d+k))`, where :math:`V` is the number of</span>
<span class="sd">    vertices, :math:`d` is the maximum degree of the vertices in the graph, and</span>
<span class="sd">    :math:`k` is the number of colors used.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; g = gt.lattice([10, 10])</span>
<span class="sd">    &gt;&gt;&gt; colors = gt.sequential_vertex_coloring(g)</span>
<span class="sd">    &gt;&gt;&gt; print(colors.a)</span>
<span class="sd">    [0 1 0 1 0 1 0 1 0 1 1 0 1 0 1 0 1 0 1 0 0 1 0 1 0 1 0 1 0 1 1 0 1 0 1 0 1</span>
<span class="sd">     0 1 0 0 1 0 1 0 1 0 1 0 1 1 0 1 0 1 0 1 0 1 0 0 1 0 1 0 1 0 1 0 1 1 0 1 0</span>
<span class="sd">     1 0 1 0 1 0 0 1 0 1 0 1 0 1 0 1 1 0 1 0 1 0 1 0 1 0]</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [sgc-bgl] http://www.boost.org/libs/graph/doc/sequential_vertex_coloring.html</span>
<span class="sd">    .. [graph-coloring] http://en.wikipedia.org/wiki/Graph_coloring</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">order</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">order</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">vertex_index</span>
    <span class="k">if</span> <span class="n">color</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">color</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="s">&quot;int&quot;</span><span class="p">)</span>

    <span class="n">libgraph_tool_topology</span><span class="o">.</span>\
        <span class="n">sequential_coloring</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">_Graph__graph</span><span class="p">,</span>
                            <span class="n">_prop</span><span class="p">(</span><span class="s">&quot;v&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">order</span><span class="p">),</span>
                            <span class="n">_prop</span><span class="p">(</span><span class="s">&quot;v&quot;</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">color</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">color</span>

</div>
<span class="kn">from</span> <span class="nn">..</span> <span class="nn">flow</span> <span class="kn">import</span> <span class="n">libgraph_tool_flow</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">

<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
<!-- <a href="graph-tool.pdf">(Download PDF version)</a> -->

<p/>
Latest <a href="/doc/dev/">development version docs</a> are also available.

        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
    <li><img src="../../_static/graph-icon.png" alt="logo" style="margin-right: 5px; margin-bottom:-2px;" /><a href="/">Project Homepage</a> &raquo;</li>
    
        <li class="nav-item nav-item-0"><a href="../../index.html">graph-tool 2.2.44 documentation</a> &raquo;</li>

          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &raquo;</li>
          <li class="nav-item nav-item-2"><a href="../graph_tool.html" >graph_tool</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2015, Tiago de Paula Peixoto &lt;tiago@skewed.de&gt;.
      Last updated on Jul 02, 2015.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
  </body>
</html>