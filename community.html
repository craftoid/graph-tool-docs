<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>graph_tool.community - Community structure &mdash; graph-tool 2.2.44 documentation</title>
    
    <link rel="stylesheet" href="_static/gt_style.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '2.2.44',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/MathJax/MathJax.js?config=default"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within graph-tool 2.2.44 documentation"
          href="_static/opensearch.xml"/>
    <link rel="shortcut icon" href="_static/graph-icon.ico"/>
    <link rel="top" title="graph-tool 2.2.44 documentation" href="index.html" />
    <link rel="up" title="graph_tool - efficient graph analysis and manipulation" href="graph_tool.html" />
    <link rel="next" title="graph_tool.correlations - Correlations" href="correlations.html" />
    <link rel="prev" title="graph_tool.collection - Dataset collection" href="collection.html" />
    <script type="text/javascript">
      var _gaq = _gaq || [];
      var pluginUrl =
        '//www.google-analytics.com/plugins/ga/inpage_linkid.js';
      _gaq.push(['_require', 'inpage_linkid', pluginUrl]);
      _gaq.push(['_setAccount', 'UA-248813-2']);
      _gaq.push(['_setDomainName', '.skewed.de']);
      _gaq.push(['_trackPageview']);
      (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
     

  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="correlations.html" title="graph_tool.correlations - Correlations"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="collection.html" title="graph_tool.collection - Dataset collection"
             accesskey="P">previous</a> |</li>
    <li><img src="_static/graph-icon.png" alt="logo" style="margin-right: 5px; margin-bottom:-2px;" /><a href="/">Project Homepage</a> &raquo;</li>
    
        <li class="nav-item nav-item-0"><a href="index.html">graph-tool 2.2.44 documentation</a> &raquo;</li>

          <li class="nav-item nav-item-1"><a href="modules.html" >Module documentation</a> &raquo;</li>
          <li class="nav-item nav-item-2"><a href="graph_tool.html" accesskey="U">graph_tool - efficient graph analysis and manipulation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <span class="target" id="module-graph_tool.community"></span><div class="section" id="graph-tool-community-community-structure">
<h1><code class="docutils literal"><span class="pre">graph_tool.community</span></code> - Community structure<a class="headerlink" href="#graph-tool-community-community-structure" title="Permalink to this headline">¶</a></h1>
<p>This module contains algorithms for the computation of community structure on
graphs.</p>
<div class="section" id="stochastic-blockmodel-inference">
<h2>Stochastic blockmodel inference<a class="headerlink" href="#stochastic-blockmodel-inference" title="Permalink to this headline">¶</a></h2>
<div class="section" id="non-hierarchical-models">
<h3>Non-hierarchical models<a class="headerlink" href="#non-hierarchical-models" title="Permalink to this headline">¶</a></h3>
<div class="section" id="summary">
<h4>Summary<a class="headerlink" href="#summary" title="Permalink to this headline">¶</a></h4>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#graph_tool.community.minimize_blockmodel_dl" title="graph_tool.community.minimize_blockmodel_dl"><code class="xref py py-obj docutils literal"><span class="pre">minimize_blockmodel_dl</span></code></a></td>
<td>Find the block partition of an unspecified size which minimizes the description length of the network, according to the stochastic blockmodel ensemble which best describes it.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#graph_tool.community.BlockState" title="graph_tool.community.BlockState"><code class="xref py py-obj docutils literal"><span class="pre">BlockState</span></code></a></td>
<td>This class encapsulates the block state of a given graph.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#graph_tool.community.OverlapBlockState" title="graph_tool.community.OverlapBlockState"><code class="xref py py-obj docutils literal"><span class="pre">OverlapBlockState</span></code></a></td>
<td>This class encapsulates the overlapping block state of a given graph.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#graph_tool.community.CovariateBlockState" title="graph_tool.community.CovariateBlockState"><code class="xref py py-obj docutils literal"><span class="pre">CovariateBlockState</span></code></a></td>
<td>This class encapsulates the (possibly overlapping) block state of a given graph, where the edges are divided into discrete layers.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#graph_tool.community.mcmc_sweep" title="graph_tool.community.mcmc_sweep"><code class="xref py py-obj docutils literal"><span class="pre">mcmc_sweep</span></code></a></td>
<td>Performs a Markov chain Monte Carlo sweep on the network, to sample the block partition according to a probability <span class="math">\(\propto e^{-\beta \mathcal{S}_{t/c}}\)</span>, where <span class="math">\(\mathcal{S}_{t/c}\)</span> is the blockmodel entropy.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#graph_tool.community.MinimizeState" title="graph_tool.community.MinimizeState"><code class="xref py py-obj docutils literal"><span class="pre">MinimizeState</span></code></a></td>
<td>This object stores information regarding the current entropy minimization state, so that the algorithms can resume previously started runs.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#graph_tool.community.multilevel_minimize" title="graph_tool.community.multilevel_minimize"><code class="xref py py-obj docutils literal"><span class="pre">multilevel_minimize</span></code></a></td>
<td>Performs an agglomerative heuristic, which progressively merges blocks together (while allowing individual node moves) to achieve a good partition in <code class="docutils literal"><span class="pre">B</span></code> blocks.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#graph_tool.community.collect_vertex_marginals" title="graph_tool.community.collect_vertex_marginals"><code class="xref py py-obj docutils literal"><span class="pre">collect_vertex_marginals</span></code></a></td>
<td>Collect the vertex marginal histogram, which counts the number of times a node was assigned to a given block.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#graph_tool.community.collect_edge_marginals" title="graph_tool.community.collect_edge_marginals"><code class="xref py py-obj docutils literal"><span class="pre">collect_edge_marginals</span></code></a></td>
<td>Collect the edge marginal histogram, which counts the number of times the endpoints of each node have been assigned to a given block pair.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#graph_tool.community.mf_entropy" title="graph_tool.community.mf_entropy"><code class="xref py py-obj docutils literal"><span class="pre">mf_entropy</span></code></a></td>
<td>Compute the &#8220;mean field&#8221; entropy given the vertex block membership marginals.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#graph_tool.community.bethe_entropy" title="graph_tool.community.bethe_entropy"><code class="xref py py-obj docutils literal"><span class="pre">bethe_entropy</span></code></a></td>
<td>Compute the Bethe entropy given the edge block membership marginals.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#graph_tool.community.model_entropy" title="graph_tool.community.model_entropy"><code class="xref py py-obj docutils literal"><span class="pre">model_entropy</span></code></a></td>
<td>Computes the amount of information necessary for the parameters of the traditional blockmodel ensemble, for <code class="docutils literal"><span class="pre">B</span></code> blocks, <code class="docutils literal"><span class="pre">N</span></code> vertices, <code class="docutils literal"><span class="pre">E</span></code> edges, and either a directed or undirected graph.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#graph_tool.community.get_max_B" title="graph_tool.community.get_max_B"><code class="xref py py-obj docutils literal"><span class="pre">get_max_B</span></code></a></td>
<td>Return the maximum detectable number of blocks, obtained by minimizing:</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#graph_tool.community.get_akc" title="graph_tool.community.get_akc"><code class="xref py py-obj docutils literal"><span class="pre">get_akc</span></code></a></td>
<td>Return the minimum value of the average degree of the network, so that some block structure with <span class="math">\(B\)</span> blocks can be detected, according to the minimum description length criterion.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#graph_tool.community.condensation_graph" title="graph_tool.community.condensation_graph"><code class="xref py py-obj docutils literal"><span class="pre">condensation_graph</span></code></a></td>
<td>Obtain the condensation graph, where each vertex with the same &#8216;prop&#8217; value is condensed in one vertex.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#graph_tool.community.get_block_edge_gradient" title="graph_tool.community.get_block_edge_gradient"><code class="xref py py-obj docutils literal"><span class="pre">get_block_edge_gradient</span></code></a></td>
<td>Get edge gradients corresponding to the block membership at the endpoints of the edges given by the <code class="docutils literal"><span class="pre">be</span></code> edge property map.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="hierarchical-models">
<h3>Hierarchical models<a class="headerlink" href="#hierarchical-models" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id1">
<h4>Summary<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#graph_tool.community.minimize_nested_blockmodel_dl" title="graph_tool.community.minimize_nested_blockmodel_dl"><code class="xref py py-obj docutils literal"><span class="pre">minimize_nested_blockmodel_dl</span></code></a></td>
<td>Find the block hierarchy of an unspecified size which minimizes the description length of the network, according to the nested stochastic blockmodel ensemble which best describes it.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#graph_tool.community.NestedBlockState" title="graph_tool.community.NestedBlockState"><code class="xref py py-obj docutils literal"><span class="pre">NestedBlockState</span></code></a></td>
<td>This class encapsulates the nested block state of a given graph.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#graph_tool.community.NestedMinimizeState" title="graph_tool.community.NestedMinimizeState"><code class="xref py py-obj docutils literal"><span class="pre">NestedMinimizeState</span></code></a></td>
<td>This object stores information regarding the current entropy minimization state, so that the algorithms can resume previously started runs.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#graph_tool.community.init_nested_state" title="graph_tool.community.init_nested_state"><code class="xref py py-obj docutils literal"><span class="pre">init_nested_state</span></code></a></td>
<td>Initializes a nested block hierarchy with sizes given by <code class="docutils literal"><span class="pre">Bs</span></code>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#graph_tool.community.nested_mcmc_sweep" title="graph_tool.community.nested_mcmc_sweep"><code class="xref py py-obj docutils literal"><span class="pre">nested_mcmc_sweep</span></code></a></td>
<td>Performs a Markov chain Monte Carlo sweep on all levels of the hierarchy.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#graph_tool.community.nested_tree_sweep" title="graph_tool.community.nested_tree_sweep"><code class="xref py py-obj docutils literal"><span class="pre">nested_tree_sweep</span></code></a></td>
<td>Performs one greedy sweep in the entire hierarchy tree, attempting to decrease its description length.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#graph_tool.community.get_hierarchy_tree" title="graph_tool.community.get_hierarchy_tree"><code class="xref py py-obj docutils literal"><span class="pre">get_hierarchy_tree</span></code></a></td>
<td>Obtain the nested hierarchical levels as a tree.</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="section" id="modularity-based-community-detection">
<h2>Modularity-based community detection<a class="headerlink" href="#modularity-based-community-detection" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id2">
<h3>Summary<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#graph_tool.community.community_structure" title="graph_tool.community.community_structure"><code class="xref py py-obj docutils literal"><span class="pre">community_structure</span></code></a></td>
<td>Obtain the community structure for the given graph, using a Potts model approach, which is a generalization of modularity maximization).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#graph_tool.community.modularity" title="graph_tool.community.modularity"><code class="xref py py-obj docutils literal"><span class="pre">modularity</span></code></a></td>
<td>Calculate Newman&#8217;s modularity.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="contents">
<h2>Contents<a class="headerlink" href="#contents" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="graph_tool.community.minimize_blockmodel_dl">
<code class="descclassname">graph_tool.community.</code><code class="descname">minimize_blockmodel_dl</code><span class="sig-paren">(</span><em>g</em>, <em>deg_corr=True</em>, <em>overlap=False</em>, <em>ec=None</em>, <em>layers=False</em>, <em>confine_layers=False</em>, <em>nonoverlap_init=False</em>, <em>dl=True</em>, <em>multigraph=True</em>, <em>dense=False</em>, <em>sparse_heuristic=False</em>, <em>eweight=None</em>, <em>vweight=None</em>, <em>clabel=None</em>, <em>c=0</em>, <em>nsweeps=10</em>, <em>adaptive_sweeps=True</em>, <em>epsilon=0.001</em>, <em>anneal=(1.0</em>, <em>1.0)</em>, <em>greedy_cooling=True</em>, <em>sequential=True</em>, <em>parallel=False</em>, <em>r=2</em>, <em>nmerge_sweeps=10</em>, <em>max_B=None</em>, <em>min_B=None</em>, <em>mid_B=None</em>, <em>checkpoint=None</em>, <em>minimize_state=None</em>, <em>exhaustive=False</em>, <em>init_states=None</em>, <em>max_BE=None</em>, <em>verbose=False</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/community/blockmodel.html#minimize_blockmodel_dl"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.community.minimize_blockmodel_dl" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the block partition of an unspecified size which minimizes the description
length of the network, according to the stochastic blockmodel ensemble which
best describes it.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>g</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.Graph" title="graph_tool.Graph"><code class="xref py py-class docutils literal"><span class="pre">Graph</span></code></a></p>
<blockquote>
<div><p>Graph to be modelled.</p>
</div></blockquote>
<p><strong>deg_corr</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, the degree-corrected version of the blockmodel ensemble will
be assumed, otherwise the traditional variant will be used.</p>
</div></blockquote>
<p><strong>overlap</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, the mixed-membership version of the blockmodel will be used.</p>
</div></blockquote>
<p><strong>ec</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal"><span class="pre">PropertyMap</span></code></a> (optional, default: <code class="docutils literal"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>If provided, this should be an edge <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal"><span class="pre">PropertyMap</span></code></a>
containing edge covariates that will split the network in discrete
layers.</p>
</div></blockquote>
<p><strong>layers</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, and <cite>´ec`</cite> is not <code class="docutils literal"><span class="pre">None</span></code>, the &#8220;independent layers&#8221;
version of the model is used, instead of the &#8220;edge covariates&#8221; version.</p>
</div></blockquote>
<p><strong>confine_layers</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, and <cite>´ec`</cite> is not <code class="docutils literal"><span class="pre">None</span></code> and <code class="docutils literal"><span class="pre">overlap</span> <span class="pre">==</span> <span class="pre">True</span></code>, the
half edges will only be moved in such a way that inside each layer the
group membership remains non-overlapping.</p>
</div></blockquote>
<p><strong>nonoverlap_init</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, and <cite>´overlap==True`</cite>, the minimization starts by first
fitting the non-overlapping model, and using that as a starting state.</p>
</div></blockquote>
<p><strong>dl</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, the change in the whole description length will be
considered after each vertex move, not only the entropy.</p>
</div></blockquote>
<p><strong>multigraph</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, the multigraph entropy will be used.</p>
</div></blockquote>
<p><strong>dense</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, the &#8220;dense&#8221; variant of the entropy will be computed.</p>
</div></blockquote>
<p><strong>sparse_heuristic</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, the sparse entropy will be used to find the best partition,
but the dense entropy will be used to compare different partitions. This
has an effect only if <code class="docutils literal"><span class="pre">dense</span> <span class="pre">==</span> <span class="pre">True</span></code>.</p>
</div></blockquote>
<p><strong>eweight</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal"><span class="pre">PropertyMap</span></code></a> (optional, default: <code class="docutils literal"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>Edge multiplicities (for multigraphs or block graphs).</p>
</div></blockquote>
<p><strong>vweight</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal"><span class="pre">PropertyMap</span></code></a> (optional, default: <code class="docutils literal"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>Vertex multiplicities (for block graphs).</p>
</div></blockquote>
<p><strong>clabel</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal"><span class="pre">PropertyMap</span></code></a> (optional, default: <code class="docutils literal"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>Constraint labels on the vertices. If supplied, vertices with different
label values will not be clustered in the same group.</p>
</div></blockquote>
<p><strong>c</strong> : <code class="docutils literal"><span class="pre">float</span></code> (optional, default: <code class="docutils literal"><span class="pre">1.0</span></code>)</p>
<blockquote>
<div><p>This parameter specifies how often fully random moves are attempted,
instead of more likely moves based on the inferred block partition.
For <code class="docutils literal"><span class="pre">c</span> <span class="pre">==</span> <span class="pre">0</span></code>, no fully random moves are attempted, and for <code class="docutils literal"><span class="pre">c</span> <span class="pre">==</span> <span class="pre">inf</span></code>
they are always attempted.</p>
</div></blockquote>
<p><strong>nsweeps</strong> : <code class="docutils literal"><span class="pre">int</span></code> (optional, default: <code class="docutils literal"><span class="pre">10</span></code>)</p>
<blockquote>
<div><p>The number of sweeps done after each merge step to reach the local
minimum.</p>
</div></blockquote>
<p><strong>adaptive_sweeps</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, the number of sweeps necessary for the local minimum will
be estimated to be enough so that no more than <code class="docutils literal"><span class="pre">epsilon</span> <span class="pre">*</span> <span class="pre">N</span></code> nodes
changes their states in the last <code class="docutils literal"><span class="pre">nsweeps</span></code> sweeps.</p>
</div></blockquote>
<p><strong>epsilon</strong> : <code class="docutils literal"><span class="pre">float</span></code> (optional, default: <code class="docutils literal"><span class="pre">1e-3</span></code>)</p>
<blockquote>
<div><p>Converge criterion for <code class="docutils literal"><span class="pre">adaptive_sweeps</span></code>.</p>
</div></blockquote>
<p><strong>anneal</strong> : pair of <code class="docutils literal"><span class="pre">floats</span></code> (optional, default: <code class="docutils literal"><span class="pre">(1.,</span> <span class="pre">1.)</span></code>)</p>
<blockquote>
<div><p>The first value specifies the starting value for  <code class="docutils literal"><span class="pre">beta</span></code> of the MCMC
steps, and the second value is the factor which is multiplied to <code class="docutils literal"><span class="pre">beta</span></code>
after each estimated equilibration (according to <code class="docutils literal"><span class="pre">nsweeps</span></code> and
<code class="docutils literal"><span class="pre">adaptive_sweeps</span></code>).</p>
</div></blockquote>
<p><strong>greedy_cooling</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, the value of <code class="docutils literal"><span class="pre">beta</span></code> of the MCMC steps are kept at
infinity for all steps. Otherwise they change according to the <code class="docutils literal"><span class="pre">anneal</span></code>
parameter.</p>
</div></blockquote>
<p><strong>sequential</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, the move attempts on the vertices are done in sequential
random order. Otherwise a total of <cite>N</cite> moves attempts are made, where
<cite>N</cite> is the number of vertices, where each vertex can be selected with
equal probability.</p>
</div></blockquote>
<p><strong>parallel</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, the updates are performed in parallel (multiple
threads).</p>
</div></blockquote>
<p><strong>r</strong> : <code class="docutils literal"><span class="pre">float</span></code> (optional, default: <code class="docutils literal"><span class="pre">2.</span></code>)</p>
<blockquote>
<div><p>Agglomeration ratio for the merging steps. Each merge step will attempt
to find the best partition into <span class="math">\(B_{i-1} / r\)</span> blocks, where
<span class="math">\(B_{i-1}\)</span> is the number of blocks in the last step.</p>
</div></blockquote>
<p><strong>nmerge_sweeps</strong> : <cite>int</cite> (optional, default: <cite>10</cite>)</p>
<blockquote>
<div><p>The number of merge sweeps done, where in each sweep a better merge
candidate is searched for every block.</p>
</div></blockquote>
<p><strong>max_B</strong> : <code class="docutils literal"><span class="pre">int</span></code> (optional, default: <code class="docutils literal"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>Maximum number of blocks tried. If not supplied, it will be
automatically determined.</p>
</div></blockquote>
<p><strong>min_B</strong> : <code class="docutils literal"><span class="pre">int</span></code> (optional, default: <cite>1</cite>)</p>
<blockquote>
<div><p>Minimum number of blocks tried.</p>
</div></blockquote>
<p><strong>mid_B</strong> : <code class="docutils literal"><span class="pre">int</span></code> (optional, default: <code class="docutils literal"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>Middle of the range which brackets the minimum. If not supplied, will be
automatically determined.</p>
</div></blockquote>
<p><strong>checkpoint</strong> : function (optional, default: <code class="docutils literal"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>If provided, this function will be called after each call to
<a class="reference internal" href="#graph_tool.community.mcmc_sweep" title="graph_tool.community.mcmc_sweep"><code class="xref py py-func docutils literal"><span class="pre">mcmc_sweep()</span></code></a>. This can be used to store the current state, so it
can be continued later. The function must have the following signature:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">checkpoint</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">nmoves</span><span class="p">,</span> <span class="n">minimize_state</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>where <cite>state</cite> is either a <a class="reference internal" href="#graph_tool.community.BlockState" title="graph_tool.community.BlockState"><code class="xref py py-class docutils literal"><span class="pre">BlockState</span></code></a>
instance or <code class="docutils literal"><span class="pre">None</span></code>, <cite>L</cite> is the current description length, <cite>delta</cite> is
the entropy difference in the last MCMC sweep, and <cite>nmoves</cite> is the
number of accepted block membership moves. The <code class="docutils literal"><span class="pre">minimize_state</span></code>
argument is a <a class="reference internal" href="#graph_tool.community.MinimizeState" title="graph_tool.community.MinimizeState"><code class="xref py py-class docutils literal"><span class="pre">MinimizeState</span></code></a> instance
which specifies the current state of the algorithm, which can be stored
via <a class="reference external" href="http://docs.python.org/3/library/pickle.html#module-pickle" title="(in Python v3.4)"><code class="xref py py-mod docutils literal"><span class="pre">pickle</span></code></a>, and supplied via the <code class="docutils literal"><span class="pre">minimize_state</span></code> option below
to continue from an interrupted run.</p>
<p>This function will also be called when the MCMC has finished for the
current value of <span class="math">\(B\)</span>, in which case <code class="docutils literal"><span class="pre">state</span> <span class="pre">==</span> <span class="pre">None</span></code>, and the
remaining parameters will be zero, except the last.</p>
</div></blockquote>
<p><strong>minimize_state</strong> : <a class="reference internal" href="#graph_tool.community.MinimizeState" title="graph_tool.community.MinimizeState"><code class="xref py py-class docutils literal"><span class="pre">MinimizeState</span></code></a> (optional, default: <code class="docutils literal"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>If provided, this will specify an exact point of execution from which
the algorithm will continue. The expected object is a
<a class="reference internal" href="#graph_tool.community.MinimizeState" title="graph_tool.community.MinimizeState"><code class="xref py py-class docutils literal"><span class="pre">MinimizeState</span></code></a>
instance which will be passed to the callback of the <code class="docutils literal"><span class="pre">checkpoint</span></code>
option above, and  can be stored by <a class="reference external" href="http://docs.python.org/3/library/pickle.html#module-pickle" title="(in Python v3.4)"><code class="xref py py-mod docutils literal"><span class="pre">pickle</span></code></a>.</p>
</div></blockquote>
<p><strong>exhaustive</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, the best value of <code class="docutils literal"><span class="pre">B</span></code> will be found by testing all possible
values, instead of performing a bisection search.</p>
</div></blockquote>
<p><strong>init_states</strong> : <code class="docutils literal"><span class="pre">list</span></code> of <a class="reference internal" href="#graph_tool.community.BlockState" title="graph_tool.community.BlockState"><code class="xref py py-class docutils literal"><span class="pre">BlockState</span></code></a> or <a class="reference internal" href="#graph_tool.community.OverlapBlockState" title="graph_tool.community.OverlapBlockState"><code class="xref py py-class docutils literal"><span class="pre">OverlapBlockState</span></code></a> (optional, default: <code class="docutils literal"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>If provided, this list of block states will be used when performing the
minimization.</p>
</div></blockquote>
<p><strong>max_BE</strong> : <code class="docutils literal"><span class="pre">int</span></code> (optional, default: <code class="docutils literal"><span class="pre">1000</span></code>)</p>
<blockquote>
<div><p>If the number of blocks exceeds this number, a sparse representation of
the block graph is used, which is slightly less efficient, but uses less
memory,</p>
</div></blockquote>
<p><strong>verbose</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, verbose information is displayed.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>state</strong> : <a class="reference internal" href="#graph_tool.community.BlockState" title="graph_tool.community.BlockState"><code class="xref py py-class docutils literal"><span class="pre">BlockState</span></code></a> or <a class="reference internal" href="#graph_tool.community.OverlapBlockState" title="graph_tool.community.OverlapBlockState"><code class="xref py py-class docutils literal"><span class="pre">OverlapBlockState</span></code></a></p>
<blockquote class="last">
<div><p>The block state containing the best model fit.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This algorithm attempts to find a block partition of an unspecified size
which minimizes the description length of the network,</p>
<div class="math">
\[\Sigma_{t/c} = \mathcal{S}_{t/c} + \mathcal{L}_{t/c},\]</div>
<p>where <span class="math">\(\mathcal{S}_{t/c}\)</span> is the blockmodel entropy (as described in
the docstring of <a class="reference internal" href="#graph_tool.community.mcmc_sweep" title="graph_tool.community.mcmc_sweep"><code class="xref py py-func docutils literal"><span class="pre">mcmc_sweep()</span></code></a>, <a class="reference internal" href="#graph_tool.community.BlockState.entropy" title="graph_tool.community.BlockState.entropy"><code class="xref py py-meth docutils literal"><span class="pre">BlockState.entropy()</span></code></a>
<a class="reference internal" href="#graph_tool.community.OverlapBlockState.entropy" title="graph_tool.community.OverlapBlockState.entropy"><code class="xref py py-meth docutils literal"><span class="pre">OverlapBlockState.entropy()</span></code></a>) and <span class="math">\(\mathcal{L}_{t/c}\)</span> is the
information necessary to describe the model (as described in the docstring
of <a class="reference internal" href="#graph_tool.community.model_entropy" title="graph_tool.community.model_entropy"><code class="xref py py-func docutils literal"><span class="pre">model_entropy()</span></code></a>, <a class="reference internal" href="#graph_tool.community.BlockState.entropy" title="graph_tool.community.BlockState.entropy"><code class="xref py py-meth docutils literal"><span class="pre">BlockState.entropy()</span></code></a> and
<a class="reference internal" href="#graph_tool.community.OverlapBlockState.entropy" title="graph_tool.community.OverlapBlockState.entropy"><code class="xref py py-meth docutils literal"><span class="pre">OverlapBlockState.entropy()</span></code></a>).</p>
<p>The algorithm works by minimizing the entropy <span class="math">\(\mathcal{S}_{t/c}\)</span> for
specific values of <span class="math">\(B\)</span> via <a class="reference internal" href="#graph_tool.community.mcmc_sweep" title="graph_tool.community.mcmc_sweep"><code class="xref py py-func docutils literal"><span class="pre">mcmc_sweep()</span></code></a> (with <span class="math">\(\beta = 1\)</span>
and <span class="math">\(\beta\to\infty\)</span>), and minimizing <span class="math">\(\Sigma_{t/c}\)</span> via an
one-dimensional Fibonacci search on <span class="math">\(B\)</span>. See
<a class="reference internal" href="#id42" id="id3">[peixoto-parsimonious-2013]</a> and <a class="reference internal" href="#id69" id="id4">[peixoto-efficient-2014]</a> for more details.</p>
<p>This algorithm has a complexity of <span class="math">\(O(\tau N\ln^2 B_{\text{max}})\)</span>,
where <span class="math">\(N\)</span> is the number of nodes in the network, <span class="math">\(\tau\)</span> is the
mixing time of the MCMC, and <span class="math">\(B_{\text{max}}\)</span> is the maximum number of
blocks considered. If <span class="math">\(B_{\text{max}}\)</span> is not supplied, it is computed
as <span class="math">\(\sim\sqrt{E}\)</span> via <a class="reference internal" href="#graph_tool.community.get_max_B" title="graph_tool.community.get_max_B"><code class="xref py py-func docutils literal"><span class="pre">get_max_B()</span></code></a>, in which case the complexity
becomes <span class="math">\(O(\tau E\ln E)\)</span>.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="holland-stochastic-1983" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[holland-stochastic-1983]</td><td>Paul W. Holland, Kathryn Blackmond Laskey,
Samuel Leinhardt, &#8220;Stochastic blockmodels: First steps&#8221;,
Carnegie-Mellon University, Pittsburgh, PA 15213, U.S.A., <a class="reference external" href="http://dx.doi.org/10.1016/0378-8733(83)90021-7">DOI: 10.1016/0378-8733(83)90021-7</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="faust-blockmodels-1992" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[faust-blockmodels-1992]</td><td>Katherine Faust, and Stanley
Wasserman. &#8220;Blockmodels: Interpretation and Evaluation.&#8221; Social Networks
14, no. 1-2 (1992): 5-61. <a class="reference external" href="http://dx.doi.org/10.1016/0378-8733(92)90013-W">DOI: 10.1016/0378-8733(92)90013-W</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="karrer-stochastic-2011" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[karrer-stochastic-2011]</td><td>Brian Karrer, and M. E. J. Newman. &#8220;Stochastic
Blockmodels and Community Structure in Networks.&#8221; Physical Review E 83,
no. 1 (2011): 016107. <a class="reference external" href="http://dx.doi.org/10.1103/PhysRevE.83.016107">DOI: 10.1103/PhysRevE.83.016107</a>.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="peixoto-entropy-2012" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[peixoto-entropy-2012]</td><td>Tiago P. Peixoto &#8220;Entropy of Stochastic Blockmodel
Ensembles.&#8221; Physical Review E 85, no. 5 (2012): 056122. <a class="reference external" href="http://dx.doi.org/10.1103/PhysRevE.85.056122">DOI: 10.1103/PhysRevE.85.056122</a>,
<a class="reference external" href="http://arxiv.org/abs/1112.6028">arXiv: 1112.6028</a>.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="peixoto-parsimonious-2013" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[peixoto-parsimonious-2013]</td><td>Tiago P. Peixoto, &#8220;Parsimonious module inference in large networks&#8221;,
Phys. Rev. Lett. 110, 148701 (2013), <a class="reference external" href="http://dx.doi.org/10.1103/PhysRevLett.110.148701">DOI: 10.1103/PhysRevLett.110.148701</a>, <a class="reference external" href="http://arxiv.org/abs/1212.4794">arXiv: 1212.4794</a>.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="peixoto-efficient-2014" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[peixoto-efficient-2014]</td><td>Tiago P. Peixoto, &#8220;Efficient Monte Carlo and greedy
heuristic for the inference of stochastic block models&#8221;, Phys. Rev. E 89, 012804 (2014),
<a class="reference external" href="http://dx.doi.org/10.1103/PhysRevE.89.012804">DOI: 10.1103/PhysRevE.89.012804</a>, <a class="reference external" href="http://arxiv.org/abs/1310.4378">arXiv: 1310.4378</a>.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="peixoto-model-2015" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[peixoto-model-2015]</td><td>Tiago P. Peixoto, &#8220;Model selection and hypothesis
testing for large-scale network models with overlapping groups&#8221;,
Phys. Rev. X 5, 011033 (2015), <a class="reference external" href="http://dx.doi.org/10.1103/PhysRevX.5.011033">DOI: 10.1103/PhysRevX.5.011033</a>,
<a class="reference external" href="http://arxiv.org/abs/1409.3059">arXiv: 1409.3059</a>.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="peixoto-inferring-2015" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[peixoto-inferring-2015]</td><td>Tiago P. Peixoto, &#8220;Inferring the mesoscale
structure of layered, edge-valued and time-varying networks&#8221;,
<a class="reference external" href="http://arxiv.org/abs/1504.02381">arXiv: 1504.02381</a></td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s">&quot;polbooks&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">minimize_blockmodel_dl</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gt</span><span class="o">.</span><span class="n">graph_draw</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">g</span><span class="o">.</span><span class="n">vp</span><span class="p">[</span><span class="s">&quot;pos&quot;</span><span class="p">],</span> <span class="n">vertex_fill_color</span><span class="o">=</span><span class="n">b</span><span class="p">,</span> <span class="n">vertex_shape</span><span class="o">=</span><span class="n">b</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s">&quot;polbooks_blocks_mdl.pdf&quot;</span><span class="p">)</span>
<span class="go">&lt;...&gt;</span>
</pre></div>
</div>
<div class="figure align-center" id="id88">
<img alt="_images/polbooks_blocks_mdl.png" src="_images/polbooks_blocks_mdl.png" />
<p class="caption"><span class="caption-text">Block partition of a political books network, which minimizes the description
length of the network according to the degree-corrected stochastic blockmodel.</span></p>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s">&quot;polbooks&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">minimize_blockmodel_dl</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">overlap</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bv</span><span class="p">,</span> <span class="o">*</span><span class="n">rest</span><span class="p">,</span> <span class="n">bc</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">get_overlap_blocks</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eg</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">get_block_edge_gradient</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">state</span><span class="o">.</span><span class="n">get_edge_blocks</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gt</span><span class="o">.</span><span class="n">graph_draw</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">vp</span><span class="p">[</span><span class="s">&quot;pos&quot;</span><span class="p">],</span> <span class="n">vertex_pie_fractions</span><span class="o">=</span><span class="n">bc</span><span class="p">,</span>
<span class="gp">... </span>              <span class="n">vertex_pie_colors</span><span class="o">=</span><span class="n">bv</span><span class="p">,</span> <span class="n">vertex_shape</span><span class="o">=</span><span class="s">&quot;pie&quot;</span><span class="p">,</span>
<span class="gp">... </span>              <span class="n">edge_gradient</span><span class="o">=</span><span class="n">eg</span><span class="p">,</span>
<span class="gp">... </span>              <span class="n">output</span><span class="o">=</span><span class="s">&quot;polbooks_overlap_blocks_mdl.pdf&quot;</span><span class="p">)</span>
<span class="go">&lt;...&gt;</span>
</pre></div>
</div>
<div class="figure align-center" id="id89">
<img alt="_images/polbooks_overlap_blocks_mdl.png" src="_images/polbooks_overlap_blocks_mdl.png" />
<p class="caption"><span class="caption-text">Overlapping partition of a political books network, which minimizes the
description length of the network according to the overlapping
degree-corrected stochastic blockmodel.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="graph_tool.community.BlockState">
<em class="property">class </em><code class="descclassname">graph_tool.community.</code><code class="descname">BlockState</code><span class="sig-paren">(</span><em>g</em>, <em>eweight=None</em>, <em>vweight=None</em>, <em>b=None</em>, <em>B=None</em>, <em>clabel=None</em>, <em>deg_corr=True</em>, <em>max_BE=1000</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/community/blockmodel.html#BlockState"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.community.BlockState" title="Permalink to this definition">¶</a></dt>
<dd><p>This class encapsulates the block state of a given graph.</p>
<p>This must be instantiated and used by functions such as <a class="reference internal" href="#graph_tool.community.mcmc_sweep" title="graph_tool.community.mcmc_sweep"><code class="xref py py-func docutils literal"><span class="pre">mcmc_sweep()</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>g</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.Graph" title="graph_tool.Graph"><code class="xref py py-class docutils literal"><span class="pre">Graph</span></code></a></p>
<blockquote>
<div><p>Graph to be modelled.</p>
</div></blockquote>
<p><strong>eweight</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal"><span class="pre">PropertyMap</span></code></a> (optional, default: <code class="docutils literal"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>Edge multiplicities (for multigraphs or block graphs).</p>
</div></blockquote>
<p><strong>vweight</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal"><span class="pre">PropertyMap</span></code></a> (optional, default: <code class="docutils literal"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>Vertex multiplicities (for block graphs).</p>
</div></blockquote>
<p><strong>b</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal"><span class="pre">PropertyMap</span></code></a> (optional, default: <code class="docutils literal"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>Initial block labels on the vertices. If not supplied, it will be
randomly sampled.</p>
</div></blockquote>
<p><strong>B</strong> : <code class="docutils literal"><span class="pre">int</span></code> (optional, default: <code class="docutils literal"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>Number of blocks. If not supplied it will be either obtained from the
parameter <code class="docutils literal"><span class="pre">b</span></code>, or set to the maximum possible value according to the
minimum description length.</p>
</div></blockquote>
<p><strong>clabel</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal"><span class="pre">PropertyMap</span></code></a> (optional, default: <code class="docutils literal"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>Constraint labels on the vertices. If supplied, vertices with different
label values will not be clustered in the same group.</p>
</div></blockquote>
<p><strong>deg_corr</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, the degree-corrected version of the blockmodel ensemble will
be assumed, otherwise the traditional variant will be used.</p>
</div></blockquote>
<p><strong>max_BE</strong> : <code class="docutils literal"><span class="pre">int</span></code> (optional, default: <code class="docutils literal"><span class="pre">1000</span></code>)</p>
<blockquote class="last">
<div><p>If the number of blocks exceeds this number, a sparse representation of
the block graph is used, which is slightly less efficient, but uses less
memory,</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="graph_tool.community.BlockState.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>b=None</em>, <em>B=None</em>, <em>deg_corr=None</em>, <em>clabel=None</em>, <em>overlap=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/community/blockmodel.html#BlockState.copy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.community.BlockState.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Copies the block state. The parameters override the state properties, and
have the same meaning as in the constructor. If <code class="docutils literal"><span class="pre">overlap=True</span></code> an
instance of <a class="reference internal" href="#graph_tool.community.OverlapBlockState" title="graph_tool.community.OverlapBlockState"><code class="xref py py-class docutils literal"><span class="pre">OverlapBlockState</span></code></a> is
returned.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.community.BlockState.get_block_state">
<code class="descname">get_block_state</code><span class="sig-paren">(</span><em>b=None</em>, <em>vweight=False</em>, <em>deg_corr=False</em>, <em>overlap=False</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/community/blockmodel.html#BlockState.get_block_state"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.community.BlockState.get_block_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a <code class="xref py py-class docutils literal"><span class="pre">BlockState`</span></code> corresponding to the
block graph. The parameters have the same meaning as the in the constructor.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.community.BlockState.get_bclabel">
<code class="descname">get_bclabel</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/community/blockmodel.html#BlockState.get_bclabel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.community.BlockState.get_bclabel" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a <code class="xref py py-class docutils literal"><span class="pre">PropertyMap`</span></code> corresponding to constraint
labels for the block graph.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.community.BlockState.get_blocks">
<code class="descname">get_blocks</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/community/blockmodel.html#BlockState.get_blocks"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.community.BlockState.get_blocks" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the property map which contains the block labels for each vertex.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.community.BlockState.get_bg">
<code class="descname">get_bg</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/community/blockmodel.html#BlockState.get_bg"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.community.BlockState.get_bg" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the block graph.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.community.BlockState.get_ers">
<code class="descname">get_ers</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/community/blockmodel.html#BlockState.get_ers"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.community.BlockState.get_ers" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the edge property map of the block graph which contains the <span class="math">\(e_{rs}\)</span> matrix entries.
For undirected graphs, the diagonal values (self-loops) contain <span class="math">\(e_{rr}/2\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.community.BlockState.get_er">
<code class="descname">get_er</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/community/blockmodel.html#BlockState.get_er"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.community.BlockState.get_er" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the vertex property map of the block graph which contains the number
<span class="math">\(e_r\)</span> of half-edges incident on block <span class="math">\(r\)</span>. If the graph is
directed, a pair of property maps is returned, with the number of
out-edges <span class="math">\(e^+_r\)</span> and in-edges <span class="math">\(e^-_r\)</span>, respectively.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.community.BlockState.get_nr">
<code class="descname">get_nr</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/community/blockmodel.html#BlockState.get_nr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.community.BlockState.get_nr" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the vertex property map of the block graph which contains the block sizes <span class="math">\(n_r\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.community.BlockState.entropy">
<code class="descname">entropy</code><span class="sig-paren">(</span><em>complete=True</em>, <em>dl=False</em>, <em>partition_dl=True</em>, <em>degree_dl=True</em>, <em>edges_dl=True</em>, <em>dense=False</em>, <em>multigraph=True</em>, <em>norm=False</em>, <em>dl_ent=False</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/community/blockmodel.html#BlockState.entropy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.community.BlockState.entropy" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the entropy associated with the current block partition.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>complete</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, the complete entropy will be returned, including constant
terms not relevant to the block partition.</p>
</div></blockquote>
<p><strong>dl</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, the full description length will be returned.</p>
</div></blockquote>
<p><strong>partition_dl</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, and <code class="docutils literal"><span class="pre">dl</span> <span class="pre">==</span> <span class="pre">True</span></code> the partition description length
will be considered.</p>
</div></blockquote>
<p><strong>edges_dl</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, and <code class="docutils literal"><span class="pre">dl</span> <span class="pre">==</span> <span class="pre">True</span></code> the edge matrix description length
will be considered.</p>
</div></blockquote>
<p><strong>degree_dl</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, and <code class="docutils literal"><span class="pre">dl</span> <span class="pre">==</span> <span class="pre">True</span></code> the degree sequence description
length will be considered.</p>
</div></blockquote>
<p><strong>dense</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, the &#8220;dense&#8221; variant of the entropy will be computed.</p>
</div></blockquote>
<p><strong>multigraph</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, the multigraph entropy will be used.</p>
</div></blockquote>
<p><strong>norm</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, the entropy will be &#8220;normalized&#8221; by dividing by the
number of edges.</p>
</div></blockquote>
<p><strong>dl_ent</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">False</span></code>)</p>
<blockquote class="last">
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, the description length of the degree sequence will be
approximated by its entropy.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>For the traditional blockmodel (<code class="docutils literal"><span class="pre">deg_corr</span> <span class="pre">==</span> <span class="pre">False</span></code>), the entropy is
given by</p>
<div class="math">
\[\begin{split}\mathcal{S}_t &amp;\cong E - \frac{1}{2} \sum_{rs}e_{rs}\ln\left(\frac{e_{rs}}{n_rn_s}\right), \\
\mathcal{S}^d_t &amp;\cong E - \sum_{rs}e_{rs}\ln\left(\frac{e_{rs}}{n_rn_s}\right),\end{split}\]</div>
<p>for undirected and directed graphs, respectively, where <span class="math">\(e_{rs}\)</span>
is the number of edges from block <span class="math">\(r\)</span> to <span class="math">\(s\)</span> (or the number
of half-edges for the undirected case when <span class="math">\(r=s\)</span>), and <span class="math">\(n_r\)</span>
is the number of vertices in block <span class="math">\(r\)</span> .</p>
<p>For the degree-corrected variant with &#8220;hard&#8221; degree constraints the
equivalent expressions are</p>
<div class="math">
\[\begin{split}\mathcal{S}_c &amp;\cong -E -\sum_kN_k\ln k! - \frac{1}{2} \sum_{rs}e_{rs}\ln\left(\frac{e_{rs}}{e_re_s}\right), \\
\mathcal{S}^d_c &amp;\cong -E -\sum_{k^+}N_{k^+}\ln k^+!  -\sum_{k^-}N_{k^-}\ln k^-! - \sum_{rs}e_{rs}\ln\left(\frac{e_{rs}}{e^+_re^-_s}\right),\end{split}\]</div>
<p>where <span class="math">\(e_r = \sum_se_{rs}\)</span> is the number of half-edges incident on
block <span class="math">\(r\)</span>, and <span class="math">\(e^+_r = \sum_se_{rs}\)</span> and <span class="math">\(e^-_r =
\sum_se_{sr}\)</span> are the numbers of out- and in-edges adjacent to block
<span class="math">\(r\)</span>, respectively.</p>
<p>If <code class="docutils literal"><span class="pre">dense</span> <span class="pre">==</span> <span class="pre">False</span></code> and <code class="docutils literal"><span class="pre">multigraph</span> <span class="pre">==</span> <span class="pre">True</span></code>, the entropy used will
be of the &#8220;Poisson&#8221; model, with the additional term:</p>
<div class="math">
\[\begin{split}{\mathcal{S}_{cm}^{(d)}} = \mathcal{S}_c^{(d)} + \sum_{i&gt;j} \ln A_{ij}! + \sum_i \ln A_{ii}!!\end{split}\]</div>
<p>If <code class="docutils literal"><span class="pre">dl</span> <span class="pre">==</span> <span class="pre">True</span></code>, the description length <span class="math">\(\mathcal{L}_t\)</span> of the
model will be returned as well, as described in
<a class="reference internal" href="#graph_tool.community.model_entropy" title="graph_tool.community.model_entropy"><code class="xref py py-func docutils literal"><span class="pre">model_entropy()</span></code></a>. Note that for the degree-corrected version the
description length is</p>
<div class="math">
\[\mathcal{L}_c = \mathcal{L}_t + \sum_r\min\left(\mathcal{L}^{(1)}_r, \mathcal{L}^{(2)}_r\right),\]</div>
<p>with</p>
<div class="math">
\[\begin{split}\mathcal{L}^{(1)}_r &amp;= \ln{\left(\!\!{n_r \choose e_r}\!\!\right)}, \\
\mathcal{L}^{(2)}_r &amp;= \ln\Xi_r + \ln n_r! - \sum_k \ln n^r_k!,\end{split}\]</div>
<p>and <span class="math">\(\ln\Xi_r \simeq 2\sqrt{\zeta(2)e_r}\)</span>, where <span class="math">\(\zeta(x)\)</span>
is the <a class="reference external" href="https://en.wikipedia.org/wiki/Riemann_zeta_function">Riemann zeta function</a>, and
<span class="math">\(n^r_k\)</span> is the number of nodes in block <span class="math">\(r\)</span> with degree
<span class="math">\(k\)</span>. For directed graphs we have instead <span class="math">\(k \to (k^-, k^+)\)</span>,
and <span class="math">\(\ln\Xi_r \to \ln\Xi^+_r + \ln\Xi^-_r\)</span> with <span class="math">\(\ln\Xi_r^+
\simeq 2\sqrt{\zeta(2)e^+_r}\)</span> and <span class="math">\(\ln\Xi_r^- \simeq
2\sqrt{\zeta(2)e^-_r}\)</span>.</p>
<p>If <code class="docutils literal"><span class="pre">dl_ent=True</span></code> is passed, this will be approximated instead by</p>
<div class="math">
\[\mathcal{L}_c \simeq \mathcal{L}_t - \sum_rn_r\sum_kp^r_k\ln p^r_k,\]</div>
<p>where <span class="math">\(p^r_k = n^r_k / n_r\)</span>.</p>
<p>If the &#8220;dense&#8221; entropies are requested (<code class="docutils literal"><span class="pre">dense=True</span></code>), they will be
computed as</p>
<div class="math">
\[\begin{split}\mathcal{S}_t  &amp;= \sum_{r&gt;s} \ln{\textstyle {n_rn_s \choose e_{rs}}} + \sum_r \ln{\textstyle {{n_r\choose 2}\choose e_{rr}/2}}\\
\mathcal{S}^d_t  &amp;= \sum_{rs} \ln{\textstyle {n_rn_s \choose e_{rs}}},\end{split}\]</div>
<p>for simple graphs, and</p>
<div class="math">
\[\begin{split}\mathcal{S}_m  &amp;= \sum_{r&gt;s} \ln{\textstyle \left(\!\!{n_rn_s \choose e_{rs}}\!\!\right)} + \sum_r \ln{\textstyle \left(\!\!{\left(\!{n_r\choose 2}\!\right)\choose e_{rr}/2}\!\!\right)}\\
\mathcal{S}^d_m  &amp;= \sum_{rs} \ln{\textstyle \left(\!\!{n_rn_s \choose e_{rs}}\!\!\right)},\end{split}\]</div>
<p>for multigraphs (i.e. <code class="docutils literal"><span class="pre">multigraph</span> <span class="pre">==</span> <span class="pre">True</span></code>). A dense entropy for the
degree-corrected model is not available, and if requested will return a
<a class="reference external" href="http://docs.python.org/3/library/exceptions.html#NotImplementedError" title="(in Python v3.4)"><code class="xref py py-exc docutils literal"><span class="pre">NotImplementedError</span></code></a>.</p>
<p>If <code class="docutils literal"><span class="pre">complete</span> <span class="pre">==</span> <span class="pre">False</span></code> constants in the above equations which do not
depend on the partition of the nodes will be omitted.</p>
<p>Note that in all cases if <code class="docutils literal"><span class="pre">norm==True</span></code> the value returned corresponds
to the entropy <cite>per edge</cite>, i.e. <span class="math">\((\mathcal{S}_{t/c}\; [\,+\,\mathcal{L}_{t/c}])/ E\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.community.BlockState.get_matrix">
<code class="descname">get_matrix</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/community/blockmodel.html#BlockState.get_matrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.community.BlockState.get_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the block matrix (as a sparse <a class="reference external" href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.html#scipy.sparse.csr_matrix" title="(in SciPy v0.15.1)"><code class="xref py py-class docutils literal"><span class="pre">csr_matrix</span></code></a>),
which contains the number of edges between each block pair.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This corresponds to the adjacency matrix of the block graph, which by
convention includes twice the amount of edges in the diagonal entries
if the graph is undirected.</p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s">&quot;polbooks&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">BlockState</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">B</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">deg_corr</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1000</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">ds</span><span class="p">,</span> <span class="n">nmoves</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">mcmc_sweep</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">get_matrix</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">figure</span><span class="p">()</span>
<span class="go">&lt;...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">matshow</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">todense</span><span class="p">())</span>
<span class="go">&lt;...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">savefig</span><span class="p">(</span><span class="s">&quot;bloc_mat.pdf&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="figure align-center" id="id90">
<img alt="_images/bloc_mat.png" src="_images/bloc_mat.png" />
<p class="caption"><span class="caption-text">A  5x5 block matrix.</span></p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="graph_tool.community.OverlapBlockState">
<em class="property">class </em><code class="descclassname">graph_tool.community.</code><code class="descname">OverlapBlockState</code><span class="sig-paren">(</span><em>g</em>, <em>b=None</em>, <em>B=None</em>, <em>clabel=None</em>, <em>deg_corr=True</em>, <em>max_BE=1000</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/community/overlap_blockmodel.html#OverlapBlockState"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.community.OverlapBlockState" title="Permalink to this definition">¶</a></dt>
<dd><p>This class encapsulates the overlapping block state of a given graph.</p>
<p>This must be instantiated and used by functions such as <a class="reference internal" href="#graph_tool.community.mcmc_sweep" title="graph_tool.community.mcmc_sweep"><code class="xref py py-func docutils literal"><span class="pre">mcmc_sweep()</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>g</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.Graph" title="graph_tool.Graph"><code class="xref py py-class docutils literal"><span class="pre">Graph</span></code></a></p>
<blockquote>
<div><p>Graph to be modelled.</p>
</div></blockquote>
<p><strong>b</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal"><span class="pre">PropertyMap</span></code></a> or <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> (optional, default: <code class="docutils literal"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>Initial block labels on the vertices or half-edges. If not supplied, it
will be randomly sampled.
If the value passed is a vertex property map, it will be assumed to be a
non-overlapping partition of the vertices. If it is an edge property
map, it should contain a vector for each edge, with the block labels at
each end point (sorted according to their vertex index, in the case of
undirected graphs, otherwise from source to target). If the value is an
<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a>, it will be assumed to correspond directly to a
partition of the list of half-edges.</p>
</div></blockquote>
<p><strong>B</strong> : <code class="docutils literal"><span class="pre">int</span></code> (optional, default: <code class="docutils literal"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>Number of blocks. If not supplied it will be either obtained from the
parameter <code class="docutils literal"><span class="pre">b</span></code>, or set to the maximum possible value according to the
minimum description length.</p>
</div></blockquote>
<p><strong>clabel</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal"><span class="pre">PropertyMap</span></code></a> (optional, default: <code class="docutils literal"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>Constraint labels on the vertices. If supplied, vertices with different
label values will not be clustered in the same group.</p>
</div></blockquote>
<p><strong>deg_corr</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, the degree-corrected version of the blockmodel ensemble will
be assumed, otherwise the traditional variant will be used.</p>
</div></blockquote>
<p><strong>max_BE</strong> : <code class="docutils literal"><span class="pre">int</span></code> (optional, default: <code class="docutils literal"><span class="pre">1000</span></code>)</p>
<blockquote class="last">
<div><p>If the number of blocks exceeds this number, a sparse representation of
the block graph is used, which is slightly less efficient, but uses less
memory,</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="graph_tool.community.OverlapBlockState.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>b=None</em>, <em>B=None</em>, <em>deg_corr=None</em>, <em>clabel=None</em>, <em>overlap=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/community/overlap_blockmodel.html#OverlapBlockState.copy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.community.OverlapBlockState.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Copies the block state. The parameters override the state properties, and
have the same meaning as in the constructor. If <code class="docutils literal"><span class="pre">overlap=False</span></code> an
instance of <a class="reference internal" href="#graph_tool.community.BlockState" title="graph_tool.community.BlockState"><code class="xref py py-class docutils literal"><span class="pre">BlockState</span></code></a> is returned.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.community.OverlapBlockState.get_block_state">
<code class="descname">get_block_state</code><span class="sig-paren">(</span><em>b=None</em>, <em>vweight=False</em>, <em>overlap=False</em>, <em>deg_corr=False</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/community/overlap_blockmodel.html#OverlapBlockState.get_block_state"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.community.OverlapBlockState.get_block_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a <code class="xref py py-class docutils literal"><span class="pre">BlockState`</span></code> (or
<code class="xref py py-class docutils literal"><span class="pre">OverlapBlockState`</span></code> if <code class="docutils literal"><span class="pre">overlap==True</span></code>)
corresponding to the block graph. The parameters have the same meaning
as the in the constructor.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.community.OverlapBlockState.get_edge_blocks">
<code class="descname">get_edge_blocks</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/community/overlap_blockmodel.html#OverlapBlockState.get_edge_blocks"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.community.OverlapBlockState.get_edge_blocks" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an edge property map which contains the block labels pairs for each
edge.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.community.OverlapBlockState.get_overlap_blocks">
<code class="descname">get_overlap_blocks</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/community/overlap_blockmodel.html#OverlapBlockState.get_overlap_blocks"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.community.OverlapBlockState.get_overlap_blocks" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the mixed membership of each vertex.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>bv</strong> : <code class="xref py py-class docutils literal"><span class="pre">PropertyMap</span></code></p>
<blockquote>
<div><p>A vector-valued vertex property map containing the block memberships
of each node.</p>
</div></blockquote>
<p><strong>bc_in</strong> : <code class="xref py py-class docutils literal"><span class="pre">PropertyMap</span></code></p>
<blockquote>
<div><p>The labelled in-degrees of each node, i.e. how many in-edges belong
to each group, in the same order as the <code class="docutils literal"><span class="pre">bv</span></code> property above.</p>
</div></blockquote>
<p><strong>bc_out</strong> : <code class="xref py py-class docutils literal"><span class="pre">PropertyMap</span></code></p>
<blockquote>
<div><p>The labelled out-degrees of each node, i.e. how many out-edges belong
to each group, in the same order as the <code class="docutils literal"><span class="pre">bv</span></code> property above.</p>
</div></blockquote>
<p><strong>bc_total</strong> : <code class="xref py py-class docutils literal"><span class="pre">PropertyMap</span></code></p>
<blockquote class="last">
<div><p>The labelled total degrees of each node, i.e. how many incident edges
belong to each group, in the same order as the <code class="docutils literal"><span class="pre">bv</span></code> property above.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="graph_tool.community.OverlapBlockState.get_nonoverlap_blocks">
<code class="descname">get_nonoverlap_blocks</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/community/overlap_blockmodel.html#OverlapBlockState.get_nonoverlap_blocks"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.community.OverlapBlockState.get_nonoverlap_blocks" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a scalar-valued vertex property map with the block mixture
represented as a single number.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.community.OverlapBlockState.get_majority_blocks">
<code class="descname">get_majority_blocks</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/community/overlap_blockmodel.html#OverlapBlockState.get_majority_blocks"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.community.OverlapBlockState.get_majority_blocks" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a scalar-valued vertex property map with the majority block
membership of each node.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.community.OverlapBlockState.entropy">
<code class="descname">entropy</code><span class="sig-paren">(</span><em>complete=True</em>, <em>dl=False</em>, <em>partition_dl=True</em>, <em>edges_dl=True</em>, <em>degree_dl=True</em>, <em>multigraph=True</em>, <em>norm=False</em>, <em>dl_ent=False</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/community/overlap_blockmodel.html#OverlapBlockState.entropy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.community.OverlapBlockState.entropy" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the entropy associated with the current overlapping partition.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>complete</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, the complete entropy will be returned, including constant
terms not relevant to the block partition.</p>
</div></blockquote>
<p><strong>dl</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, the full description length will be returned.</p>
</div></blockquote>
<p><strong>partition_dl</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, and <code class="docutils literal"><span class="pre">dl</span> <span class="pre">==</span> <span class="pre">True</span></code> the partition description length
will be considered.</p>
</div></blockquote>
<p><strong>edges_dl</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, and <code class="docutils literal"><span class="pre">dl</span> <span class="pre">==</span> <span class="pre">True</span></code> the edge matrix description length
will be considered.</p>
</div></blockquote>
<p><strong>degree_dl</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, and <code class="docutils literal"><span class="pre">dl</span> <span class="pre">==</span> <span class="pre">True</span></code> the degree sequence description
length will be considered.</p>
</div></blockquote>
<p><strong>multigraph</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, the multigraph entropy will be used. Only has an effect
if <code class="docutils literal"><span class="pre">dense</span> <span class="pre">==</span> <span class="pre">True</span></code>.</p>
</div></blockquote>
<p><strong>norm</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, the entropy will be &#8220;normalized&#8221; by dividing by the
number of edges.</p>
</div></blockquote>
<p><strong>dl_ent</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">False</span></code>)</p>
<blockquote class="last">
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, the description length of the degree sequence will be
approximated by its entropy.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>For the traditional blockmodel (<code class="docutils literal"><span class="pre">deg_corr</span> <span class="pre">==</span> <span class="pre">False</span></code>), the entropy is
given by</p>
<div class="math">
\[\begin{split}\mathcal{S}_t &amp;\cong E - \frac{1}{2} \sum_{rs}e_{rs}\ln\left(\frac{e_{rs}}{n_rn_s}\right), \\
\mathcal{S}^d_t &amp;\cong E - \sum_{rs}e_{rs}\ln\left(\frac{e_{rs}}{n_rn_s}\right),\end{split}\]</div>
<p>for undirected and directed graphs, respectively, where <span class="math">\(e_{rs}\)</span>
is the number of edges from block <span class="math">\(r\)</span> to <span class="math">\(s\)</span> (or the number
of half-edges for the undirected case when <span class="math">\(r=s\)</span>), and <span class="math">\(n_r
= \sum_ib_i^r\)</span> is the number of vertices in block <span class="math">\(r\)</span>, with
<span class="math">\(\vec{b}_i\)</span> being a binary vector with <span class="math">\(B\)</span> entries
describing the mixed membership of node <span class="math">\(i\)</span>. Note that because of
the possible overlaps, we have <span class="math">\(\sum_rn_r \ge N\)</span>.</p>
<p>For the degree-corrected variant with &#8220;hard&#8221; degree constraints the
equivalent expressions are</p>
<div class="math">
\[\begin{split}\mathcal{S}_c &amp;\cong -E -\sum_{ir}\ln k_i^r! - \frac{1}{2} \sum_{rs}e_{rs}\ln\left(\frac{e_{rs}}{e_re_s}\right), \\
\mathcal{S}^d_c &amp;\cong -E -\sum_{ir}\left(\ln {k^+}_i^r! + \ln {k^-}_i^r! \right) - \sum_{rs}e_{rs}\ln\left(\frac{e_{rs}}{e^+_re^-_s}\right),\end{split}\]</div>
<p>where <span class="math">\(e_r = \sum_se_{rs}\)</span> is the number of half-edges incident on
block <span class="math">\(r\)</span>, <span class="math">\(e^+_r = \sum_se_{rs}\)</span> and <span class="math">\(e^-_r =
\sum_se_{sr}\)</span> are the numbers of out- and in-edges adjacent to block
<span class="math">\(r\)</span>, respectively, and <span class="math">\(k_i^r\)</span> is the degree of node
<span class="math">\(i\)</span> of type <span class="math">\(r\)</span>, whereas <span class="math">\({k^+}_i^r\)</span> and
<span class="math">\({k^-}_i^r\)</span> are the labeled out- and in-degrees, respectively.</p>
<p>If <code class="docutils literal"><span class="pre">multigraph</span> <span class="pre">==</span> <span class="pre">True</span></code>, the entropy used will be of the &#8220;Poisson&#8221;
model, with the additional term:</p>
<div class="math">
\[\begin{split}{\mathcal{S}_{cm}^{(d)}} = \mathcal{S}_c^{(d)} + \sum_{i&gt;j}\sum_{rs} \ln A^{rs}_{ij}! + \sum_i\sum_{rs} \ln A^{rs}_{ii}!!\end{split}\]</div>
<p>If <code class="docutils literal"><span class="pre">complete</span> <span class="pre">==</span> <span class="pre">False</span></code> only the last term of the equations above will
be returned.</p>
<p>If <code class="docutils literal"><span class="pre">dl</span> <span class="pre">==</span> <span class="pre">True</span></code>, the description length <span class="math">\(\mathcal{L}_t\)</span> of the
model will be returned as well:</p>
<div class="math">
\[\mathcal{L}_t = \ln\Omega_m + \ln\left(\!\!{D \choose N}\!\!\right) + \sum_d \ln {\left(\!\!{{B\choose d}\choose n_d}\!\!\right)} + \ln N! - \sum_{\vec{b}}\ln n_{\vec{b}}!,\]</div>
<p>where <span class="math">\(d \equiv |\vec{b}|_1 = \sum_rb_r\)</span> is the mixture
size, <span class="math">\(n_d\)</span> is the number of nodes in a mixture of size <span class="math">\(d\)</span>,
<span class="math">\(D\)</span> is the maximum value of <span class="math">\(d\)</span>, <span class="math">\(n_{\vec{b}}\)</span> is the
number of nodes in mixture <span class="math">\(\vec{b}\)</span>, and</p>
<div class="math">
\[\Omega_m = \left(\!\!{\left(\!{B \choose 2}\!\right) \choose E}\!\!\right)\]</div>
<p>is the number of different <span class="math">\(e_{rs}\)</span> matrices for undirected
graphs, whereas for directed graphs we have</p>
<div class="math">
\[\Omega_m = \left(\!\!{B^2 \choose E}\!\!\right).\]</div>
<p>Note that for the degree-corrected version the description length is</p>
<div class="math">
\[\mathcal{L}_c = \mathcal{L}_t + \sum_r\ln\left(\!\!{m_r \choose e_r}\!\!\right) + \sum_{\vec{b}}\min\left(\mathcal{L}^{(1)}_{\vec{b}}, \mathcal{L}^{(2)}_{\vec{b}}\right),\]</div>
<p>where <span class="math">\(m_r\)</span> is the number of non-empty mixtures which contain type <span class="math">\(r\)</span>, and</p>
<div class="math">
\[\begin{split}\mathcal{L}^{(1)}_{\vec{b}} &amp;= \sum_r\ln{\left(\!\!{n_{\vec{b}}\choose e^r_{\vec{b}}}\!\!\right)}, \\
\mathcal{L}^{(2)}_{\vec{b}} &amp;= \sum_rb_r\ln\Xi_{\vec{b}}^r + \ln n_{\vec{b}}! - \sum_{\vec{k}} \ln n^{\vec{b}}_{\vec{k}}!,\end{split}\]</div>
<p>and <span class="math">\(\ln\Xi_{\vec{b}}^r \simeq 2\sqrt{\zeta(2)e_{\vec{b}}^r}\)</span>,
where <span class="math">\(\zeta(x)\)</span> is the <a class="reference external" href="https://en.wikipedia.org/wiki/Riemann_zeta_function">Riemann zeta function</a>, and
<span class="math">\(n^{\vec{b}}_{\vec{k}}\)</span> is the number of nodes in mixture
<span class="math">\(\vec{b}\)</span> with labelled degree <span class="math">\(\vec{k}\)</span>. For directed
graphs we have instead <span class="math">\(\vec{k} \to (\vec{k}^-, \vec{k}^+)\)</span>, and
<span class="math">\(\ln\Xi_{\vec{b}}^r \to \ln{\Xi^+}_{\vec{b}}^r +
\ln{\Xi^-}_{\vec{b}}^r\)</span>.</p>
<p>If <code class="docutils literal"><span class="pre">dl_ent=True</span></code> is passed, this will be approximated instead by</p>
<div class="math">
\[\mathcal{L}_c \simeq \mathcal{L}_t - \sum_{\vec{b}}n_{\vec{b}}\sum_{\vec{k}}p^{\vec{b}}_{\vec{k}}\ln p^{\vec{b}}_{\vec{k}},\]</div>
<p>where <span class="math">\(p^{\vec{b}}_{\vec{k}} = n^{\vec{b}}_{\vec{k}} / n_{\vec{b}}\)</span>.</p>
<p>If <code class="docutils literal"><span class="pre">complete</span> <span class="pre">==</span> <span class="pre">False</span></code> constants in the above equations which do not
depend on the partition of the nodes will be omitted.</p>
<p>Note that in all cases if <code class="docutils literal"><span class="pre">norm</span> <span class="pre">==</span> <span class="pre">True</span></code> the value returned
corresponds to the entropy <cite>per edge</cite>, i.e. <span class="math">\((\mathcal{S}_{t/c}\;[\,+\,\mathcal{L}_{t/c}])/ E\)</span>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="graph_tool.community.CovariateBlockState">
<em class="property">class </em><code class="descclassname">graph_tool.community.</code><code class="descname">CovariateBlockState</code><span class="sig-paren">(</span><em>g</em>, <em>ec</em>, <em>eweight=None</em>, <em>vweight=None</em>, <em>b=None</em>, <em>B=None</em>, <em>clabel=None</em>, <em>layers=False</em>, <em>deg_corr=True</em>, <em>overlap=False</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/community/covariate_blockmodel.html#CovariateBlockState"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.community.CovariateBlockState" title="Permalink to this definition">¶</a></dt>
<dd><p>This class encapsulates the (possibly overlapping) block state of a given
graph, where the edges are divided into discrete layers.</p>
<p>This must be instantiated and used by functions such as <a class="reference internal" href="#graph_tool.community.mcmc_sweep" title="graph_tool.community.mcmc_sweep"><code class="xref py py-func docutils literal"><span class="pre">mcmc_sweep()</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>g</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.Graph" title="graph_tool.Graph"><code class="xref py py-class docutils literal"><span class="pre">Graph</span></code></a></p>
<blockquote>
<div><p>Graph to be modelled.</p>
</div></blockquote>
<p><strong>ec</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal"><span class="pre">PropertyMap</span></code></a></p>
<blockquote>
<div><p>Edge <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal"><span class="pre">PropertyMap</span></code></a> containing edge covariates that
will split the network in discrete layers.</p>
</div></blockquote>
<p><strong>eweight</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal"><span class="pre">PropertyMap</span></code></a> (optional, default: <code class="docutils literal"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>Edge multiplicities (for multigraphs or block graphs).</p>
</div></blockquote>
<p><strong>vweight</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal"><span class="pre">PropertyMap</span></code></a> (optional, default: <code class="docutils literal"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>Vertex multiplicities (for block graphs).</p>
</div></blockquote>
<p><strong>b</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal"><span class="pre">PropertyMap</span></code></a> or <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></code></a> (optional, default: <code class="docutils literal"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>Initial block labels on the vertices or half-edges. If not supplied, it
will be randomly sampled.</p>
</div></blockquote>
<p><strong>B</strong> : <code class="docutils literal"><span class="pre">int</span></code> (optional, default: <code class="docutils literal"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>Number of blocks. If not supplied it will be either obtained from the
parameter <code class="docutils literal"><span class="pre">b</span></code>, or set to the maximum possible value according to the
minimum description length.</p>
</div></blockquote>
<p><strong>clabel</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal"><span class="pre">PropertyMap</span></code></a> (optional, default: <code class="docutils literal"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>Constraint labels on the vertices. If supplied, vertices with different
label values will not be clustered in the same group.</p>
</div></blockquote>
<p><strong>layers</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">layers==True</span></code>, the &#8220;independent layers&#8221; version of the model is
used, instead of the &#8220;edge covariates&#8221; version.</p>
</div></blockquote>
<p><strong>deg_corr</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, the degree-corrected version of the blockmodel ensemble will
be assumed, otherwise the traditional variant will be used.</p>
</div></blockquote>
<p><strong>overlap</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">False</span></code>)</p>
<blockquote class="last">
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, the overlapping version of the moddel will be used.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="graph_tool.community.CovariateBlockState.merge_layers">
<code class="descname">merge_layers</code><span class="sig-paren">(</span><em>l_src</em>, <em>l_tgt</em>, <em>revert=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/community/covariate_blockmodel.html#CovariateBlockState.merge_layers"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.community.CovariateBlockState.merge_layers" title="Permalink to this definition">¶</a></dt>
<dd><p>Merge layer <cite>l_src</cite> into <cite>l_tgt</cite> and delete <cite>l_src</cite>.</p>
<p>If <code class="docutils literal"><span class="pre">revert</span> <span class="pre">==</span> <span class="pre">True</span></code>, this will return a context that can be used with
the <code class="docutils literal"><span class="pre">with</span></code> statement, so that when the context is closed, the layers
are returned to their original state, i.e.</p>
<div class="code highlight-python"><div class="highlight"><pre><span class="k">with</span> <span class="n">state</span><span class="o">.</span><span class="n">merge_layers</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">revert</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="c"># here layers 3 and 10 are merged</span>
    <span class="k">pass</span>
<span class="c"># here layers 3 and 10 exist separately as they did before</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="graph_tool.community.CovariateBlockState.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>b=None</em>, <em>B=None</em>, <em>deg_corr=None</em>, <em>clabel=None</em>, <em>overlap=None</em>, <em>layers=None</em>, <em>ec=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/community/covariate_blockmodel.html#CovariateBlockState.copy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.community.CovariateBlockState.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Copies the block state. The parameters override the state properties, and
have the same meaning as in the constructor.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.community.CovariateBlockState.get_bclabel">
<code class="descname">get_bclabel</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/community/covariate_blockmodel.html#CovariateBlockState.get_bclabel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.community.CovariateBlockState.get_bclabel" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a <code class="xref py py-class docutils literal"><span class="pre">PropertyMap`</span></code> corresponding to constraint
labels for the block graph.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.community.CovariateBlockState.get_bg">
<code class="descname">get_bg</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/community/covariate_blockmodel.html#CovariateBlockState.get_bg"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.community.CovariateBlockState.get_bg" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the block graph.</p>
</dd></dl>

<dl class="attribute">
<dt id="graph_tool.community.CovariateBlockState.bg">
<code class="descname">bg</code><a class="headerlink" href="#graph_tool.community.CovariateBlockState.bg" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="graph_tool.community.CovariateBlockState.mrs">
<code class="descname">mrs</code><a class="headerlink" href="#graph_tool.community.CovariateBlockState.mrs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="graph_tool.community.CovariateBlockState.bec">
<code class="descname">bec</code><a class="headerlink" href="#graph_tool.community.CovariateBlockState.bec" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="graph_tool.community.CovariateBlockState.get_block_state">
<code class="descname">get_block_state</code><span class="sig-paren">(</span><em>b=None</em>, <em>vweight=False</em>, <em>deg_corr=False</em>, <em>overlap=False</em>, <em>layers=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/community/covariate_blockmodel.html#CovariateBlockState.get_block_state"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.community.CovariateBlockState.get_block_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a <code class="xref py py-class docutils literal"><span class="pre">CovariateBlockState`</span></code> corresponding
to the block graph. The parameters have the same meaning as the in the
constructor.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.community.CovariateBlockState.get_edge_blocks">
<code class="descname">get_edge_blocks</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/community/covariate_blockmodel.html#CovariateBlockState.get_edge_blocks"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.community.CovariateBlockState.get_edge_blocks" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an edge property map which contains the block labels pairs for each
edge.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.community.CovariateBlockState.get_overlap_blocks">
<code class="descname">get_overlap_blocks</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/community/covariate_blockmodel.html#CovariateBlockState.get_overlap_blocks"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.community.CovariateBlockState.get_overlap_blocks" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the mixed membership of each vertex.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>bv</strong> : <code class="xref py py-class docutils literal"><span class="pre">PropertyMap</span></code></p>
<blockquote>
<div><p>A vector-valued vertex property map containing the block memberships
of each node.</p>
</div></blockquote>
<p><strong>bc_in</strong> : <code class="xref py py-class docutils literal"><span class="pre">PropertyMap</span></code></p>
<blockquote>
<div><p>The labelled in-degrees of each node, i.e. how many in-edges belong
to each group, in the same order as the <code class="docutils literal"><span class="pre">bv</span></code> property above.</p>
</div></blockquote>
<p><strong>bc_out</strong> : <code class="xref py py-class docutils literal"><span class="pre">PropertyMap</span></code></p>
<blockquote>
<div><p>The labelled out-degrees of each node, i.e. how many out-edges belong
to each group, in the same order as the <code class="docutils literal"><span class="pre">bv</span></code> property above.</p>
</div></blockquote>
<p><strong>bc_total</strong> : <code class="xref py py-class docutils literal"><span class="pre">PropertyMap</span></code></p>
<blockquote class="last">
<div><p>The labelled total degrees of each node, i.e. how many incident edges
belong to each group, in the same order as the <code class="docutils literal"><span class="pre">bv</span></code> property above.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="graph_tool.community.CovariateBlockState.get_nonoverlap_blocks">
<code class="descname">get_nonoverlap_blocks</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/community/covariate_blockmodel.html#CovariateBlockState.get_nonoverlap_blocks"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.community.CovariateBlockState.get_nonoverlap_blocks" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a scalar-valued vertex property map with the block mixture
represented as a single number.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.community.CovariateBlockState.get_majority_blocks">
<code class="descname">get_majority_blocks</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/community/covariate_blockmodel.html#CovariateBlockState.get_majority_blocks"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.community.CovariateBlockState.get_majority_blocks" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a scalar-valued vertex property map with the majority block
membership of each node.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.community.CovariateBlockState.entropy">
<code class="descname">entropy</code><span class="sig-paren">(</span><em>complete=True</em>, <em>dl=False</em>, <em>partition_dl=True</em>, <em>edges_dl=True</em>, <em>degree_dl=True</em>, <em>dense=False</em>, <em>multigraph=True</em>, <em>norm=False</em>, <em>dl_ent=False</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/community/covariate_blockmodel.html#CovariateBlockState.entropy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.community.CovariateBlockState.entropy" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the entropy associated with the current block partition.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>complete</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, the complete entropy will be returned, including constant
terms not relevant to the block partition.</p>
</div></blockquote>
<p><strong>dl</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, the full description length will be returned.</p>
</div></blockquote>
<p><strong>partition_dl</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, and <code class="docutils literal"><span class="pre">dl</span> <span class="pre">==</span> <span class="pre">True</span></code> the partition description length
will be considered.</p>
</div></blockquote>
<p><strong>edges_dl</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, and <code class="docutils literal"><span class="pre">dl</span> <span class="pre">==</span> <span class="pre">True</span></code> the edge matrix description length
will be considered.</p>
</div></blockquote>
<p><strong>degree_dl</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, and <code class="docutils literal"><span class="pre">dl</span> <span class="pre">==</span> <span class="pre">True</span></code> the degree sequence description
length will be considered.</p>
</div></blockquote>
<p><strong>dense</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, the &#8220;dense&#8221; variant of the entropy will be computed.</p>
</div></blockquote>
<p><strong>multigraph</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, the multigraph entropy will be used.</p>
</div></blockquote>
<p><strong>norm</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, the entropy will be &#8220;normalized&#8221; by dividing by the
number of edges.</p>
</div></blockquote>
<p><strong>dl_ent</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">False</span></code>)</p>
<blockquote class="last">
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, the description length of the degree sequence will be
approximated by its entropy.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="graph_tool.community.mcmc_sweep">
<code class="descclassname">graph_tool.community.</code><code class="descname">mcmc_sweep</code><span class="sig-paren">(</span><em>state</em>, <em>beta=1.0</em>, <em>c=1.0</em>, <em>niter=1</em>, <em>dl=False</em>, <em>dense=False</em>, <em>multigraph=False</em>, <em>node_coherent=False</em>, <em>confine_layers=False</em>, <em>sequential=True</em>, <em>parallel=False</em>, <em>vertices=None</em>, <em>verbose=False</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/community/blockmodel.html#mcmc_sweep"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.community.mcmc_sweep" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs a Markov chain Monte Carlo sweep on the network, to sample the block partition according to a probability <span class="math">\(\propto e^{-\beta \mathcal{S}_{t/c}}\)</span>, where <span class="math">\(\mathcal{S}_{t/c}\)</span> is the blockmodel entropy.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>state</strong> : <a class="reference internal" href="#graph_tool.community.BlockState" title="graph_tool.community.BlockState"><code class="xref py py-class docutils literal"><span class="pre">BlockState</span></code></a>, <a class="reference internal" href="#graph_tool.community.OverlapBlockState" title="graph_tool.community.OverlapBlockState"><code class="xref py py-class docutils literal"><span class="pre">OverlapBlockState</span></code></a> or <a class="reference internal" href="#graph_tool.community.CovariateBlockState" title="graph_tool.community.CovariateBlockState"><code class="xref py py-class docutils literal"><span class="pre">CovariateBlockState</span></code></a></p>
<blockquote>
<div><p>The block state.</p>
</div></blockquote>
<p><strong>beta</strong> : <code class="docutils literal"><span class="pre">float</span></code> (optional, default: <cite>1.0</cite>)</p>
<blockquote>
<div><p>The inverse temperature parameter <span class="math">\(\beta\)</span>.</p>
</div></blockquote>
<p><strong>c</strong> : <code class="docutils literal"><span class="pre">float</span></code> (optional, default: <code class="docutils literal"><span class="pre">1.0</span></code>)</p>
<blockquote>
<div><p>This parameter specifies how often fully random moves are attempted,
instead of more likely moves based on the inferred block partition.
For <code class="docutils literal"><span class="pre">c</span> <span class="pre">==</span> <span class="pre">0</span></code>, no fully random moves are attempted, and for <code class="docutils literal"><span class="pre">c</span> <span class="pre">==</span> <span class="pre">inf</span></code>
they are always attempted.</p>
</div></blockquote>
<p><strong>niter</strong> : <code class="docutils literal"><span class="pre">int</span></code> (optional, default: <code class="docutils literal"><span class="pre">1</span></code>)</p>
<blockquote>
<div><p>Number of sweeps to perform.</p>
</div></blockquote>
<p><strong>dl</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, the change in the whole description length will be
considered after each vertex move, not only the entropy.</p>
</div></blockquote>
<p><strong>dense</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, the &#8220;dense&#8221; variant of the entropy will be computed.</p>
</div></blockquote>
<p><strong>multigraph</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, the multigraph entropy will be used. Only has an effect
if <code class="docutils literal"><span class="pre">dense</span> <span class="pre">==</span> <span class="pre">True</span></code>.</p>
</div></blockquote>
<p><strong>node_coherent</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, and if the <code class="docutils literal"><span class="pre">state</span></code> is an instance of
<a class="reference internal" href="#graph_tool.community.OverlapBlockState" title="graph_tool.community.OverlapBlockState"><code class="xref py py-class docutils literal"><span class="pre">OverlapBlockState</span></code></a>, then all half-edges
incident on the same node are moved simultaneously.</p>
</div></blockquote>
<p><strong>confine_layers</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, and if the <code class="docutils literal"><span class="pre">state</span></code> is an instance of
<a class="reference internal" href="#graph_tool.community.CovariateBlockState" title="graph_tool.community.CovariateBlockState"><code class="xref py py-class docutils literal"><span class="pre">CovariateBlockState</span></code></a>, with an
<em>overlapping</em> partition, the half edges will only be moved in such a way</p>
<blockquote>
<div><p>that inside each layer the group membership remains non-overlapping.</p>
</div></blockquote>
</div></blockquote>
<p><strong>sequential</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, the move attempts on the vertices are done in sequential
random order. Otherwise a total of <cite>N</cite> moves attempts are made, where
<cite>N</cite> is the number of vertices, where each vertex can be selected with
equal probability.</p>
</div></blockquote>
<p><strong>parallel</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, the updates are performed in parallel (multiple
threads).</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">If this is used, the Markov Chain is not guaranteed to be sampled with
the correct probabilities. This is better used in conjunction with
<code class="docutils literal"><span class="pre">beta=float('inf')</span></code>, where this is not an issue.</p>
</div>
</div></blockquote>
<p><strong>vertices</strong> : <code class="docutils literal"><span class="pre">list</span> <span class="pre">of</span> <span class="pre">ints</span></code> (optional, default: <code class="docutils literal"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>A list of vertices which will be attempted to be moved. If <code class="docutils literal"><span class="pre">None</span></code>, all
vertices will be attempted.</p>
</div></blockquote>
<p><strong>verbose</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, verbose information is displayed.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dS</strong> : <code class="docutils literal"><span class="pre">float</span></code></p>
<blockquote>
<div><p>The entropy difference (in nats) after the sweeps.</p>
</div></blockquote>
<p><strong>nmoves</strong> : <code class="docutils literal"><span class="pre">int</span></code></p>
<blockquote class="last">
<div><p>The number of accepted block membership moves.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This algorithm performs a Markov chain Monte Carlo sweep on the network,
where the block memberships are randomly moved, and either accepted or
rejected, so that after sufficiently many sweeps the partitions are sampled
with probability proportional to <span class="math">\(e^{-\beta\mathcal{S}_{t/c}}\)</span>, where
<span class="math">\(\mathcal{S}_{t/c}\)</span> is the blockmodel entropy, given by</p>
<div class="math">
\[\begin{split}\mathcal{S}_t &amp;\cong - \frac{1}{2} \sum_{rs}e_{rs}\ln\left(\frac{e_{rs}}{n_rn_s}\right), \\
\mathcal{S}^d_t &amp;\cong - \sum_{rs}e_{rs}\ln\left(\frac{e_{rs}}{n_rn_s}\right),\end{split}\]</div>
<p>for undirected and directed traditional blockmodels (<code class="docutils literal"><span class="pre">deg_corr</span> <span class="pre">==</span> <span class="pre">False</span></code>),
respectively, where <span class="math">\(e_{rs}\)</span> is the number of edges from block
<span class="math">\(r\)</span> to <span class="math">\(s\)</span> (or the number of half-edges for the undirected case
when <span class="math">\(r=s\)</span>), and <span class="math">\(n_r\)</span> is the number of vertices in block
<span class="math">\(r\)</span>, and constant terms which are independent of the block partition
were dropped (see <a class="reference internal" href="#graph_tool.community.BlockState.entropy" title="graph_tool.community.BlockState.entropy"><code class="xref py py-meth docutils literal"><span class="pre">BlockState.entropy()</span></code></a> for the complete entropy). For
the degree-corrected variant with &#8220;hard&#8221; degree constraints the equivalent
expressions are</p>
<div class="math">
\[\begin{split}\mathcal{S}_c &amp;\cong  - \frac{1}{2} \sum_{rs}e_{rs}\ln\left(\frac{e_{rs}}{e_re_s}\right), \\
\mathcal{S}^d_c &amp;\cong - \sum_{rs}e_{rs}\ln\left(\frac{e_{rs}}{e^+_re^-_s}\right),\end{split}\]</div>
<p>where <span class="math">\(e_r = \sum_se_{rs}\)</span> is the number of half-edges incident on
block <span class="math">\(r\)</span>, and <span class="math">\(e^+_r = \sum_se_{rs}\)</span> and <span class="math">\(e^-_r =
\sum_se_{sr}\)</span> are the number of out- and in-edges adjacent to block
<span class="math">\(r\)</span>, respectively.</p>
<p>The Monte Carlo algorithm employed attempts to improve the mixing time of
the Markov chain by proposing membership moves <span class="math">\(r\to s\)</span> with
probability <span class="math">\(p(r\to s|t) \propto e_{ts} + c\)</span>, where <span class="math">\(t\)</span> is the
block label of a random neighbour of the vertex being moved. See
<a class="reference internal" href="#id69" id="id14">[peixoto-efficient-2014]</a> for more details.</p>
<p>This algorithm has a complexity of <span class="math">\(O(E)\)</span>, where <span class="math">\(E\)</span> is the
number of edges in the network.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="id15" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[holland-stochastic-1983]</td><td>Paul W. Holland, Kathryn Blackmond Laskey,
Samuel Leinhardt, &#8220;Stochastic blockmodels: First steps&#8221;,
Carnegie-Mellon University, Pittsburgh, PA 15213, U.S.A.,
<a class="reference external" href="http://dx.doi.org/10.1016/0378-8733(83)90021-7">DOI: 10.1016/0378-8733(83)90021-7</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="id16" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[faust-blockmodels-1992]</td><td>Katherine Faust, and Stanley
Wasserman. &#8220;Blockmodels: Interpretation and Evaluation.&#8221; Social Networks
14, no. 1-2 (1992): 5-61. <a class="reference external" href="http://dx.doi.org/10.1016/0378-8733(92)90013-W">DOI: 10.1016/0378-8733(92)90013-W</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="id17" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[karrer-stochastic-2011]</td><td>Brian Karrer, and M. E. J. Newman. &#8220;Stochastic
Blockmodels and Community Structure in Networks.&#8221; Physical Review E 83,
no. 1 (2011): 016107. <a class="reference external" href="http://dx.doi.org/10.1103/PhysRevE.83.016107">DOI: 10.1103/PhysRevE.83.016107</a>.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="id18" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[peixoto-entropy-2012]</td><td>Tiago P. Peixoto &#8220;Entropy of Stochastic Blockmodel
Ensembles.&#8221; Physical Review E 85, no. 5 (2012): 056122.
<a class="reference external" href="http://dx.doi.org/10.1103/PhysRevE.85.056122">DOI: 10.1103/PhysRevE.85.056122</a>, <a class="reference external" href="http://arxiv.org/abs/1112.6028">arXiv: 1112.6028</a>.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="id19" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[peixoto-parsimonious-2013]</td><td>Tiago P. Peixoto, &#8220;Parsimonious module
inference in large networks&#8221;, Phys. Rev. Lett. 110, 148701 (2013),
<a class="reference external" href="http://dx.doi.org/10.1103/PhysRevLett.110.148701">DOI: 10.1103/PhysRevLett.110.148701</a>, <a class="reference external" href="http://arxiv.org/abs/1212.4794">arXiv: 1212.4794</a>.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="id20" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[peixoto-efficient-2014]</td><td>Tiago P. Peixoto, &#8220;Efficient Monte Carlo and greedy
heuristic for the inference of stochastic block models&#8221;, Phys. Rev. E 89,
012804 (2014), <a class="reference external" href="http://dx.doi.org/10.1103/PhysRevE.89.012804">DOI: 10.1103/PhysRevE.89.012804</a>, <a class="reference external" href="http://arxiv.org/abs/1310.4378">arXiv: 1310.4378</a>.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="id21" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[peixoto-model-2015]</td><td>Tiago P. Peixoto, &#8220;Model selection and hypothesis
testing for large-scale network models with overlapping groups&#8221;,
Phys. Rev. X 5, 011033 (2015), <a class="reference external" href="http://dx.doi.org/10.1103/PhysRevX.5.011033">DOI: 10.1103/PhysRevX.5.011033</a>,
<a class="reference external" href="http://arxiv.org/abs/1409.3059">arXiv: 1409.3059</a>.</td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s">&quot;polbooks&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">BlockState</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">B</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">deg_corr</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pv</span> <span class="o">=</span> <span class="bp">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1000</span><span class="p">):</span>        <span class="c"># remove part of the transient</span>
<span class="gp">... </span>    <span class="n">ds</span><span class="p">,</span> <span class="n">nmoves</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">mcmc_sweep</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1000</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">ds</span><span class="p">,</span> <span class="n">nmoves</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">mcmc_sweep</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">pv</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">collect_vertex_marginals</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">pv</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gt</span><span class="o">.</span><span class="n">graph_draw</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">g</span><span class="o">.</span><span class="n">vp</span><span class="p">[</span><span class="s">&quot;pos&quot;</span><span class="p">],</span> <span class="n">vertex_shape</span><span class="o">=</span><span class="s">&quot;pie&quot;</span><span class="p">,</span> <span class="n">vertex_pie_fractions</span><span class="o">=</span><span class="n">pv</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s">&quot;polbooks_blocks_soft.pdf&quot;</span><span class="p">)</span>
<span class="go">&lt;...&gt;</span>
</pre></div>
</div>
<div class="figure align-center" id="id91">
<img alt="_images/polbooks_blocks_soft.png" src="_images/polbooks_blocks_soft.png" />
<p class="caption"><span class="caption-text">&#8220;Soft&#8221; block partition of a political books network with <span class="math">\(B=3\)</span>.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="graph_tool.community.MinimizeState">
<em class="property">class </em><code class="descclassname">graph_tool.community.</code><code class="descname">MinimizeState</code><a class="reference internal" href="_modules/graph_tool/community/blockmodel.html#MinimizeState"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.community.MinimizeState" title="Permalink to this definition">¶</a></dt>
<dd><p>This object stores information regarding the current entropy minimization
state, so that the algorithms can resume previously started runs.
This object can be saved to disk via the <a class="reference external" href="http://docs.python.org/3/library/pickle.html#module-pickle" title="(in Python v3.4)"><code class="xref py py-mod docutils literal"><span class="pre">pickle</span></code></a> interface.</p>
<dl class="method">
<dt id="graph_tool.community.MinimizeState.clear">
<code class="descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/community/blockmodel.html#MinimizeState.clear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.community.MinimizeState.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Clear state.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="graph_tool.community.multilevel_minimize">
<code class="descclassname">graph_tool.community.</code><code class="descname">multilevel_minimize</code><span class="sig-paren">(</span><em>state</em>, <em>B</em>, <em>nsweeps=10</em>, <em>adaptive_sweeps=True</em>, <em>epsilon=0</em>, <em>anneal=(1.0</em>, <em>1.0)</em>, <em>r=2.0</em>, <em>nmerge_sweeps=10</em>, <em>greedy=True</em>, <em>c=0.0</em>, <em>dl=False</em>, <em>dense=False</em>, <em>multigraph=True</em>, <em>sequential=True</em>, <em>parallel=False</em>, <em>checkpoint=None</em>, <em>minimize_state=None</em>, <em>verbose=False</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/community/blockmodel.html#multilevel_minimize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.community.multilevel_minimize" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs an agglomerative heuristic, which progressively merges blocks together (while allowing individual node moves) to achieve a good partition in <code class="docutils literal"><span class="pre">B</span></code> blocks.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>state</strong> : <a class="reference internal" href="#graph_tool.community.BlockState" title="graph_tool.community.BlockState"><code class="xref py py-class docutils literal"><span class="pre">BlockState</span></code></a>, <a class="reference internal" href="#graph_tool.community.OverlapBlockState" title="graph_tool.community.OverlapBlockState"><code class="xref py py-class docutils literal"><span class="pre">OverlapBlockState</span></code></a> or <a class="reference internal" href="#graph_tool.community.CovariateBlockState" title="graph_tool.community.CovariateBlockState"><code class="xref py py-class docutils literal"><span class="pre">CovariateBlockState</span></code></a></p>
<blockquote>
<div><p>The block state.</p>
</div></blockquote>
<p><strong>B</strong> : <code class="docutils literal"><span class="pre">int</span></code></p>
<blockquote>
<div><p>The desired number of blocks.</p>
</div></blockquote>
<p><strong>nsweeps</strong> : <code class="docutils literal"><span class="pre">int</span></code> (optional, default: <code class="docutils literal"><span class="pre">10</span></code>)</p>
<blockquote>
<div><p>The number of sweeps done after each merge step to reach the local
minimum.</p>
</div></blockquote>
<p><strong>adaptive_sweeps</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, the number of sweeps necessary for the local minimum will
be estimated to be enough so that no more than <code class="docutils literal"><span class="pre">epsilon</span> <span class="pre">*</span> <span class="pre">N</span></code> nodes
changes their states in the last <code class="docutils literal"><span class="pre">nsweeps</span></code> sweeps.</p>
</div></blockquote>
<p><strong>epsilon</strong> : <code class="docutils literal"><span class="pre">float</span></code> (optional, default: <code class="docutils literal"><span class="pre">0</span></code>)</p>
<blockquote>
<div><p>Converge criterion for <code class="docutils literal"><span class="pre">adaptive_sweeps</span></code>.</p>
</div></blockquote>
<p><strong>anneal</strong> : pair of <code class="docutils literal"><span class="pre">floats</span></code> (optional, default: <code class="docutils literal"><span class="pre">(1.,</span> <span class="pre">1.)</span></code>)</p>
<blockquote>
<div><p>The first value specifies the starting value for  <code class="docutils literal"><span class="pre">beta</span></code> of the MCMC
steps, and the second value is the factor which is multiplied to <code class="docutils literal"><span class="pre">beta</span></code>
after each estimated equilibration (according to <code class="docutils literal"><span class="pre">nsweeps</span></code> and
<code class="docutils literal"><span class="pre">adaptive_sweeps</span></code>).</p>
</div></blockquote>
<p><strong>r</strong> : <code class="docutils literal"><span class="pre">float</span></code> (optional, default: <code class="docutils literal"><span class="pre">2.</span></code>)</p>
<blockquote>
<div><p>Agglomeration ratio for the merging steps. Each merge step will attempt
to find the best partition into <span class="math">\(B_{i-1} / r\)</span> blocks, where
<span class="math">\(B_{i-1}\)</span> is the number of blocks in the last step.</p>
</div></blockquote>
<p><strong>nmerge_sweeps</strong> : <cite>int</cite> (optional, default: <cite>10</cite>)</p>
<blockquote>
<div><p>The number of merge sweeps done, where in each sweep a better merge
candidate is searched for every block.</p>
</div></blockquote>
<p><strong>greedy</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, the value of <code class="docutils literal"><span class="pre">beta</span></code> of the MCMC steps are kept at
infinity for all steps. Otherwise they change according to the <code class="docutils literal"><span class="pre">anneal</span></code>
parameter.</p>
</div></blockquote>
<p><strong>c</strong> : <code class="docutils literal"><span class="pre">float</span></code> (optional, default: <code class="docutils literal"><span class="pre">0.0</span></code>)</p>
<blockquote>
<div><p>This parameter specifies how often fully random moves are attempted,
instead of more likely moves based on the inferred block partition.
For <code class="docutils literal"><span class="pre">c</span> <span class="pre">==</span> <span class="pre">0</span></code>, no fully random moves are attempted, and for <code class="docutils literal"><span class="pre">c</span> <span class="pre">==</span> <span class="pre">inf</span></code>
they are always attempted.</p>
</div></blockquote>
<p><strong>dl</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, the change in the whole description length will be
considered after each vertex move, not only the entropy.</p>
</div></blockquote>
<p><strong>dense</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, the &#8220;dense&#8221; variant of the entropy will be computed.</p>
</div></blockquote>
<p><strong>multigraph</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, the multigraph entropy will be used. Only has an effect
if <code class="docutils literal"><span class="pre">dense</span> <span class="pre">==</span> <span class="pre">True</span></code>.</p>
</div></blockquote>
<p><strong>sequential</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, the move attempts on the vertices are done in sequential
random order. Otherwise a total of <cite>N</cite> moves attempts are made, where
<cite>N</cite> is the number of vertices, where each vertex can be selected with
equal probability.</p>
</div></blockquote>
<p><strong>parallel</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, the updates are performed in parallel (multiple
threads).</p>
</div></blockquote>
<p><strong>vertices: ``list of ints`` (optional, default: ``None``)</strong></p>
<blockquote>
<div><p>A list of vertices which will be attempted to be moved. If <code class="docutils literal"><span class="pre">None</span></code>, all
vertices will be attempted.</p>
</div></blockquote>
<p><strong>checkpoint</strong> : function (optional, default: <code class="docutils literal"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>If provided, this function will be called after each call to
<a class="reference internal" href="#graph_tool.community.mcmc_sweep" title="graph_tool.community.mcmc_sweep"><code class="xref py py-func docutils literal"><span class="pre">mcmc_sweep()</span></code></a>. This can be used to store the current state, so it
can be continued later. The function must have the following signature:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">checkpoint</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">nmoves</span><span class="p">,</span> <span class="n">minimize_state</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>where <cite>state</cite> is either a <a class="reference internal" href="#graph_tool.community.BlockState" title="graph_tool.community.BlockState"><code class="xref py py-class docutils literal"><span class="pre">BlockState</span></code></a>
instance or <code class="docutils literal"><span class="pre">None</span></code>, <cite>S</cite> is the current entropy value, <cite>delta</cite> is
the entropy difference in the last MCMC sweep, and <cite>nmoves</cite> is the
number of accepted block membership moves. The <code class="docutils literal"><span class="pre">minimize_state</span></code>
argument is a <a class="reference internal" href="#graph_tool.community.MinimizeState" title="graph_tool.community.MinimizeState"><code class="xref py py-class docutils literal"><span class="pre">MinimizeState</span></code></a> instance which specifies the current
state of the algorithm, which can be stored via <a class="reference external" href="http://docs.python.org/3/library/pickle.html#module-pickle" title="(in Python v3.4)"><code class="xref py py-mod docutils literal"><span class="pre">pickle</span></code></a>, and
supplied via the <code class="docutils literal"><span class="pre">minimize_state</span></code> option below to continue from an
interrupted run.</p>
<p>This function will also be called when the MCMC has finished for the
current value of <span class="math">\(B\)</span>, in which case <code class="docutils literal"><span class="pre">state</span> <span class="pre">==</span> <span class="pre">None</span></code>, and the
remaining parameters will be zero, except the last.</p>
</div></blockquote>
<p><strong>minimize_state</strong> : <a class="reference internal" href="#graph_tool.community.MinimizeState" title="graph_tool.community.MinimizeState"><code class="xref py py-class docutils literal"><span class="pre">MinimizeState</span></code></a> (optional, default: <code class="docutils literal"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>If provided, this will specify an exact point of execution from which
the algorithm will continue. The expected object is a <a class="reference internal" href="#graph_tool.community.MinimizeState" title="graph_tool.community.MinimizeState"><code class="xref py py-class docutils literal"><span class="pre">MinimizeState</span></code></a>
instance which will be passed to the callback of the <code class="docutils literal"><span class="pre">checkpoint</span></code>
option above, and  can be stored by <a class="reference external" href="http://docs.python.org/3/library/pickle.html#module-pickle" title="(in Python v3.4)"><code class="xref py py-mod docutils literal"><span class="pre">pickle</span></code></a>.</p>
</div></blockquote>
<p><strong>verbose</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, verbose information is displayed.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>state</strong> : <a class="reference internal" href="#graph_tool.community.BlockState" title="graph_tool.community.BlockState"><code class="xref py py-class docutils literal"><span class="pre">BlockState</span></code></a></p>
<blockquote class="last">
<div><p>The new <a class="reference internal" href="#graph_tool.community.BlockState" title="graph_tool.community.BlockState"><code class="xref py py-class docutils literal"><span class="pre">BlockState</span></code></a> with <code class="docutils literal"><span class="pre">B</span></code> blocks.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This algorithm performs an agglomerative heuristic on the current block state,
where blocks are progressively merged together, using repeated applications of
the <a class="reference internal" href="#graph_tool.community.mcmc_sweep" title="graph_tool.community.mcmc_sweep"><code class="xref py py-func docutils literal"><span class="pre">mcmc_sweep()</span></code></a> moves, at different scales. See <a class="reference internal" href="#id69" id="id29">[peixoto-efficient-2014]</a>
for more details.</p>
<p>This algorithm has a complexity of <span class="math">\(O(N\ln^2 N)\)</span>, where <span class="math">\(N\)</span> is the
number of nodes in the network.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="id30" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[peixoto-efficient-2014]</td><td>Tiago P. Peixoto, &#8220;Efficient Monte Carlo and greedy
heuristic for the inference of stochastic block models&#8221;, Phys. Rev. E 89, 012804 (2014),
<a class="reference external" href="http://dx.doi.org/10.1103/PhysRevE.89.012804">DOI: 10.1103/PhysRevE.89.012804</a>, <a class="reference external" href="http://arxiv.org/abs/1310.4378">arXiv: 1310.4378</a>.</td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s">&quot;polblogs&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">GraphView</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">vfilt</span><span class="o">=</span><span class="n">gt</span><span class="o">.</span><span class="n">label_largest_component</span><span class="p">(</span><span class="n">gt</span><span class="o">.</span><span class="n">GraphView</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="bp">False</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">BlockState</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">B</span><span class="o">=</span><span class="n">g</span><span class="o">.</span><span class="n">num_vertices</span><span class="p">(),</span> <span class="n">deg_corr</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">multilevel_minimize</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">B</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gt</span><span class="o">.</span><span class="n">graph_draw</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">g</span><span class="o">.</span><span class="n">vp</span><span class="p">[</span><span class="s">&quot;pos&quot;</span><span class="p">],</span> <span class="n">vertex_fill_color</span><span class="o">=</span><span class="n">state</span><span class="o">.</span><span class="n">get_blocks</span><span class="p">(),</span> <span class="n">output</span><span class="o">=</span><span class="s">&quot;polblogs_agg.pdf&quot;</span><span class="p">)</span>
<span class="go">&lt;...&gt;</span>
</pre></div>
</div>
<div class="figure align-center" id="id92">
<img alt="_images/polblogs_agg.png" src="_images/polblogs_agg.png" />
<p class="caption"><span class="caption-text">Block partition of a political blogs network with <span class="math">\(B=2\)</span>.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="graph_tool.community.collect_edge_marginals">
<code class="descclassname">graph_tool.community.</code><code class="descname">collect_edge_marginals</code><span class="sig-paren">(</span><em>state</em>, <em>p=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/community/blockmodel.html#collect_edge_marginals"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.community.collect_edge_marginals" title="Permalink to this definition">¶</a></dt>
<dd><p>Collect the edge marginal histogram, which counts the number of times
the endpoints of each node have been assigned to a given block pair.</p>
<p>This should be called multiple times, after repeated runs of the
<a class="reference internal" href="#graph_tool.community.mcmc_sweep" title="graph_tool.community.mcmc_sweep"><code class="xref py py-func docutils literal"><span class="pre">mcmc_sweep()</span></code></a> function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>state</strong> : <a class="reference internal" href="#graph_tool.community.BlockState" title="graph_tool.community.BlockState"><code class="xref py py-class docutils literal"><span class="pre">BlockState</span></code></a></p>
<blockquote>
<div><p>The block state.</p>
</div></blockquote>
<p><strong>p</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal"><span class="pre">PropertyMap</span></code></a> (optional, default: <code class="docutils literal"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>Edge property map with vector-type values, storing the previous block
membership counts.  Each vector entry corresponds to <code class="docutils literal"><span class="pre">b[i]</span> <span class="pre">+</span> <span class="pre">B</span> <span class="pre">*</span>
<span class="pre">b[j]</span></code>, where <code class="docutils literal"><span class="pre">b</span></code> is the block membership and <code class="docutils literal"><span class="pre">i</span> <span class="pre">=</span> <span class="pre">min(source(e),</span>
<span class="pre">target(e))</span></code> and <code class="docutils literal"><span class="pre">j</span> <span class="pre">=</span> <span class="pre">max(source(e),</span> <span class="pre">target(e))</span></code>. If not provided, an
empty histogram will be created.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>p</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal"><span class="pre">PropertyMap</span></code></a> (optional, default: <code class="docutils literal"><span class="pre">None</span></code>)</p>
<blockquote class="last">
<div><p>Vertex property map with vector-type values, storing the accumulated
block membership counts.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s">&quot;polbooks&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">BlockState</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">B</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">deg_corr</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pe</span> <span class="o">=</span> <span class="bp">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1000</span><span class="p">):</span>        <span class="c"># remove part of the transient</span>
<span class="gp">... </span>    <span class="n">ds</span><span class="p">,</span> <span class="n">nmoves</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">mcmc_sweep</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1000</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">ds</span><span class="p">,</span> <span class="n">nmoves</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">mcmc_sweep</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">pe</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">collect_edge_marginals</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">pe</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gt</span><span class="o">.</span><span class="n">bethe_entropy</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">pe</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">17.609773262509986</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="graph_tool.community.collect_vertex_marginals">
<code class="descclassname">graph_tool.community.</code><code class="descname">collect_vertex_marginals</code><span class="sig-paren">(</span><em>state</em>, <em>p=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/community/blockmodel.html#collect_vertex_marginals"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.community.collect_vertex_marginals" title="Permalink to this definition">¶</a></dt>
<dd><p>Collect the vertex marginal histogram, which counts the number of times a
node was assigned to a given block.</p>
<p>This should be called multiple times, after repeated runs of the
<a class="reference internal" href="#graph_tool.community.mcmc_sweep" title="graph_tool.community.mcmc_sweep"><code class="xref py py-func docutils literal"><span class="pre">mcmc_sweep()</span></code></a> function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>state</strong> : <a class="reference internal" href="#graph_tool.community.BlockState" title="graph_tool.community.BlockState"><code class="xref py py-class docutils literal"><span class="pre">BlockState</span></code></a></p>
<blockquote>
<div><p>The block state.</p>
</div></blockquote>
<p><strong>p</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal"><span class="pre">PropertyMap</span></code></a> (optional, default: <code class="docutils literal"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>Vertex property map with vector-type values, storing the previous block
membership counts. If not provided, an empty histogram will be created.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>p</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal"><span class="pre">PropertyMap</span></code></a></p>
<blockquote class="last">
<div><p>Vertex property map with vector-type values, storing the accumulated
block membership counts.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s">&quot;polbooks&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">BlockState</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">B</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">deg_corr</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pv</span> <span class="o">=</span> <span class="bp">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1000</span><span class="p">):</span>        <span class="c"># remove part of the transient</span>
<span class="gp">... </span>    <span class="n">ds</span><span class="p">,</span> <span class="n">nmoves</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">mcmc_sweep</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1000</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">ds</span><span class="p">,</span> <span class="n">nmoves</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">mcmc_sweep</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">pv</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">collect_vertex_marginals</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">pv</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gt</span><span class="o">.</span><span class="n">mf_entropy</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">pv</span><span class="p">)</span>
<span class="go">20.117550557730116</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gt</span><span class="o">.</span><span class="n">graph_draw</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">g</span><span class="o">.</span><span class="n">vp</span><span class="p">[</span><span class="s">&quot;pos&quot;</span><span class="p">],</span> <span class="n">vertex_shape</span><span class="o">=</span><span class="s">&quot;pie&quot;</span><span class="p">,</span> <span class="n">vertex_pie_fractions</span><span class="o">=</span><span class="n">pv</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s">&quot;polbooks_blocks_soft_B4.pdf&quot;</span><span class="p">)</span>
<span class="go">&lt;...&gt;</span>
</pre></div>
</div>
<div class="figure align-center" id="id93">
<img alt="_images/polbooks_blocks_soft_B4.png" src="_images/polbooks_blocks_soft_B4.png" />
<p class="caption"><span class="caption-text">&#8220;Soft&#8221; block partition of a political books network with <span class="math">\(B=4\)</span>.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="graph_tool.community.mf_entropy">
<code class="descclassname">graph_tool.community.</code><code class="descname">mf_entropy</code><span class="sig-paren">(</span><em>state</em>, <em>p</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/community/blockmodel.html#mf_entropy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.community.mf_entropy" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the &#8220;mean field&#8221; entropy given the vertex block membership marginals.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>state</strong> : <a class="reference internal" href="#graph_tool.community.BlockState" title="graph_tool.community.BlockState"><code class="xref py py-class docutils literal"><span class="pre">BlockState</span></code></a></p>
<blockquote>
<div><p>The block state.</p>
</div></blockquote>
<p><strong>p</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal"><span class="pre">PropertyMap</span></code></a></p>
<blockquote>
<div><p>Vertex property map with vector-type values, storing the accumulated block
membership counts.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>Hmf</strong> : <code class="docutils literal"><span class="pre">float</span></code></p>
<blockquote class="last">
<div><p>The &#8220;mean field&#8221; entropy value (in <a class="reference external" href="http://en.wikipedia.org/wiki/Nat_%28information%29">nats</a>).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The &#8220;mean field&#8221; entropy is defined as,</p>
<div class="math">
\[H = - \sum_{v,r}\pi_r^v\ln\pi_r^v,\]</div>
<p>where <span class="math">\(\pi_r^v\)</span> is the marginal probability that vertex <span class="math">\(v\)</span>
belongs to block <span class="math">\(r\)</span>.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="mezard-information-2009" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[mezard-information-2009]</td><td>Marc Mézard, Andrea Montanari, &#8220;Information,
Physics, and Computation&#8221;, Oxford Univ Press, 2009.</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="graph_tool.community.bethe_entropy">
<code class="descclassname">graph_tool.community.</code><code class="descname">bethe_entropy</code><span class="sig-paren">(</span><em>state</em>, <em>p</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/community/blockmodel.html#bethe_entropy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.community.bethe_entropy" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Bethe entropy given the edge block membership marginals.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>state</strong> : <a class="reference internal" href="#graph_tool.community.BlockState" title="graph_tool.community.BlockState"><code class="xref py py-class docutils literal"><span class="pre">BlockState</span></code></a></p>
<blockquote>
<div><p>The block state.</p>
</div></blockquote>
<p><strong>p</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal"><span class="pre">PropertyMap</span></code></a></p>
<blockquote>
<div><p>Edge property map with vector-type values, storing the previous block
membership counts.  Each vector entry corresponds to <code class="docutils literal"><span class="pre">b[i]</span> <span class="pre">+</span> <span class="pre">B</span> <span class="pre">*</span>
<span class="pre">b[j]</span></code>, where <code class="docutils literal"><span class="pre">b</span></code> is the block membership and <code class="docutils literal"><span class="pre">i</span> <span class="pre">=</span> <span class="pre">min(source(e),</span>
<span class="pre">target(e))</span></code> and <code class="docutils literal"><span class="pre">j</span> <span class="pre">=</span> <span class="pre">max(source(e),</span> <span class="pre">target(e))</span></code>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>H</strong> : <code class="docutils literal"><span class="pre">float</span></code></p>
<blockquote>
<div><p>The Bethe entropy value (in <a class="reference external" href="http://en.wikipedia.org/wiki/Nat_%28information%29">nats</a>)</p>
</div></blockquote>
<p><strong>Hmf</strong> : <code class="docutils literal"><span class="pre">float</span></code></p>
<blockquote>
<div><p>The &#8220;mean field&#8221; entropy value (in <a class="reference external" href="http://en.wikipedia.org/wiki/Nat_%28information%29">nats</a>),
as would be returned by the <a class="reference internal" href="#graph_tool.community.mf_entropy" title="graph_tool.community.mf_entropy"><code class="xref py py-func docutils literal"><span class="pre">mf_entropy()</span></code></a> function.</p>
</div></blockquote>
<p><strong>pv</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal"><span class="pre">PropertyMap</span></code></a> (optional, default: <code class="docutils literal"><span class="pre">None</span></code>)</p>
<blockquote class="last">
<div><p>Vertex property map with vector-type values, storing the accumulated
block membership counts. These are the node marginals, as would be
returned by the <a class="reference internal" href="#graph_tool.community.collect_vertex_marginals" title="graph_tool.community.collect_vertex_marginals"><code class="xref py py-func docutils literal"><span class="pre">collect_vertex_marginals()</span></code></a> function.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The Bethe entropy is defined as,</p>
<div class="math">
\[H = -\sum_{e,(r,s)}\pi_{(r,s)}^e\ln\pi_{(r,s)}^e - \sum_{v,r}(1-k_i)\pi_r^v\ln\pi_r^v,\]</div>
<p>where <span class="math">\(\pi_{(r,s)}^e\)</span> is the marginal probability that the endpoints
of the edge <span class="math">\(e\)</span> belong to blocks <span class="math">\((r,s)\)</span>, and <span class="math">\(\pi_r^v\)</span> is
the marginal probability that vertex <span class="math">\(v\)</span> belongs to block <span class="math">\(r\)</span>,
and <span class="math">\(k_i\)</span> is the degree of vertex <span class="math">\(v\)</span> (or total degree for
directed graphs).</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="id35" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[mezard-information-2009]</td><td>Marc Mézard, Andrea Montanari, &#8220;Information,
Physics, and Computation&#8221;, Oxford Univ Press, 2009.</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="graph_tool.community.model_entropy">
<code class="descclassname">graph_tool.community.</code><code class="descname">model_entropy</code><span class="sig-paren">(</span><em>B</em>, <em>N</em>, <em>E</em>, <em>directed=False</em>, <em>nr=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/community/blockmodel.html#model_entropy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.community.model_entropy" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the amount of information necessary for the parameters of the traditional blockmodel ensemble, for <code class="docutils literal"><span class="pre">B</span></code> blocks, <code class="docutils literal"><span class="pre">N</span></code> vertices, <code class="docutils literal"><span class="pre">E</span></code> edges, and either a directed or undirected graph.</p>
<p>A traditional blockmodel is defined as a set of <span class="math">\(N\)</span> vertices which can
belong to one of <span class="math">\(B\)</span> blocks, and the matrix <span class="math">\(e_{rs}\)</span> describes
the number of edges from block <span class="math">\(r\)</span> to <span class="math">\(s\)</span> (or twice that number
if <span class="math">\(r=s\)</span> and the graph is undirected).</p>
<p>For an undirected graph, the number of distinct <span class="math">\(e_{rs}\)</span> matrices is given by,</p>
<div class="math">
\[\Omega_m = \left(\!\!{\left(\!{B \choose 2}\!\right) \choose E}\!\!\right)\]</div>
<p>and for a directed graph,</p>
<div class="math">
\[\Omega_m = \left(\!\!{B^2 \choose E}\!\!\right)\]</div>
<p>where <span class="math">\(\left(\!{n \choose k}\!\right) = {n+k-1\choose k}\)</span> is the
number of <span class="math">\(k\)</span> combinations with repetitions from a set of size <span class="math">\(n\)</span>.</p>
<p>The total information necessary to describe the model is then,</p>
<div class="math">
\[\mathcal{L}_t = \ln\Omega_m + \ln\left(\!\!{B \choose N}\!\!\right) + \ln N! - \sum_r \ln n_r!,\]</div>
<p>where the remaining term is the information necessary to describe the
block partition, where <span class="math">\(n_r\)</span> is the number of nodes in block <span class="math">\(r\)</span>.</p>
<p>If <code class="docutils literal"><span class="pre">nr</span></code> is <code class="docutils literal"><span class="pre">None</span></code>, it is assumed <span class="math">\(n_r=N/B\)</span>.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="id37" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[peixoto-parsimonious-2013]</td><td>Tiago P. Peixoto, &#8220;Parsimonious module inference in large networks&#8221;,
Phys. Rev. Lett. 110, 148701 (2013), <a class="reference external" href="http://dx.doi.org/10.1103/PhysRevLett.110.148701">DOI: 10.1103/PhysRevLett.110.148701</a>, <a class="reference external" href="http://arxiv.org/abs/1212.4794">arXiv: 1212.4794</a>.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="peixoto-hierarchical-2014" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[peixoto-hierarchical-2014]</td><td>Tiago P. Peixoto, &#8220;Hierarchical block structures and high-resolution
model selection in large networks &#8221;, Phys. Rev. X 4, 011047 (2014), <a class="reference external" href="http://dx.doi.org/10.1103/PhysRevX.4.011047">DOI: 10.1103/PhysRevX.4.011047</a>,
<a class="reference external" href="http://arxiv.org/abs/1310.4377">arXiv: 1310.4377</a>.</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="graph_tool.community.get_max_B">
<code class="descclassname">graph_tool.community.</code><code class="descname">get_max_B</code><span class="sig-paren">(</span><em>N</em>, <em>E</em>, <em>directed=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/community/blockmodel.html#get_max_B"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.community.get_max_B" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the maximum detectable number of blocks, obtained by minimizing:</p>
<div class="math">
\[\mathcal{L}_t(B, N, E) - E\ln B\]</div>
<p>where <span class="math">\(\mathcal{L}_t(B, N, E)\)</span> is the information necessary to
describe a traditional blockmodel with <cite>B</cite> blocks, <cite>N</cite> nodes and <cite>E</cite>
edges (see <a class="reference internal" href="#graph_tool.community.model_entropy" title="graph_tool.community.model_entropy"><code class="xref py py-func docutils literal"><span class="pre">model_entropy()</span></code></a>).</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="id40" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[peixoto-parsimonious-2013]</td><td>Tiago P. Peixoto, &#8220;Parsimonious module inference in large networks&#8221;,
Phys. Rev. Lett. 110, 148701 (2013), <a class="reference external" href="http://dx.doi.org/10.1103/PhysRevLett.110.148701">DOI: 10.1103/PhysRevLett.110.148701</a>, <a class="reference external" href="http://arxiv.org/abs/1212.4794">arXiv: 1212.4794</a>.</td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">gt</span><span class="o">.</span><span class="n">get_max_B</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="mf">1e6</span><span class="p">,</span> <span class="n">E</span><span class="o">=</span><span class="mf">5e6</span><span class="p">)</span>
<span class="go">1572</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="graph_tool.community.get_akc">
<code class="descclassname">graph_tool.community.</code><code class="descname">get_akc</code><span class="sig-paren">(</span><em>B</em>, <em>I</em>, <em>N=inf</em>, <em>directed=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/community/blockmodel.html#get_akc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.community.get_akc" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the minimum value of the average degree of the network, so that some block structure with <span class="math">\(B\)</span> blocks can be detected, according to the minimum description length criterion.</p>
<p>This is obtained by solving</p>
<div class="math">
\[\Sigma_b = \mathcal{L}_t(B, N, E) - E\mathcal{I}_{t/c} = 0,\]</div>
<p>where <span class="math">\(\mathcal{L}_{t}\)</span> is the necessary information to describe the
blockmodel parameters (see <a class="reference internal" href="#graph_tool.community.model_entropy" title="graph_tool.community.model_entropy"><code class="xref py py-func docutils literal"><span class="pre">model_entropy()</span></code></a>), and
<span class="math">\(\mathcal{I}_{t/c}\)</span> characterizes the planted block structure, and is
given by</p>
<div class="math">
\[\begin{split}\mathcal{I}_t &amp;= \sum_{rs}m_{rs}\ln\left(\frac{m_{rs}}{w_rw_s}\right),\\
\mathcal{I}_c &amp;= \sum_{rs}m_{rs}\ln\left(\frac{m_{rs}}{m_rm_s}\right),\end{split}\]</div>
<p>where <span class="math">\(m_{rs} = e_{rs}/2E\)</span> (or <span class="math">\(m_{rs} = e_{rs}/E\)</span> for directed
graphs) and <span class="math">\(w_r=n_r/N\)</span>. We note that <span class="math">\(\mathcal{I}_{t/c}\in[0,
\ln B]\)</span>. In the case where <span class="math">\(E \gg B^2\)</span>, this simplifies to</p>
<div class="math">
\[\begin{split}\left&lt;k\right&gt;_c &amp;= \frac{2\ln B}{\mathcal{I}_{t/c}},\\
\left&lt;k^{-/+}\right&gt;_c &amp;= \frac{\ln B}{\mathcal{I}_{t/c}},\end{split}\]</div>
<p>for undirected and directed graphs, respectively. This limit is assumed if
<code class="docutils literal"><span class="pre">N</span> <span class="pre">==</span> <span class="pre">inf</span></code>.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="id42" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[peixoto-parsimonious-2013]</td><td>Tiago P. Peixoto, &#8220;Parsimonious module inference in large networks&#8221;,
Phys. Rev. Lett. 110, 148701 (2013), <a class="reference external" href="http://dx.doi.org/10.1103/PhysRevLett.110.148701">DOI: 10.1103/PhysRevLett.110.148701</a>, <a class="reference external" href="http://arxiv.org/abs/1212.4794">arXiv: 1212.4794</a>.</td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">gt</span><span class="o">.</span><span class="n">get_akc</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">log</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">/</span> <span class="mi">100</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="go">2.414413200430159</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="graph_tool.community.condensation_graph">
<code class="descclassname">graph_tool.community.</code><code class="descname">condensation_graph</code><span class="sig-paren">(</span><em>g</em>, <em>prop</em>, <em>vweight=None</em>, <em>eweight=None</em>, <em>avprops=None</em>, <em>aeprops=None</em>, <em>self_loops=False</em>, <em>parallel_edges=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/community/blockmodel.html#condensation_graph"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.community.condensation_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Obtain the condensation graph, where each vertex with the same &#8216;prop&#8217; value is condensed in one vertex.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>g</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.Graph" title="graph_tool.Graph"><code class="xref py py-class docutils literal"><span class="pre">Graph</span></code></a></p>
<blockquote>
<div><p>Graph to be modelled.</p>
</div></blockquote>
<p><strong>prop</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal"><span class="pre">PropertyMap</span></code></a></p>
<blockquote>
<div><p>Vertex property map with the community partition.</p>
</div></blockquote>
<p><strong>vweight</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal"><span class="pre">PropertyMap</span></code></a> (optional, default: None)</p>
<blockquote>
<div><p>Vertex property map with the optional vertex weights.</p>
</div></blockquote>
<p><strong>eweight</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal"><span class="pre">PropertyMap</span></code></a> (optional, default: None)</p>
<blockquote>
<div><p>Edge property map with the optional edge weights.</p>
</div></blockquote>
<p><strong>avprops</strong> : list of <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal"><span class="pre">PropertyMap</span></code></a> (optional, default: None)</p>
<blockquote>
<div><p>If provided, the sum of each property map in this list for
each vertex in the condensed graph will be computed and returned.</p>
</div></blockquote>
<p><strong>aeprops</strong> : list of <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal"><span class="pre">PropertyMap</span></code></a> (optional, default: None)</p>
<blockquote>
<div><p>If provided, the sum of each property map in this list for
each edge in the condensed graph will be computed and returned.</p>
</div></blockquote>
<p><strong>self_loops</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, self-loops due to intra-block edges are also included in
the condensation graph.</p>
</div></blockquote>
<p><strong>parallel_edges</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, parallel edges will be included in the condensation graph,
such that the total number of edges will be the same as in the original
graph.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>condensation_graph</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.Graph" title="graph_tool.Graph"><code class="xref py py-class docutils literal"><span class="pre">Graph</span></code></a></p>
<blockquote>
<div><p>The community network</p>
</div></blockquote>
<p><strong>prop</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal"><span class="pre">PropertyMap</span></code></a></p>
<blockquote>
<div><p>The community values.</p>
</div></blockquote>
<p><strong>vcount</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal"><span class="pre">PropertyMap</span></code></a></p>
<blockquote>
<div><p>A vertex property map with the vertex count for each community.</p>
</div></blockquote>
<p><strong>ecount</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal"><span class="pre">PropertyMap</span></code></a></p>
<blockquote>
<div><p>An edge property map with the inter-community edge count for each edge.</p>
</div></blockquote>
<p><strong>va</strong> : list of <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal"><span class="pre">PropertyMap</span></code></a></p>
<blockquote>
<div><p>A list of vertex property maps with summed values of the properties
passed via the <code class="docutils literal"><span class="pre">avprops</span></code> parameter.</p>
</div></blockquote>
<p><strong>ea</strong> : list of <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal"><span class="pre">PropertyMap</span></code></a></p>
<blockquote class="last">
<div><p>A list of edge property maps with summed values of the properties
passed via the <code class="docutils literal"><span class="pre">avprops</span></code> parameter.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#graph_tool.community.community_structure" title="graph_tool.community.community_structure"><code class="xref py py-obj docutils literal"><span class="pre">community_structure</span></code></a></dt>
<dd>Obtain the community structure</dd>
<dt><a class="reference internal" href="#graph_tool.community.modularity" title="graph_tool.community.modularity"><code class="xref py py-obj docutils literal"><span class="pre">modularity</span></code></a></dt>
<dd>Calculate the network modularity</dd>
<dt><a class="reference internal" href="#graph_tool.community.condensation_graph" title="graph_tool.community.condensation_graph"><code class="xref py py-obj docutils literal"><span class="pre">condensation_graph</span></code></a></dt>
<dd>Network of communities, or blocks</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Each vertex in the condensation graph represents one community in the
original graph (vertices with the same &#8216;prop&#8217; value), and the edges
represent existent edges between vertices of the respective communities in
the original graph.</p>
<p class="rubric">Examples</p>
<p>Let&#8217;s first obtain the best block partition with <code class="docutils literal"><span class="pre">B=5</span></code>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s">&quot;polbooks&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">BlockState</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">B</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">deg_corr</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1000</span><span class="p">):</span>        <span class="c"># remove part of the transient</span>
<span class="gp">... </span>    <span class="n">ds</span><span class="p">,</span> <span class="n">nmoves</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">mcmc_sweep</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1000</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">ds</span><span class="p">,</span> <span class="n">nmoves</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">mcmc_sweep</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="s">&quot;inf&quot;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">get_blocks</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gt</span><span class="o">.</span><span class="n">graph_draw</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">g</span><span class="o">.</span><span class="n">vp</span><span class="p">[</span><span class="s">&quot;pos&quot;</span><span class="p">],</span> <span class="n">vertex_fill_color</span><span class="o">=</span><span class="n">b</span><span class="p">,</span> <span class="n">vertex_shape</span><span class="o">=</span><span class="n">b</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s">&quot;polbooks_blocks_B5.pdf&quot;</span><span class="p">)</span>
<span class="go">&lt;...&gt;</span>
</pre></div>
</div>
<p>Now we get the condensation graph:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">bg</span><span class="p">,</span> <span class="n">bb</span><span class="p">,</span> <span class="n">vcount</span><span class="p">,</span> <span class="n">ecount</span><span class="p">,</span> <span class="n">avp</span><span class="p">,</span> <span class="n">aep</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">condensation_graph</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">avprops</span><span class="o">=</span><span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">vp</span><span class="p">[</span><span class="s">&quot;pos&quot;</span><span class="p">]],</span> <span class="n">self_loops</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pos</span> <span class="o">=</span> <span class="n">avp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">bg</span><span class="o">.</span><span class="n">vertices</span><span class="p">():</span>
<span class="gp">... </span>    <span class="n">pos</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">a</span> <span class="o">/=</span> <span class="n">vcount</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gt</span><span class="o">.</span><span class="n">graph_draw</span><span class="p">(</span><span class="n">bg</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">avp</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">vertex_fill_color</span><span class="o">=</span><span class="n">bb</span><span class="p">,</span> <span class="n">vertex_shape</span><span class="o">=</span><span class="n">bb</span><span class="p">,</span>
<span class="gp">... </span>              <span class="n">vertex_size</span><span class="o">=</span><span class="n">gt</span><span class="o">.</span><span class="n">prop_to_size</span><span class="p">(</span><span class="n">vcount</span><span class="p">,</span> <span class="n">mi</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">ma</span><span class="o">=</span><span class="mi">100</span><span class="p">),</span>
<span class="gp">... </span>              <span class="n">edge_pen_width</span><span class="o">=</span><span class="n">gt</span><span class="o">.</span><span class="n">prop_to_size</span><span class="p">(</span><span class="n">ecount</span><span class="p">,</span> <span class="n">mi</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">ma</span><span class="o">=</span><span class="mi">10</span><span class="p">),</span>
<span class="gp">... </span>              <span class="n">output</span><span class="o">=</span><span class="s">&quot;polbooks_blocks_B5_cond.pdf&quot;</span><span class="p">)</span>
<span class="go">&lt;...&gt;</span>
</pre></div>
</div>
<div class="figure align-center" id="id94">
<img alt="_images/polbooks_blocks_B5.png" src="_images/polbooks_blocks_B5.png" />
<p class="caption"><span class="caption-text">Block partition of a political books network with <span class="math">\(B=5\)</span>.</span></p>
</div>
<div class="figure align-center" id="id95">
<img alt="_images/polbooks_blocks_B5_cond.png" src="_images/polbooks_blocks_B5_cond.png" />
<p class="caption"><span class="caption-text">Condensation graph of the obtained block partition.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="graph_tool.community.minimize_nested_blockmodel_dl">
<code class="descclassname">graph_tool.community.</code><code class="descname">minimize_nested_blockmodel_dl</code><span class="sig-paren">(</span><em>g</em>, <em>Bs=None</em>, <em>bs=None</em>, <em>min_B=None</em>, <em>max_B=None</em>, <em>max_b=None</em>, <em>deg_corr=True</em>, <em>overlap=False</em>, <em>ec=None</em>, <em>layers=False</em>, <em>confine_layers=False</em>, <em>nonoverlap_init=False</em>, <em>dl=True</em>, <em>multigraph=True</em>, <em>dense=False</em>, <em>eweight=None</em>, <em>vweight=None</em>, <em>clabel=None</em>, <em>frozen_levels=None</em>, <em>nsweeps=10</em>, <em>adaptive_sweeps=True</em>, <em>epsilon=0.001</em>, <em>c=0</em>, <em>nmerge_sweeps=10</em>, <em>r=2</em>, <em>sparse_thresh=100</em>, <em>sequential=True</em>, <em>parallel=False</em>, <em>verbose=False</em>, <em>checkpoint=None</em>, <em>minimize_state=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/community/nested_blockmodel.html#minimize_nested_blockmodel_dl"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.community.minimize_nested_blockmodel_dl" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the block hierarchy of an unspecified size which minimizes the description
length of the network, according to the nested stochastic blockmodel ensemble which
best describes it.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>g</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.Graph" title="graph_tool.Graph"><code class="xref py py-class docutils literal"><span class="pre">Graph</span></code></a></p>
<blockquote>
<div><p>Graph being used.</p>
</div></blockquote>
<p><strong>Bs</strong> : list of <code class="docutils literal"><span class="pre">int</span></code> (optional, default: <code class="docutils literal"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>Initial number of blocks for each hierarchy level.</p>
</div></blockquote>
<p><strong>bs</strong> : list of <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal"><span class="pre">PropertyMap</span></code></a> or <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> instances (optional, default: <code class="docutils literal"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>Initial block labels on the vertices, for each hierarchy level.</p>
</div></blockquote>
<p><strong>min_B</strong> : <code class="docutils literal"><span class="pre">int</span></code> (optional, default: <code class="docutils literal"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>Minimum number of blocks at the lowest level.</p>
</div></blockquote>
<p><strong>max_B</strong> : <code class="docutils literal"><span class="pre">int</span></code> (optional, default: <code class="docutils literal"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>Maximum number of blocks at the lowest level.</p>
</div></blockquote>
<p><strong>max_b</strong> : <code class="docutils literal"><span class="pre">int</span></code> (optional, default: <code class="docutils literal"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>Block partition used for the maximum number of blocks at the lowest
level.</p>
</div></blockquote>
<p><strong>deg_corr</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, the degree-corrected version of the blockmodel ensemble
will be used in the bottom level, otherwise the traditional variant will
be used.</p>
</div></blockquote>
<p><strong>overlap</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, the mixed-membership version of the blockmodel will be used.</p>
</div></blockquote>
<p><strong>ec</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal"><span class="pre">PropertyMap</span></code></a> (optional, default: <code class="docutils literal"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>If provided, this should be an edge <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal"><span class="pre">PropertyMap</span></code></a>
containing edge covariates that will split the network in discrete
layers.</p>
</div></blockquote>
<p><strong>layers</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, and <cite>´ec`</cite> is not <code class="docutils literal"><span class="pre">None</span></code>, the &#8220;independent layers&#8221;
version of the model is used, instead of the &#8220;edge covariates&#8221; version.</p>
</div></blockquote>
<p><strong>confine_layers</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, and <cite>´ec`</cite> is not <code class="docutils literal"><span class="pre">None</span></code> and <code class="docutils literal"><span class="pre">overlap</span> <span class="pre">==</span> <span class="pre">True</span></code>, the
half edges will only be moved in such a way that inside each layer the
group membership remains non-overlapping.</p>
</div></blockquote>
<p><strong>nonoverlap_init</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, and <cite>´overlap == True`</cite>, the minimization starts by first
fitting the non-overlapping model, and using that as a starting state.</p>
</div></blockquote>
<p><strong>dl</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, the change in the whole description length will be
considered after each vertex move, not only the entropy.</p>
</div></blockquote>
<p><strong>multigraph</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, the multigraph entropy will be used.</p>
</div></blockquote>
<p><strong>dense</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, the &#8220;dense&#8221; variant of the entropy will be computed.</p>
</div></blockquote>
<p><strong>eweight</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal"><span class="pre">PropertyMap</span></code></a> (optional, default: <code class="docutils literal"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>Edge weights (i.e. multiplicity).</p>
</div></blockquote>
<p><strong>vweight</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal"><span class="pre">PropertyMap</span></code></a> (optional, default: <code class="docutils literal"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>Vertex weights (i.e. multiplicity).</p>
</div></blockquote>
<p><strong>clabel</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal"><span class="pre">PropertyMap</span></code></a> (optional, default: <code class="docutils literal"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>Constraint labels on the vertices. If supplied, vertices with different
label values will not be clustered in the same group.</p>
</div></blockquote>
<p><strong>frozen_levels</strong> : <a class="reference external" href="http://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.4)"><code class="xref py py-class docutils literal"><span class="pre">list</span></code></a> (optional, default: <code class="docutils literal"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>List of levels (<a href="#id44"><span class="problematic" id="id45">``</span></a>int``s) which will remain unmodified during the
algorithm.</p>
</div></blockquote>
<p><strong>nsweeps</strong> : <code class="docutils literal"><span class="pre">int</span></code> (optional, default: <code class="docutils literal"><span class="pre">10</span></code>)</p>
<blockquote>
<div><p>The number of sweeps done after each merge step to reach the local
minimum.</p>
</div></blockquote>
<p><strong>epsilon</strong> : <code class="docutils literal"><span class="pre">float</span></code> (optional, default: <code class="docutils literal"><span class="pre">0</span></code>)</p>
<blockquote>
<div><p>The number of sweeps necessary for the local minimum will
be estimated to be enough so that no more than <code class="docutils literal"><span class="pre">epsilon</span> <span class="pre">*</span> <span class="pre">N</span></code> nodes
changes their states in the last <code class="docutils literal"><span class="pre">nsweeps</span></code> sweeps.</p>
</div></blockquote>
<p><strong>c</strong> : <code class="docutils literal"><span class="pre">float</span></code> (optional, default: <code class="docutils literal"><span class="pre">0.</span></code>)</p>
<blockquote>
<div><p>This parameter specifies how often fully random moves are attempted,
instead of more likely moves based on the inferred block partition.
For <code class="docutils literal"><span class="pre">c</span> <span class="pre">==</span> <span class="pre">0</span></code>, no fully random moves are attempted, and for <code class="docutils literal"><span class="pre">c</span> <span class="pre">==</span> <span class="pre">inf</span></code>
they are always attempted.</p>
</div></blockquote>
<p><strong>nmerge_sweeps</strong> : <cite>int</cite> (optional, default: <cite>10</cite>)</p>
<blockquote>
<div><p>The number of merge sweeps done, where in each sweep a better merge
candidate is searched for every block.</p>
</div></blockquote>
<p><strong>r</strong> : <code class="docutils literal"><span class="pre">float</span></code> (optional, default: <code class="docutils literal"><span class="pre">2.</span></code>)</p>
<blockquote>
<div><p>Agglomeration ratio for the merging steps. Each merge step will attempt
to find the best partition into <span class="math">\(B_{i-1} / r\)</span> blocks, where
<span class="math">\(B_{i-1}\)</span> is the number of blocks in the last step.</p>
</div></blockquote>
<p><strong>sparse_thresh</strong> : <code class="docutils literal"><span class="pre">int</span></code> (optional, default: <code class="docutils literal"><span class="pre">100</span></code>)</p>
<blockquote>
<div><p>If the number of blocks at some level is larger than this value, the
sparse entropy will be used to find the best partition, but the dense
entropy will be used to compare different partitions.</p>
</div></blockquote>
<p><strong>sequential</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, the move attempts on the vertices are done in sequential
random order. Otherwise a total of <code class="docutils literal"><span class="pre">N</span></code> moves attempts are made, where
<cite>N</cite> is the number of vertices, where each vertex can be selected with
equal probability.</p>
</div></blockquote>
<p><strong>checkpoint</strong> : function (optional, default: <code class="docutils literal"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>If provided, this function will be called after each call to
<a class="reference internal" href="#graph_tool.community.mcmc_sweep" title="graph_tool.community.mcmc_sweep"><code class="xref py py-func docutils literal"><span class="pre">mcmc_sweep()</span></code></a>. This can be used to store the current state, so it
can be continued later. The function must have the following signature:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">checkpoint</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">nmoves</span><span class="p">,</span> <span class="n">minimize_state</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>where <cite>state</cite> is either a <a class="reference internal" href="#graph_tool.community.NestedBlockState" title="graph_tool.community.NestedBlockState"><code class="xref py py-class docutils literal"><span class="pre">NestedBlockState</span></code></a>
instance or <code class="docutils literal"><span class="pre">None</span></code>, <cite>L</cite> is the current description length, <code class="docutils literal"><span class="pre">delta</span></code> is
the entropy difference in the last MCMC sweep, and <code class="docutils literal"><span class="pre">nmoves</span></code> is the
number of accepted block membership moves. The <code class="docutils literal"><span class="pre">minimize_state</span></code>
argument is a <a class="reference internal" href="#graph_tool.community.NestedMinimizeState" title="graph_tool.community.NestedMinimizeState"><code class="xref py py-class docutils literal"><span class="pre">NestedMinimizeState</span></code></a>
instance which specifies the current state of the algorithm, which can
be stored via <a class="reference external" href="http://docs.python.org/3/library/pickle.html#module-pickle" title="(in Python v3.4)"><code class="xref py py-mod docutils literal"><span class="pre">pickle</span></code></a>, and supplied via the <code class="docutils literal"><span class="pre">minimize_state</span></code>
option below to continue from an interrupted run.</p>
<p>This function will also be called when the MCMC has finished for the
current value of <span class="math">\(B\)</span>, in which case <code class="docutils literal"><span class="pre">state</span> <span class="pre">==</span> <span class="pre">None</span></code>, and the
remaining parameters will be zero, except the last.</p>
</div></blockquote>
<p><strong>minimize_state</strong> : <a class="reference internal" href="#graph_tool.community.MinimizeState" title="graph_tool.community.MinimizeState"><code class="xref py py-class docutils literal"><span class="pre">MinimizeState</span></code></a> (optional, default: <code class="docutils literal"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>If provided, this will specify an exact point of execution from which
the algorithm will continue. The expected object is a
<a class="reference internal" href="#graph_tool.community.NestedMinimizeState" title="graph_tool.community.NestedMinimizeState"><code class="xref py py-class docutils literal"><span class="pre">NestedMinimizeState</span></code></a>
instance which will be passed to the callback of the <code class="docutils literal"><span class="pre">checkpoint</span></code>
option above, and  can be stored by <a class="reference external" href="http://docs.python.org/3/library/pickle.html#module-pickle" title="(in Python v3.4)"><code class="xref py py-mod docutils literal"><span class="pre">pickle</span></code></a>.</p>
</div></blockquote>
<p><strong>verbose</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, verbose information is displayed.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>state</strong> : <a class="reference internal" href="#graph_tool.community.NestedBlockState" title="graph_tool.community.NestedBlockState"><code class="xref py py-class docutils literal"><span class="pre">NestedBlockState</span></code></a></p>
<blockquote class="last">
<div><p>The nested block state.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This algorithm attempts to find a block partition hierarchy of an unspecified size
which minimizes the description length of the network,</p>
<div class="math">
\[\Sigma = \mathcal{L}_{t/c} + \mathcal{S}_n,\]</div>
<p>where <span class="math">\(\mathcal{S}_{n}\)</span> is the nested blockmodel entropy given by</p>
<div class="math">
\[\mathcal{S}_n  = \mathcal{S}_{t/c}(\{e^0_{rs}\}, \{n^0_r\}) + \sum_{l=1}^LS_m(\{e^l_{rs}\}, \{n^l_r\}).\]</div>
<p>with <span class="math">\(\mathcal{S}_{t/c}\)</span> and <span class="math">\(\mathcal{S}_{m}\)</span> described in the docstring of
<a class="reference internal" href="#graph_tool.community.BlockState.entropy" title="graph_tool.community.BlockState.entropy"><code class="xref py py-meth docutils literal"><span class="pre">entropy()</span></code></a>, and <span class="math">\(\{e^l_{rs}\}\)</span>
and <span class="math">\(\{n^l_r\}\)</span> are the edge and node counts at hierarchical level <span class="math">\(l\)</span>.
Additionally <span class="math">\(\mathcal{L}_{t/c}\)</span> is the information necessary to
describe the block partitions, i.e. <span class="math">\(\mathcal{L}_t=\sum_{l=0}^L\mathcal{L}^l_t\)</span>, with</p>
<div class="math">
\[\mathcal{L}^l_t = \ln\left(\!\!{B_l\choose B_{l-1}}\!\!\right) + \ln B_{l-1}! - \sum_r \ln n_r^l!.\]</div>
<p>See <a class="reference internal" href="#id70" id="id46">[peixoto-hierarchical-2014]</a> for details on the algorithm.</p>
<p>This algorithm has a complexity of <span class="math">\(O(N \ln^2 N)\)</span>, where <span class="math">\(N\)</span>
is the number of nodes in the network.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="id47" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[peixoto-hierarchical-2014]</td><td>Tiago P. Peixoto, &#8220;Hierarchical block structures and high-resolution
model selection in large networks &#8221;, Phys. Rev. X 4, 011047 (2014), <a class="reference external" href="http://dx.doi.org/10.1103/PhysRevX.4.011047">DOI: 10.1103/PhysRevX.4.011047</a>,
<a class="reference external" href="http://arxiv.org/abs/1310.4377">arXiv: 1310.4377</a>.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="id48" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[peixoto-efficient-2014]</td><td>Tiago P. Peixoto, &#8220;Efficient Monte Carlo and greedy
heuristic for the inference of stochastic block models&#8221;, Phys. Rev. E 89, 012804 (2014),
<a class="reference external" href="http://dx.doi.org/10.1103/PhysRevE.89.012804">DOI: 10.1103/PhysRevE.89.012804</a>, <a class="reference external" href="http://arxiv.org/abs/1310.4378">arXiv: 1310.4378</a>.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="id49" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[peixoto-model-2015]</td><td>Tiago P. Peixoto, &#8220;Model selection and hypothesis
testing for large-scale network models with overlapping groups&#8221;,
Phys. Rev. X 5, 011033 (2015), <a class="reference external" href="http://dx.doi.org/10.1103/PhysRevX.5.011033">DOI: 10.1103/PhysRevX.5.011033</a>,
<a class="reference external" href="http://arxiv.org/abs/1409.3059">arXiv: 1409.3059</a>.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="id50" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[peixoto-inferring-2015]</td><td>Tiago P. Peixoto, &#8220;Inferring the mesoscale
structure of layered, edge-valued and time-varying networks&#8221;,
<a class="reference external" href="http://arxiv.org/abs/1504.02381">arXiv: 1504.02381</a></td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s">&quot;power&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">minimize_nested_blockmodel_dl</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">deg_corr</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gt</span><span class="o">.</span><span class="n">draw_hierarchy</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s">&quot;power_nested_mdl.pdf&quot;</span><span class="p">)</span>
<span class="go">(...)</span>
</pre></div>
</div>
<div class="figure align-center" id="id96">
<img alt="_images/power_nested_mdl.png" src="_images/power_nested_mdl.png" />
<p class="caption"><span class="caption-text">Hierarchical Block partition of a power-grid network, which minimizes
the description length of the network according to the nested
(degree-corrected) stochastic blockmodel.</span></p>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s">&quot;celegansneural&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">minimize_nested_blockmodel_dl</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">deg_corr</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">overlap</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
<span class="gp">... </span>                                         <span class="n">nonoverlap_init</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">dl</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gt</span><span class="o">.</span><span class="n">draw_hierarchy</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s">&quot;celegans_nested_mdl_overlap.pdf&quot;</span><span class="p">)</span>
<span class="go">(...)</span>
</pre></div>
</div>
<div class="figure align-center" id="id97">
<img alt="_images/celegans_nested_mdl_overlap.png" src="_images/celegans_nested_mdl_overlap.png" />
<p class="caption"><span class="caption-text">Overlapping block partition of the C. elegans neural network, which
minimizes the description length of the network according to the nested
overlapping stochastic blockmodel.</span></p>
</div>
</dd></dl>

<dl class="class">
<dt id="graph_tool.community.NestedBlockState">
<em class="property">class </em><code class="descclassname">graph_tool.community.</code><code class="descname">NestedBlockState</code><span class="sig-paren">(</span><em>g</em>, <em>eweight=None</em>, <em>vweight=None</em>, <em>ec=None</em>, <em>bs=None</em>, <em>Bs=None</em>, <em>deg_corr=True</em>, <em>overlap=False</em>, <em>layers=False</em>, <em>clabel=None</em>, <em>max_BE=1000</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/community/nested_blockmodel.html#NestedBlockState"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.community.NestedBlockState" title="Permalink to this definition">¶</a></dt>
<dd><p>This class encapsulates the nested block state of a given graph.</p>
<p>This must be instantiated and used by functions such as <a class="reference internal" href="#graph_tool.community.nested_mcmc_sweep" title="graph_tool.community.nested_mcmc_sweep"><code class="xref py py-func docutils literal"><span class="pre">nested_mcmc_sweep()</span></code></a>.</p>
<p>The instances of this class contain a data member called <code class="docutils literal"><span class="pre">levels</span></code>, which
is a list of <a class="reference internal" href="#graph_tool.community.BlockState" title="graph_tool.community.BlockState"><code class="xref py py-class docutils literal"><span class="pre">BlockState</span></code></a> (or
<a class="reference internal" href="#graph_tool.community.OverlapBlockState" title="graph_tool.community.OverlapBlockState"><code class="xref py py-class docutils literal"><span class="pre">OverlapBlockState</span></code></a>) instances, containing the
entire nested hierarchy.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>g</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.Graph" title="graph_tool.Graph"><code class="xref py py-class docutils literal"><span class="pre">Graph</span></code></a></p>
<blockquote>
<div><p>Graph to be used.</p>
</div></blockquote>
<p><strong>eweight</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal"><span class="pre">PropertyMap</span></code></a> (optional, default: <code class="docutils literal"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>Edge weights (i.e. multiplicity).</p>
</div></blockquote>
<p><strong>vweight</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal"><span class="pre">PropertyMap</span></code></a> (optional, default: <code class="docutils literal"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>Vertex weights (i.e. multiplicity).</p>
</div></blockquote>
<p><strong>bs</strong> : list of <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal"><span class="pre">PropertyMap</span></code></a> or <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.9)"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> instances (optional, default: <code class="docutils literal"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>Initial block labels on the vertices, for each hierarchy level.</p>
</div></blockquote>
<p><strong>Bs</strong> : list of <code class="docutils literal"><span class="pre">int</span></code> (optional, default: <code class="docutils literal"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>Number of blocks for each hierarchy level.</p>
</div></blockquote>
<p><strong>deg_corr</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, the degree-corrected version of the blockmodel ensemble will
be used in the bottom level, otherwise the traditional variant will be used.</p>
</div></blockquote>
<p><strong>overlap</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, the mixed-membership version of the blockmodel will be used
at the lowest level.</p>
</div></blockquote>
<p><strong>clabel</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal"><span class="pre">PropertyMap</span></code></a> (optional, default: <code class="docutils literal"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>Constraint labels on the vertices. If supplied, vertices with different
label values will not be clustered in the same group.</p>
</div></blockquote>
<p><strong>max_BE</strong> : <code class="docutils literal"><span class="pre">int</span></code> (optional, default: <code class="docutils literal"><span class="pre">1000</span></code>)</p>
<blockquote class="last">
<div><p>If the number of blocks exceeds this number, a sparse representation of
the block graph is used, which is slightly less efficient, but uses less
memory,</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="graph_tool.community.NestedBlockState.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>ec=None</em>, <em>layers=None</em>, <em>deg_corr=None</em>, <em>overlap=None</em>, <em>clabel=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/community/nested_blockmodel.html#NestedBlockState.copy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.community.NestedBlockState.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Copies the block state. The parameters override the state properties, and
have the same meaning as in the constructor..</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.community.NestedBlockState.level_entropy">
<code class="descname">level_entropy</code><span class="sig-paren">(</span><em>l</em>, <em>complete=True</em>, <em>dense=False</em>, <em>multigraph=True</em>, <em>norm=True</em>, <em>dl_ent=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/community/nested_blockmodel.html#NestedBlockState.level_entropy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.community.NestedBlockState.level_entropy" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the description length of hierarchy level l.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>l</strong> : <code class="docutils literal"><span class="pre">int</span></code></p>
<blockquote>
<div><p>Hierarchy level.</p>
</div></blockquote>
<p><strong>complete</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, the complete entropy will be returned, including constant
terms not relevant to the block partition.</p>
</div></blockquote>
<p><strong>dense</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, the &#8220;dense&#8221; variant of the entropy will be computed.</p>
</div></blockquote>
<p><strong>multigraph</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, the multigraph entropy will be used.</p>
</div></blockquote>
<p><strong>norm</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, the entropy will be &#8220;normalized&#8221; by dividing by the
number of edges.</p>
</div></blockquote>
<p><strong>dl_ent</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">False</span></code>)</p>
<blockquote class="last">
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, the description length of the degree sequence will be
approximated by its entropy.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="graph_tool.community.NestedBlockState.entropy">
<code class="descname">entropy</code><span class="sig-paren">(</span><em>complete=True</em>, <em>dense=False</em>, <em>multigraph=True</em>, <em>norm=False</em>, <em>dl_ent=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/community/nested_blockmodel.html#NestedBlockState.entropy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.community.NestedBlockState.entropy" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the description length of the entire hierarchy.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>complete</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, the complete entropy will be returned, including constant
terms not relevant to the block partition.</p>
</div></blockquote>
<p><strong>dense</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, the &#8220;dense&#8221; variant of the entropy will be computed.</p>
</div></blockquote>
<p><strong>multigraph</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, the multigraph entropy will be used.</p>
</div></blockquote>
<p><strong>norm</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, the entropy will be &#8220;normalized&#8221; by dividing by the
number of edges.</p>
</div></blockquote>
<p><strong>dl_ent</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">False</span></code>)</p>
<blockquote class="last">
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, the description length of the degree sequence will be
approximated by its entropy.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="graph_tool.community.NestedBlockState.get_bstack">
<code class="descname">get_bstack</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/community/nested_blockmodel.html#NestedBlockState.get_bstack"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.community.NestedBlockState.get_bstack" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the nested levels as individual graphs.</p>
<p>This returns a list of <a class="reference internal" href="graph_tool.html#graph_tool.Graph" title="graph_tool.Graph"><code class="xref py py-class docutils literal"><span class="pre">Graph</span></code></a> instances
representing the inferred hierarchy at each level. Each graph has two
internal vertex and edge property maps named &#8220;count&#8221; which correspond to
the vertex and edge counts at the lower level, respectively. Additionally,
an internal vertex property map named &#8220;b&#8221; specifies the block partition.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.community.NestedBlockState.project_level">
<code class="descname">project_level</code><span class="sig-paren">(</span><em>l</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/community/nested_blockmodel.html#NestedBlockState.project_level"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.community.NestedBlockState.project_level" title="Permalink to this definition">¶</a></dt>
<dd><p>Project the partition at level <code class="docutils literal"><span class="pre">l</span></code> onto the lowest level, and return the
corresponding <a class="reference internal" href="#graph_tool.community.BlockState" title="graph_tool.community.BlockState"><code class="xref py py-class docutils literal"><span class="pre">BlockState</span></code></a> (or
<a class="reference internal" href="#graph_tool.community.OverlapBlockState" title="graph_tool.community.OverlapBlockState"><code class="xref py py-class docutils literal"><span class="pre">OverlapBlockState</span></code></a>).</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.community.NestedBlockState.merge_layers">
<code class="descname">merge_layers</code><span class="sig-paren">(</span><em>l_src</em>, <em>l_tgt</em>, <em>revert=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/community/nested_blockmodel.html#NestedBlockState.merge_layers"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.community.NestedBlockState.merge_layers" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="graph_tool.community.NestedBlockState.print_summary">
<code class="descname">print_summary</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/community/nested_blockmodel.html#NestedBlockState.print_summary"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.community.NestedBlockState.print_summary" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="graph_tool.community.NestedMinimizeState">
<em class="property">class </em><code class="descclassname">graph_tool.community.</code><code class="descname">NestedMinimizeState</code><a class="reference internal" href="_modules/graph_tool/community/nested_blockmodel.html#NestedMinimizeState"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.community.NestedMinimizeState" title="Permalink to this definition">¶</a></dt>
<dd><p>This object stores information regarding the current entropy minimization
state, so that the algorithms can resume previously started runs.
This object can be saved to disk via the <a class="reference external" href="http://docs.python.org/3/library/pickle.html#module-pickle" title="(in Python v3.4)"><code class="xref py py-mod docutils literal"><span class="pre">pickle</span></code></a> interface.</p>
<dl class="method">
<dt id="graph_tool.community.NestedMinimizeState.clear">
<code class="descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/community/nested_blockmodel.html#NestedMinimizeState.clear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.community.NestedMinimizeState.clear" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="graph_tool.community.NestedMinimizeState.sync">
<code class="descname">sync</code><span class="sig-paren">(</span><em>state</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/community/nested_blockmodel.html#NestedMinimizeState.sync"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.community.NestedMinimizeState.sync" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="graph_tool.community.NestedMinimizeState.delete">
<code class="descname">delete</code><span class="sig-paren">(</span><em>l</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/community/nested_blockmodel.html#NestedMinimizeState.delete"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.community.NestedMinimizeState.delete" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="graph_tool.community.NestedMinimizeState.insert">
<code class="descname">insert</code><span class="sig-paren">(</span><em>l</em>, <em>state</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/community/nested_blockmodel.html#NestedMinimizeState.insert"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.community.NestedMinimizeState.insert" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="graph_tool.community.NestedMinimizeState.mark_level">
<code class="descname">mark_level</code><span class="sig-paren">(</span><em>l</em>, <em>done</em>, <em>state</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/community/nested_blockmodel.html#NestedMinimizeState.mark_level"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.community.NestedMinimizeState.mark_level" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="graph_tool.community.NestedMinimizeState.clear_mstate">
<code class="descname">clear_mstate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/community/nested_blockmodel.html#NestedMinimizeState.clear_mstate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.community.NestedMinimizeState.clear_mstate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="graph_tool.community.init_nested_state">
<code class="descclassname">graph_tool.community.</code><code class="descname">init_nested_state</code><span class="sig-paren">(</span><em>g</em>, <em>Bs</em>, <em>ec=None</em>, <em>deg_corr=True</em>, <em>overlap=False</em>, <em>layers=False</em>, <em>confine_layers=False</em>, <em>dl=False</em>, <em>dense=False</em>, <em>multigraph=True</em>, <em>eweight=None</em>, <em>vweight=None</em>, <em>clabel=None</em>, <em>nsweeps=10</em>, <em>epsilon=0.0</em>, <em>r=2</em>, <em>nmerge_sweeps=10</em>, <em>adaptive_sweeps=True</em>, <em>c=0</em>, <em>sequential=True</em>, <em>parallel=False</em>, <em>sparse_thresh=100</em>, <em>checkpoint=None</em>, <em>minimize_state=None</em>, <em>max_BE=1000</em>, <em>verbose=False</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/community/nested_blockmodel.html#init_nested_state"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.community.init_nested_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes a nested block hierarchy with sizes given by <code class="docutils literal"><span class="pre">Bs</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>g</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.Graph" title="graph_tool.Graph"><code class="xref py py-class docutils literal"><span class="pre">Graph</span></code></a></p>
<blockquote>
<div><p>The graph being modelled.</p>
</div></blockquote>
<p><strong>Bs</strong> : list of <code class="docutils literal"><span class="pre">int</span></code> (optional, default: <code class="docutils literal"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>Number of blocks for each hierarchy level.</p>
</div></blockquote>
<p><strong>deg_corr</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, the degree-corrected version of the blockmodel ensemble will
be used in the bottom level, otherwise the traditional variant will be used.</p>
</div></blockquote>
<p><strong>dense</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, the &#8220;dense&#8221; variant of the entropy will be computed.</p>
</div></blockquote>
<p><strong>eweight</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal"><span class="pre">PropertyMap</span></code></a> (optional, default: <code class="docutils literal"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>Edge weights (i.e. multiplicity).</p>
</div></blockquote>
<p><strong>vweight</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal"><span class="pre">PropertyMap</span></code></a> (optional, default: <code class="docutils literal"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>Vertex weights (i.e. multiplicity).</p>
</div></blockquote>
<p><strong>nsweeps</strong> : <code class="docutils literal"><span class="pre">int</span></code> (optional, default: <code class="docutils literal"><span class="pre">10</span></code>)</p>
<blockquote>
<div><p>The number of sweeps done after each merge step to reach the local
minimum.</p>
</div></blockquote>
<p><strong>epsilon</strong> : <code class="docutils literal"><span class="pre">float</span></code> (optional, default: <code class="docutils literal"><span class="pre">0</span></code>)</p>
<blockquote>
<div><p>Converge criterion for <code class="docutils literal"><span class="pre">adaptive_sweeps</span></code>.</p>
</div></blockquote>
<p><strong>r</strong> : <code class="docutils literal"><span class="pre">float</span></code> (optional, default: <code class="docutils literal"><span class="pre">2.</span></code>)</p>
<blockquote>
<div><p>Agglomeration ratio for the merging steps. Each merge step will attempt
to find the best partition into <span class="math">\(B_{i-1} / r\)</span> blocks, where
<span class="math">\(B_{i-1}\)</span> is the number of blocks in the last step.</p>
</div></blockquote>
<p><strong>nmerge_sweeps</strong> : <cite>int</cite> (optional, default: <cite>10</cite>)</p>
<blockquote>
<div><p>The number of merge sweeps done, where in each sweep a better merge
candidate is searched for every block.</p>
</div></blockquote>
<p><strong>c</strong> : <code class="docutils literal"><span class="pre">float</span></code> (optional, default: <code class="docutils literal"><span class="pre">0.</span></code>)</p>
<blockquote>
<div><p>This parameter specifies how often fully random moves are attempted,
instead of more likely moves based on the inferred block partition.
For <code class="docutils literal"><span class="pre">c</span> <span class="pre">==</span> <span class="pre">0</span></code>, no fully random moves are attempted, and for <code class="docutils literal"><span class="pre">c</span> <span class="pre">==</span> <span class="pre">inf</span></code>
they are always attempted.</p>
</div></blockquote>
<p><strong>sequential</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, the move attempts on the vertices are done in sequential
random order. Otherwise a total of <cite>N</cite> moves attempts are made, where
<cite>N</cite> is the number of vertices, where each vertex can be selected with
equal probability.</p>
</div></blockquote>
<p><strong>sparse_thresh</strong> : <code class="docutils literal"><span class="pre">int</span></code> (optional, default: <code class="docutils literal"><span class="pre">100</span></code>)</p>
<blockquote>
<div><p>If the number of nodes in the higher level multigraphs exceeds this
number, the sparse entropy will be used to find the best partition,
but the dense entropy will be used to compare different partitions.</p>
</div></blockquote>
<p><strong>checkpoint</strong> : function (optional, default: <code class="docutils literal"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>If provided, this function will be called after each call to
<a class="reference internal" href="#graph_tool.community.mcmc_sweep" title="graph_tool.community.mcmc_sweep"><code class="xref py py-func docutils literal"><span class="pre">mcmc_sweep()</span></code></a>. This can be used to store the current state, so it
can be continued later. The function must have the following signature:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">checkpoint</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">nmoves</span><span class="p">,</span> <span class="n">minimize_state</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>where <cite>state</cite> is either a <a class="reference internal" href="#graph_tool.community.NestedBlockState" title="graph_tool.community.NestedBlockState"><code class="xref py py-class docutils literal"><span class="pre">NestedBlockState</span></code></a>
instance or <code class="docutils literal"><span class="pre">None</span></code>, <cite>S</cite> is the current entropy value, <cite>delta</cite> is
the entropy difference in the last MCMC sweep, and <cite>nmoves</cite> is the
number of accepted block membership moves. The <code class="docutils literal"><span class="pre">minimize_state</span></code>
argument is a <a class="reference internal" href="#graph_tool.community.NestedMinimizeState" title="graph_tool.community.NestedMinimizeState"><code class="xref py py-class docutils literal"><span class="pre">NestedMinimizeState</span></code></a> instance which specifies
the current state of the algorithm, which can be stored via <a class="reference external" href="http://docs.python.org/3/library/pickle.html#module-pickle" title="(in Python v3.4)"><code class="xref py py-mod docutils literal"><span class="pre">pickle</span></code></a>,
and supplied via the <code class="docutils literal"><span class="pre">minimize_state</span></code> option below to continue from an
interrupted run.</p>
<p>This function will also be called when the MCMC has finished for the
current value of <span class="math">\(B\)</span>, in which case <code class="docutils literal"><span class="pre">state</span> <span class="pre">==</span> <span class="pre">None</span></code>, and the
remaining parameters will be zero, except the last.</p>
</div></blockquote>
<p><strong>minimize_state</strong> : <a class="reference internal" href="#graph_tool.community.NestedMinimizeState" title="graph_tool.community.NestedMinimizeState"><code class="xref py py-class docutils literal"><span class="pre">NestedMinimizeState</span></code></a> (optional, default: <code class="docutils literal"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>If provided, this will specify an exact point of execution from which
the algorithm will continue. The expected object is a
<a class="reference internal" href="#graph_tool.community.NestedMinimizeState" title="graph_tool.community.NestedMinimizeState"><code class="xref py py-class docutils literal"><span class="pre">NestedMinimizeState</span></code></a> instance which will be passed to the
callback of the <code class="docutils literal"><span class="pre">checkpoint</span></code> option above, and  can be stored by
<a class="reference external" href="http://docs.python.org/3/library/pickle.html#module-pickle" title="(in Python v3.4)"><code class="xref py py-mod docutils literal"><span class="pre">pickle</span></code></a>.</p>
</div></blockquote>
<p><strong>verbose</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, verbose information is displayed.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>state</strong> : <a class="reference internal" href="#graph_tool.community.NestedBlockState" title="graph_tool.community.NestedBlockState"><code class="xref py py-class docutils literal"><span class="pre">NestedBlockState</span></code></a></p>
<blockquote class="last">
<div><p>The initialized nested state.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This algorithm performs an agglomerative heuristic on each level  of the
network, via the function <a class="reference internal" href="#graph_tool.community.multilevel_minimize" title="graph_tool.community.multilevel_minimize"><code class="xref py py-func docutils literal"><span class="pre">multilevel_minimize()</span></code></a>.</p>
<p>This algorithm has worst-case complexity of <span class="math">\(O(N\ln^2 N \times L)\)</span>,
where  <span class="math">\(N\)</span> is the number of nodes in the network, and <span class="math">\(L\)</span> is
the depth of the hierarchy.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="id55" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[peixoto-efficient-2014]</td><td>Tiago P. Peixoto, &#8220;Efficient Monte Carlo and greedy
heuristic for the inference of stochastic block models&#8221;, Phys. Rev. E 89, 012804 (2014),
<a class="reference external" href="http://dx.doi.org/10.1103/PhysRevE.89.012804">DOI: 10.1103/PhysRevE.89.012804</a>, <a class="reference external" href="http://arxiv.org/abs/1310.4378">arXiv: 1310.4378</a>.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="id56" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[peixoto-hierarchical-2014]</td><td>Tiago P. Peixoto, &#8220;Hierarchical block structures and high-resolution
model selection in large networks &#8221;, Phys. Rev. X 4, 011047 (2014), <a class="reference external" href="http://dx.doi.org/10.1103/PhysRevX.4.011047">DOI: 10.1103/PhysRevX.4.011047</a>,
<a class="reference external" href="http://arxiv.org/abs/1310.4377">arXiv: 1310.4377</a>.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="id57" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[peixoto-model-2015]</td><td>Tiago P. Peixoto, &#8220;Model selection and hypothesis
testing for large-scale network models with overlapping groups&#8221;,
Phys. Rev. X 5, 011033 (2015), <a class="reference external" href="http://dx.doi.org/10.1103/PhysRevX.5.011033">DOI: 10.1103/PhysRevX.5.011033</a>,
<a class="reference external" href="http://arxiv.org/abs/1409.3059">arXiv: 1409.3059</a>.</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="graph_tool.community.nested_mcmc_sweep">
<code class="descclassname">graph_tool.community.</code><code class="descname">nested_mcmc_sweep</code><span class="sig-paren">(</span><em>state</em>, <em>beta=1.0</em>, <em>c=1.0</em>, <em>dl=False</em>, <em>sequential=True</em>, <em>parallel=False</em>, <em>verbose=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/community/nested_blockmodel.html#nested_mcmc_sweep"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.community.nested_mcmc_sweep" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs a Markov chain Monte Carlo sweep on all levels of the hierarchy.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>state</strong> : <a class="reference internal" href="#graph_tool.community.NestedBlockState" title="graph_tool.community.NestedBlockState"><code class="xref py py-class docutils literal"><span class="pre">NestedBlockState</span></code></a></p>
<blockquote>
<div><p>The nested block state.</p>
</div></blockquote>
<p><strong>beta</strong> : <cite>float</cite> (optional, default: <cite>1.0</cite>)</p>
<blockquote>
<div><p>The inverse temperature parameter <span class="math">\(\beta\)</span>.</p>
</div></blockquote>
<p><strong>c</strong> : <code class="docutils literal"><span class="pre">float</span></code> (optional, default: <code class="docutils literal"><span class="pre">1.0</span></code>)</p>
<blockquote>
<div><p>This parameter specifies how often fully random moves are attempted,
instead of more likely moves based on the inferred block partition.
For <code class="docutils literal"><span class="pre">c</span> <span class="pre">==</span> <span class="pre">0</span></code>, no fully random moves are attempted, and for <code class="docutils literal"><span class="pre">c</span> <span class="pre">==</span> <span class="pre">inf</span></code>
they are always attempted.</p>
</div></blockquote>
<p><strong>dl</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, the change in the whole description length will be
considered after each vertex move, not only the entropy.</p>
</div></blockquote>
<p><strong>sequential</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, the move attempts on the vertices are done in sequential
random order. Otherwise a total of <cite>N</cite> moves attempts are made, where
<cite>N</cite> is the number of vertices, where each vertex can be selected with
equal probability.</p>
</div></blockquote>
<p><strong>verbose</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, verbose information is displayed.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dS_moves</strong> : list of (<code class="docutils literal"><span class="pre">float</span></code>, <code class="docutils literal"><span class="pre">int</span></code>) tuples</p>
<blockquote class="last">
<div><p>The entropy difference (per edge) and number of accepted block membership
moves after a full sweep for each level.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This algorithm performs a Markov chain Monte Carlo sweep on each level of the
network, via the function <a class="reference internal" href="#graph_tool.community.mcmc_sweep" title="graph_tool.community.mcmc_sweep"><code class="xref py py-func docutils literal"><span class="pre">mcmc_sweep()</span></code></a>.</p>
<p>This algorithm has a worse-case complexity of <span class="math">\(O(E \times L)\)</span>, where
<span class="math">\(E\)</span> is the number of edges in the network, and <span class="math">\(L\)</span> is the depth
of the hierarchy.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="id61" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[peixoto-efficient-2014]</td><td>Tiago P. Peixoto, &#8220;Efficient Monte Carlo and greedy
heuristic for the inference of stochastic block models&#8221;, Phys. Rev. E 89, 012804 (2014),
<a class="reference external" href="http://dx.doi.org/10.1103/PhysRevE.89.012804">DOI: 10.1103/PhysRevE.89.012804</a>, <a class="reference external" href="http://arxiv.org/abs/1310.4378">arXiv: 1310.4378</a>.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="id62" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[peixoto-hierarchical-2014]</td><td>Tiago P. Peixoto, &#8220;Hierarchical block structures and high-resolution
model selection in large networks &#8221;, Phys. Rev. X 4, 011047 (2014), <a class="reference external" href="http://dx.doi.org/10.1103/PhysRevX.4.011047">DOI: 10.1103/PhysRevX.4.011047</a>,
<a class="reference external" href="http://arxiv.org/abs/1310.4377">arXiv: 1310.4377</a>.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="id63" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[peixoto-model-2015]</td><td>Tiago P. Peixoto, &#8220;Model selection and hypothesis
testing for large-scale network models with overlapping groups&#8221;,
Phys. Rev. X 5, 011033 (2015), <a class="reference external" href="http://dx.doi.org/10.1103/PhysRevX.5.011033">DOI: 10.1103/PhysRevX.5.011033</a>,
<a class="reference external" href="http://arxiv.org/abs/1409.3059">arXiv: 1409.3059</a>.</td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s">&quot;polbooks&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">NestedBlockState</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">Bs</span><span class="o">=</span><span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">deg_corr</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ret</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">nested_mcmc_sweep</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>
<span class="go">[(0.0, 0), (0.0, 0), (0.0, 0), (0.0, 0), (0.0, 0)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="graph_tool.community.nested_tree_sweep">
<code class="descclassname">graph_tool.community.</code><code class="descname">nested_tree_sweep</code><span class="sig-paren">(</span><em>state</em>, <em>min_B=None</em>, <em>max_B=None</em>, <em>max_b=None</em>, <em>nsweeps=10</em>, <em>epsilon=0.0</em>, <em>r=2.0</em>, <em>nmerge_sweeps=10</em>, <em>adaptive_sweeps=True</em>, <em>c=0</em>, <em>dl=False</em>, <em>dense=False</em>, <em>multigraph=True</em>, <em>sequential=True</em>, <em>parallel=False</em>, <em>sparse_thresh=100</em>, <em>checkpoint=None</em>, <em>minimize_state=None</em>, <em>frozen_levels=None</em>, <em>confine_layers=False</em>, <em>verbose=False</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/community/nested_blockmodel.html#nested_tree_sweep"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.community.nested_tree_sweep" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs one greedy sweep in the entire hierarchy tree, attempting to
decrease its description length.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>state</strong> : <a class="reference internal" href="#graph_tool.community.NestedBlockState" title="graph_tool.community.NestedBlockState"><code class="xref py py-class docutils literal"><span class="pre">NestedBlockState</span></code></a></p>
<blockquote>
<div><p>The nested block state.</p>
</div></blockquote>
<p><strong>min_B</strong> : <code class="docutils literal"><span class="pre">int</span></code> (optional, default: <code class="docutils literal"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>Minimum number of blocks at the lowest level.</p>
</div></blockquote>
<p><strong>max_B</strong> : <code class="docutils literal"><span class="pre">int</span></code> (optional, default: <code class="docutils literal"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>Maximum number of blocks at the lowest level.</p>
</div></blockquote>
<p><strong>max_b</strong> : <code class="docutils literal"><span class="pre">int</span></code> (optional, default: <code class="docutils literal"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>Block partition used for the maximum number of blocks at the lowest
level.</p>
</div></blockquote>
<p><strong>nsweeps</strong> : <code class="docutils literal"><span class="pre">int</span></code> (optional, default: <code class="docutils literal"><span class="pre">10</span></code>)</p>
<blockquote>
<div><p>The number of sweeps done after each merge step to reach the local
minimum.</p>
</div></blockquote>
<p><strong>epsilon</strong> : <code class="docutils literal"><span class="pre">float</span></code> (optional, default: <code class="docutils literal"><span class="pre">0</span></code>)</p>
<blockquote>
<div><p>Converge criterion for <code class="docutils literal"><span class="pre">adaptive_sweeps</span></code>.</p>
</div></blockquote>
<p><strong>r</strong> : <code class="docutils literal"><span class="pre">float</span></code> (optional, default: <code class="docutils literal"><span class="pre">2.</span></code>)</p>
<blockquote>
<div><p>Agglomeration ratio for the merging steps. Each merge step will attempt
to find the best partition into <span class="math">\(B_{i-1} / r\)</span> blocks, where
<span class="math">\(B_{i-1}\)</span> is the number of blocks in the last step.</p>
</div></blockquote>
<p><strong>nmerge_sweeps</strong> : <cite>int</cite> (optional, default: <cite>10</cite>)</p>
<blockquote>
<div><p>The number of merge sweeps done, where in each sweep a better merge
candidate is searched for every block.</p>
</div></blockquote>
<p><strong>c</strong> : <code class="docutils literal"><span class="pre">float</span></code> (optional, default: <code class="docutils literal"><span class="pre">1.0</span></code>)</p>
<blockquote>
<div><p>This parameter specifies how often fully random moves are attempted,
instead of more likely moves based on the inferred block partition.
For <code class="docutils literal"><span class="pre">c</span> <span class="pre">==</span> <span class="pre">0</span></code>, no fully random moves are attempted, and for <code class="docutils literal"><span class="pre">c</span> <span class="pre">==</span> <span class="pre">inf</span></code>
they are always attempted.</p>
</div></blockquote>
<p><strong>dense</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, the &#8220;dense&#8221; variant of the entropy will be computed.</p>
</div></blockquote>
<p><strong>sequential</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, the move attempts on the vertices are done in sequential
random order. Otherwise a total of <cite>N</cite> moves attempts are made, where
<cite>N</cite> is the number of vertices, where each vertex can be selected with
equal probability.</p>
</div></blockquote>
<p><strong>sparse_thresh</strong> : <code class="docutils literal"><span class="pre">int</span></code> (optional, default: <code class="docutils literal"><span class="pre">100</span></code>)</p>
<blockquote>
<div><p>If the number of nodes in the higher level multigraphs exceeds this
number, the sparse entropy will be used to find the best partition,
but the dense entropy will be used to compare different partitions.</p>
</div></blockquote>
<p><strong>checkpoint</strong> : function (optional, default: <code class="docutils literal"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>If provided, this function will be called after each call to
<a class="reference internal" href="#graph_tool.community.mcmc_sweep" title="graph_tool.community.mcmc_sweep"><code class="xref py py-func docutils literal"><span class="pre">mcmc_sweep()</span></code></a>. This can be used to store the current state, so it
can be continued later. The function must have the following signature:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">checkpoint</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">nmoves</span><span class="p">,</span> <span class="n">minimize_state</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>where <cite>state</cite> is either a <a class="reference internal" href="#graph_tool.community.NestedBlockState" title="graph_tool.community.NestedBlockState"><code class="xref py py-class docutils literal"><span class="pre">NestedBlockState</span></code></a>
instance or <code class="docutils literal"><span class="pre">None</span></code>, <cite>S</cite> is the current entropy value, <cite>delta</cite> is
the entropy difference in the last MCMC sweep, and <cite>nmoves</cite> is the
number of accepted block membership moves. The <code class="docutils literal"><span class="pre">minimize_state</span></code>
argument is a <a class="reference internal" href="#graph_tool.community.NestedMinimizeState" title="graph_tool.community.NestedMinimizeState"><code class="xref py py-class docutils literal"><span class="pre">NestedMinimizeState</span></code></a> instance which specifies
the current state of the algorithm, which can be stored via <a class="reference external" href="http://docs.python.org/3/library/pickle.html#module-pickle" title="(in Python v3.4)"><code class="xref py py-mod docutils literal"><span class="pre">pickle</span></code></a>,
and supplied via the <code class="docutils literal"><span class="pre">minimize_state</span></code> option below to continue from an
interrupted run.</p>
<p>This function will also be called when the MCMC has finished for the
current value of <span class="math">\(B\)</span>, in which case <code class="docutils literal"><span class="pre">state</span> <span class="pre">==</span> <span class="pre">None</span></code>, and the
remaining parameters will be zero, except the last.</p>
</div></blockquote>
<p><strong>minimize_state</strong> : <a class="reference internal" href="#graph_tool.community.NestedMinimizeState" title="graph_tool.community.NestedMinimizeState"><code class="xref py py-class docutils literal"><span class="pre">NestedMinimizeState</span></code></a> (optional, default: <code class="docutils literal"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>If provided, this will specify an exact point of execution from which
the algorithm will continue. The expected object is a
<a class="reference internal" href="#graph_tool.community.NestedMinimizeState" title="graph_tool.community.NestedMinimizeState"><code class="xref py py-class docutils literal"><span class="pre">NestedMinimizeState</span></code></a> instance which will be passed to the
callback of the <code class="docutils literal"><span class="pre">checkpoint</span></code> option above, and  can be stored by
<a class="reference external" href="http://docs.python.org/3/library/pickle.html#module-pickle" title="(in Python v3.4)"><code class="xref py py-mod docutils literal"><span class="pre">pickle</span></code></a>.</p>
</div></blockquote>
<p><strong>frozen_levels</strong> : <a class="reference external" href="http://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.4)"><code class="xref py py-class docutils literal"><span class="pre">list</span></code></a> (optional, default: <code class="docutils literal"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>List of levels (<a href="#id67"><span class="problematic" id="id68">``</span></a>int``s) which will remain unmodified during the
algorithm.</p>
</div></blockquote>
<p><strong>verbose</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If <code class="docutils literal"><span class="pre">True</span></code>, verbose information is displayed.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dS</strong> : <code class="docutils literal"><span class="pre">float</span></code></p>
<blockquote class="last">
<div><p>The description length difference (per edge) after the move.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This algorithm performs a constrained agglomerative heuristic on each level
of the network, via the function <a class="reference internal" href="#graph_tool.community.multilevel_minimize" title="graph_tool.community.multilevel_minimize"><code class="xref py py-func docutils literal"><span class="pre">multilevel_minimize()</span></code></a>.</p>
<p>This algorithm has worst-case complexity of <span class="math">\(O(N\ln^2 N \times L)\)</span>,
where  <span class="math">\(N\)</span> is the number of nodes in the network, and <span class="math">\(L\)</span> is
the depth of the hierarchy.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="id69" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[peixoto-efficient-2014]</td><td>Tiago P. Peixoto, &#8220;Efficient Monte Carlo and greedy
heuristic for the inference of stochastic block models&#8221;, Phys. Rev. E 89, 012804 (2014),
<a class="reference external" href="http://dx.doi.org/10.1103/PhysRevE.89.012804">DOI: 10.1103/PhysRevE.89.012804</a>, <a class="reference external" href="http://arxiv.org/abs/1310.4378">arXiv: 1310.4378</a>.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="id70" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[peixoto-hierarchical-2014]</td><td>Tiago P. Peixoto, &#8220;Hierarchical block structures and high-resolution
model selection in large networks &#8221;, Phys. Rev. X 4, 011047 (2014), <a class="reference external" href="http://dx.doi.org/10.1103/PhysRevX.4.011047">DOI: 10.1103/PhysRevX.4.011047</a>,
<a class="reference external" href="http://arxiv.org/abs/1310.4377">arXiv: 1310.4377</a>.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="id71" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[peixoto-model-2015]</td><td>Tiago P. Peixoto, &#8220;Model selection and hypothesis
testing for large-scale network models with overlapping groups&#8221;,
Phys. Rev. X 5, 011033 (2015), <a class="reference external" href="http://dx.doi.org/10.1103/PhysRevX.5.011033">DOI: 10.1103/PhysRevX.5.011033</a>,
<a class="reference external" href="http://arxiv.org/abs/1409.3059">arXiv: 1409.3059</a>.</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="graph_tool.community.get_hierarchy_tree">
<code class="descclassname">graph_tool.community.</code><code class="descname">get_hierarchy_tree</code><span class="sig-paren">(</span><em>state</em>, <em>empty_branches=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/community/nested_blockmodel.html#get_hierarchy_tree"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.community.get_hierarchy_tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Obtain the nested hierarchical levels as a tree.</p>
<p>This transforms a <code class="xref py py-class docutils literal"><span class="pre">NestedBlockState</span></code> instance into a
single <a class="reference internal" href="graph_tool.html#graph_tool.Graph" title="graph_tool.Graph"><code class="xref py py-class docutils literal"><span class="pre">Graph</span></code></a> instance containing the hierarchy tree.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>tree</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.Graph" title="graph_tool.Graph"><code class="xref py py-class docutils literal"><span class="pre">Graph</span></code></a></p>
<blockquote>
<div><p>A directed graph, where vertices are blocks, and a directed edge points
to an upper to a lower level in the hierarchy.</p>
</div></blockquote>
<p><strong>label</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal"><span class="pre">PropertyMap</span></code></a></p>
<blockquote>
<div><p>A vertex property map containing the block label for each node.</p>
</div></blockquote>
<p><strong>order</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal"><span class="pre">PropertyMap</span></code></a></p>
<blockquote>
<div><p>A vertex property map containing the relative ordering of each layer
according to the total degree of the groups at the specific levels.</p>
</div></blockquote>
<p><strong>empty_branches</strong> : <code class="docutils literal"><span class="pre">bool</span></code> (optional, default: <code class="docutils literal"><span class="pre">True</span></code>)</p>
<blockquote class="last">
<div><p>If <code class="docutils literal"><span class="pre">empty_branches</span> <span class="pre">==</span> <span class="pre">False</span></code>, dangling branches at the upper layers
will be pruned.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="graph_tool.community.get_block_edge_gradient">
<code class="descclassname">graph_tool.community.</code><code class="descname">get_block_edge_gradient</code><span class="sig-paren">(</span><em>g</em>, <em>be</em>, <em>cmap=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/community/overlap_blockmodel.html#get_block_edge_gradient"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.community.get_block_edge_gradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Get edge gradients corresponding to the block membership at the endpoints of
the edges given by the <code class="docutils literal"><span class="pre">be</span></code> edge property map.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>g</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.Graph" title="graph_tool.Graph"><code class="xref py py-class docutils literal"><span class="pre">Graph</span></code></a></p>
<blockquote>
<div><p>The graph.</p>
</div></blockquote>
<p><strong>be</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal"><span class="pre">PropertyMap</span></code></a></p>
<blockquote>
<div><p>Vector-valued edge property map with the block membership at each
endpoint.</p>
</div></blockquote>
<p><strong>cmap</strong> : <a class="reference external" href="http://matplotlib.sourceforge.net/api/colors_api.html#matplotlib.colors.Colormap" title="(in Matplotlib v1.4.3)"><code class="xref py py-class docutils literal"><span class="pre">matplotlib.colors.Colormap</span></code></a> (optional, default: <code class="docutils literal"><span class="pre">default_cm</span></code>)</p>
<blockquote>
<div><p>Color map used to construct the gradient.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>cp</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal"><span class="pre">PropertyMap</span></code></a></p>
<blockquote class="last">
<div><p>A vector-valued edge property map containing a color gradient.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="graph_tool.community.community_structure">
<code class="descclassname">graph_tool.community.</code><code class="descname">community_structure</code><span class="sig-paren">(</span><em>g</em>, <em>n_iter</em>, <em>n_spins</em>, <em>gamma=1.0</em>, <em>corr='erdos'</em>, <em>spins=None</em>, <em>weight=None</em>, <em>t_range=(100.0</em>, <em>0.01)</em>, <em>verbose=False</em>, <em>history_file=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/community.html#community_structure"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.community.community_structure" title="Permalink to this definition">¶</a></dt>
<dd><p>Obtain the community structure for the given graph, using a Potts model
approach, which is a generalization of modularity maximization).</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p><strong>The use of this function is discouraged.</strong> Although community detection
based on modularity maximization is very common, it is very
problematic. It will find high-scoring partitions where there is none
<a class="reference internal" href="#guimera-modularity-2004" id="id75">[guimera-modularity-2004]</a>, and at the same time will not find actual
structure in large graphs <a class="reference internal" href="#fortunato-resolution-2007" id="id76">[fortunato-resolution-2007]</a>. Furthermore, in
many empirical networks, the partitions found in this way are largely
meaningless <a class="reference internal" href="#good-performance-2010" id="id77">[good-performance-2010]</a>.</p>
<p class="last">One should use instead methods based on statistical inference
(i.e. <a class="reference internal" href="#graph_tool.community.minimize_blockmodel_dl" title="graph_tool.community.minimize_blockmodel_dl"><code class="xref py py-func docutils literal"><span class="pre">minimize_blockmodel_dl()</span></code></a> and
<a class="reference internal" href="#graph_tool.community.minimize_nested_blockmodel_dl" title="graph_tool.community.minimize_nested_blockmodel_dl"><code class="xref py py-func docutils literal"><span class="pre">minimize_nested_blockmodel_dl()</span></code></a>).</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>g</strong> :  <a class="reference internal" href="graph_tool.html#graph_tool.Graph" title="graph_tool.Graph"><code class="xref py py-class docutils literal"><span class="pre">Graph</span></code></a></p>
<blockquote>
<div><p>Graph to be used.</p>
</div></blockquote>
<p><strong>n_iter</strong> : int</p>
<blockquote>
<div><p>Number of iterations.</p>
</div></blockquote>
<p><strong>n_spins</strong> : int</p>
<blockquote>
<div><p>Number of maximum spins to be used.</p>
</div></blockquote>
<p><strong>gamma</strong> : float (optional, default: 1.0)</p>
<blockquote>
<div><p>The <span class="math">\(\gamma\)</span> parameter of the hamiltonian.</p>
</div></blockquote>
<p><strong>corr</strong> : string (optional, default: &#8220;erdos&#8221;)</p>
<blockquote>
<div><p>Type of correlation to be assumed: Either &#8220;erdos&#8221;, &#8220;uncorrelated&#8221; and
&#8220;correlated&#8221;.</p>
</div></blockquote>
<p><strong>spins</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal"><span class="pre">PropertyMap</span></code></a></p>
<blockquote>
<div><p>Vertex property maps to store the spin variables. If this is specified,
the values will not be initialized to a random value.</p>
</div></blockquote>
<p><strong>weight</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal"><span class="pre">PropertyMap</span></code></a> (optional, default: None)</p>
<blockquote>
<div><p>Edge property map with the optional edge weights.</p>
</div></blockquote>
<p><strong>t_range</strong> : tuple of floats (optional, default: (100.0, 0.01))</p>
<blockquote>
<div><p>Temperature range.</p>
</div></blockquote>
<p><strong>verbose</strong> : bool (optional, default: False)</p>
<blockquote>
<div><p>Display verbose information.</p>
</div></blockquote>
<p><strong>history_file</strong> : string (optional, default: None)</p>
<blockquote>
<div><p>History file to keep information about the simulated annealing.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>spins</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal"><span class="pre">PropertyMap</span></code></a></p>
<blockquote class="last">
<div><p>Vertex property map with the spin values.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#graph_tool.community.community_structure" title="graph_tool.community.community_structure"><code class="xref py py-obj docutils literal"><span class="pre">community_structure</span></code></a></dt>
<dd>Obtain the community structure</dd>
<dt><a class="reference internal" href="#graph_tool.community.modularity" title="graph_tool.community.modularity"><code class="xref py py-obj docutils literal"><span class="pre">modularity</span></code></a></dt>
<dd>Calculate the network modularity</dd>
<dt><a class="reference internal" href="#graph_tool.community.condensation_graph" title="graph_tool.community.condensation_graph"><code class="xref py py-obj docutils literal"><span class="pre">condensation_graph</span></code></a></dt>
<dd>Network of communities, or blocks</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The method of community detection covered here is an implementation of what
was proposed in <a class="reference internal" href="#reichard-statistical-2006" id="id78">[reichard-statistical-2006]</a>. It
consists of a <a class="reference external" href="http://en.wikipedia.org/wiki/Simulated_annealing">simulated annealing</a> algorithm which tries to minimize the
following hamiltonian:</p>
<div class="math">
\[\mathcal{H}(\{\sigma\}) = - \sum_{i \neq j} \left(A_{ij} -
\gamma p_{ij}\right) \delta(\sigma_i,\sigma_j)\]</div>
<p>where <span class="math">\(p_{ij}\)</span> is the probability of vertices i and j being connected,
which reduces the problem of community detection to finding the ground
states of a Potts spin-glass model. It can be shown that minimizing this
hamiltonan, with <span class="math">\(\gamma=1\)</span>, is equivalent to maximizing
Newman&#8217;s modularity (<a class="reference internal" href="#id86" id="id79">[newman-modularity-2006]</a>). By increasing the parameter
<span class="math">\(\gamma\)</span>, it&#8217;s possible also to find sub-communities.</p>
<p>It is possible to select three policies for choosing <span class="math">\(p_{ij}\)</span> and thus
choosing the null model: &#8220;erdos&#8221; selects a Erdos-Reyni random graph,
&#8220;uncorrelated&#8221; selects an arbitrary random graph with no vertex-vertex
correlations, and &#8220;correlated&#8221; selects a random graph with average
correlation taken from the graph itself. Optionally a weight property
can be given by the <cite>weight</cite> option.</p>
<p>The most important parameters for the algorithm are the initial and final
temperatures (<cite>t_range</cite>), and total number of iterations (<cite>max_iter</cite>). It
normally takes some trial and error to determine the best values for a
specific graph. To help with this, the <cite>history</cite> option can be used, which
saves to a chosen file the temperature and number of spins per iteration,
which can be used to determined whether or not the algorithm converged to
the optimal solution. Also, the <cite>verbose</cite> option prints the computation
status on the terminal.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If the spin property already exists before the computation starts, it&#8217;s
not re-sampled at the beginning. This means that it&#8217;s possible to
continue a previous run, if you saved the graph, by properly setting
<cite>t_range</cite> value, and using the same <cite>spin</cite> property.</p>
</div>
<p>If enabled during compilation, this algorithm runs in parallel.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="guimera-modularity-2004" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[guimera-modularity-2004]</td><td><em>(<a class="fn-backref" href="#id75">1</a>, <a class="fn-backref" href="#id80">2</a>)</em> Roger Guimerà, Marta Sales-Pardo, and Luís
A. Nunes Amaral, &#8220;Modularity from fluctuations in random graphs and
complex networks&#8221;, Phys. Rev. E 70, 025101(R) (2004),
<a class="reference external" href="http://dx.doi.org/10.1103/PhysRevE.70.025101">DOI: 10.1103/PhysRevE.70.025101</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="fortunato-resolution-2007" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[fortunato-resolution-2007]</td><td><em>(<a class="fn-backref" href="#id76">1</a>, <a class="fn-backref" href="#id81">2</a>)</em> Santo Fortunato and Marc Barthélemy,
&#8220;Resolution limit in community detection&#8221;, Proc. Natl. Acad. Sci. USA
104(1): 36–41 (2007), <a class="reference external" href="http://dx.doi.org/10.1073/pnas.0605965104">DOI: 10.1073/pnas.0605965104</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="good-performance-2010" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[good-performance-2010]</td><td><em>(<a class="fn-backref" href="#id77">1</a>, <a class="fn-backref" href="#id82">2</a>)</em> Benjamin H. Good, Yves-Alexandre de Montjoye, and
Aaron Clauset, &#8220;Performance of modularity maximization in practical
contexts&#8221;, Phys. Rev. E 81, 046106 (2010),
<a class="reference external" href="http://dx.doi.org/10.1103/PhysRevE.81.046106">DOI: 10.1103/PhysRevE.81.046106</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="reichard-statistical-2006" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[reichard-statistical-2006]</td><td><em>(<a class="fn-backref" href="#id78">1</a>, <a class="fn-backref" href="#id83">2</a>)</em> Joerg Reichardt and Stefan Bornholdt,
&#8220;Statistical Mechanics of Community Detection&#8221;, Phys. Rev. E 74
016110 (2006), <a class="reference external" href="http://dx.doi.org/10.1103/PhysRevE.74.016110">DOI: 10.1103/PhysRevE.74.016110</a>, <a class="reference external" href="http://arxiv.org/abs/cond-mat/0603718">arXiv: cond-mat/0603718</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="newman-modularity-2006" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[newman-modularity-2006]</td><td>M. E. J. Newman, &#8220;Modularity and community
structure in networks&#8221;, Proc. Natl. Acad. Sci. USA 103, 8577-8582 (2006),
<a class="reference external" href="http://dx.doi.org/10.1073/pnas.0601602103">DOI: 10.1073/pnas.0601602103</a>, <a class="reference external" href="http://arxiv.org/abs/physics/0602124">arXiv: physics/0602124</a></td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>This example uses the network <a class="reference download internal" href="_downloads/community.xml"><code class="xref download docutils literal"><span class="pre">community.xml</span></code></a>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pylab</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">numpy.random</span> <span class="kn">import</span> <span class="n">seed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">seed</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">load_graph</span><span class="p">(</span><span class="s">&quot;community.xml&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pos</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">vertex_properties</span><span class="p">[</span><span class="s">&quot;pos&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spins</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">community_structure</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="mi">10000</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="n">t_range</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gt</span><span class="o">.</span><span class="n">graph_draw</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span> <span class="n">vertex_fill_color</span><span class="o">=</span><span class="n">spins</span><span class="p">,</span> <span class="n">output_size</span><span class="o">=</span><span class="p">(</span><span class="mi">420</span><span class="p">,</span> <span class="mi">420</span><span class="p">),</span> <span class="n">output</span><span class="o">=</span><span class="s">&quot;comm1.pdf&quot;</span><span class="p">)</span>
<span class="go">&lt;...&gt;</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">spins</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">community_structure</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="mi">10000</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="n">t_range</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">),</span> <span class="n">gamma</span><span class="o">=</span><span class="mf">2.5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gt</span><span class="o">.</span><span class="n">graph_draw</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span> <span class="n">vertex_fill_color</span><span class="o">=</span><span class="n">spins</span><span class="p">,</span> <span class="n">output_size</span><span class="o">=</span><span class="p">(</span><span class="mi">420</span><span class="p">,</span> <span class="mi">420</span><span class="p">),</span> <span class="n">output</span><span class="o">=</span><span class="s">&quot;comm2.pdf&quot;</span><span class="p">)</span>
<span class="go">&lt;...&gt;</span>
</pre></div>
</div>
<div class="figure align-center" id="id98">
<img alt="_images/comm1.png" src="_images/comm1.png" />
<p class="caption"><span class="caption-text">The community structure with <span class="math">\(\gamma=1\)</span>.</span></p>
</div>
<div class="figure align-center" id="id99">
<img alt="_images/comm2.png" src="_images/comm2.png" />
<p class="caption"><span class="caption-text">The community structure with <span class="math">\(\gamma=2.5\)</span>.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="graph_tool.community.modularity">
<code class="descclassname">graph_tool.community.</code><code class="descname">modularity</code><span class="sig-paren">(</span><em>g</em>, <em>prop</em>, <em>weight=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/community.html#modularity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.community.modularity" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate Newman&#8217;s modularity.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>g</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.Graph" title="graph_tool.Graph"><code class="xref py py-class docutils literal"><span class="pre">Graph</span></code></a></p>
<blockquote>
<div><p>Graph to be used.</p>
</div></blockquote>
<p><strong>prop</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal"><span class="pre">PropertyMap</span></code></a></p>
<blockquote>
<div><p>Vertex property map with the community partition.</p>
</div></blockquote>
<p><strong>weight</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal"><span class="pre">PropertyMap</span></code></a> (optional, default: None)</p>
<blockquote>
<div><p>Edge property map with the optional edge weights.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>modularity</strong> : float</p>
<blockquote class="last">
<div><p>Newman&#8217;s modularity.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#graph_tool.community.community_structure" title="graph_tool.community.community_structure"><code class="xref py py-obj docutils literal"><span class="pre">community_structure</span></code></a></dt>
<dd>obtain the community structure</dd>
<dt><a class="reference internal" href="#graph_tool.community.modularity" title="graph_tool.community.modularity"><code class="xref py py-obj docutils literal"><span class="pre">modularity</span></code></a></dt>
<dd>calculate the network modularity</dd>
<dt><a class="reference internal" href="#graph_tool.community.condensation_graph" title="graph_tool.community.condensation_graph"><code class="xref py py-obj docutils literal"><span class="pre">condensation_graph</span></code></a></dt>
<dd>Network of communities, or blocks</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Given a specific graph partition specified by <cite>prop</cite>, Newman&#8217;s modularity
<a class="reference internal" href="#id86" id="id85">[newman-modularity-2006]</a> is defined by:</p>
<div class="math">
\[Q = \frac{1}{2E} \sum_r e_{rr}- \frac{e_r^2}{2E}\]</div>
<p>where <span class="math">\(e_{rs}\)</span> is the number of edges which fall between
vertices in communities s and r, or twice that number if <span class="math">\(r = s\)</span>, and
<span class="math">\(e_r = \sum_s e_{rs}\)</span>.</p>
<p>If weights are provided, the matrix <span class="math">\(e_{rs}\)</span> corresponds to the sum
of edge weights instead of number of edges, and the value of <span class="math">\(E\)</span>
becomes the total sum of edge weights.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="id86" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[newman-modularity-2006]</td><td>M. E. J. Newman, &#8220;Modularity and community
structure in networks&#8221;, Proc. Natl. Acad. Sci. USA 103, 8577-8582 (2006),
<a class="reference external" href="http://dx.doi.org/10.1073/pnas.0601602103">DOI: 10.1073/pnas.0601602103</a>, <a class="reference external" href="http://arxiv.org/abs/physics/0602124">arXiv: physics/0602124</a></td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pylab</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">numpy.random</span> <span class="kn">import</span> <span class="n">seed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">seed</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">load_graph</span><span class="p">(</span><span class="s">&quot;community.xml&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">community_structure</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="mi">10000</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gt</span><span class="o">.</span><span class="n">modularity</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">0.5353141885624041</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="docutils literal"><span class="pre">graph_tool.community</span></code> - Community structure</a><ul>
<li><a class="reference internal" href="#stochastic-blockmodel-inference">Stochastic blockmodel inference</a><ul>
<li><a class="reference internal" href="#non-hierarchical-models">Non-hierarchical models</a><ul>
<li><a class="reference internal" href="#summary">Summary</a></li>
</ul>
</li>
<li><a class="reference internal" href="#hierarchical-models">Hierarchical models</a><ul>
<li><a class="reference internal" href="#id1">Summary</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#modularity-based-community-detection">Modularity-based community detection</a><ul>
<li><a class="reference internal" href="#id2">Summary</a></li>
</ul>
</li>
<li><a class="reference internal" href="#contents">Contents</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="collection.html"
                        title="previous chapter"><code class="docutils literal"><span class="pre">graph_tool.collection</span></code> - Dataset collection</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="correlations.html"
                        title="next chapter"><code class="docutils literal"><span class="pre">graph_tool.correlations</span></code> - Correlations</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/community.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>

<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
<!-- <a href="graph-tool.pdf">(Download PDF version)</a> -->

<p/>
Latest <a href="/doc/dev/">development version docs</a> are also available.

        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="correlations.html" title="graph_tool.correlations - Correlations"
             >next</a> |</li>
        <li class="right" >
          <a href="collection.html" title="graph_tool.collection - Dataset collection"
             >previous</a> |</li>
    <li><img src="_static/graph-icon.png" alt="logo" style="margin-right: 5px; margin-bottom:-2px;" /><a href="/">Project Homepage</a> &raquo;</li>
    
        <li class="nav-item nav-item-0"><a href="index.html">graph-tool 2.2.44 documentation</a> &raquo;</li>

          <li class="nav-item nav-item-1"><a href="modules.html" >Module documentation</a> &raquo;</li>
          <li class="nav-item nav-item-2"><a href="graph_tool.html" >graph_tool - efficient graph analysis and manipulation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2015, Tiago de Paula Peixoto &lt;tiago@skewed.de&gt;.
      Last updated on Jul 02, 2015.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
  </body>
</html>