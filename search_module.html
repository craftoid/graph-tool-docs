<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>graph_tool.search - Search algorithms &mdash; graph-tool 2.2.44 documentation</title>
    
    <link rel="stylesheet" href="_static/gt_style.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '2.2.44',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/MathJax/MathJax.js?config=default"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within graph-tool 2.2.44 documentation"
          href="_static/opensearch.xml"/>
    <link rel="shortcut icon" href="_static/graph-icon.ico"/>
    <link rel="top" title="graph-tool 2.2.44 documentation" href="index.html" />
    <link rel="up" title="graph_tool - efficient graph analysis and manipulation" href="graph_tool.html" />
    <link rel="next" title="graph_tool.spectral - Spectral properties" href="spectral.html" />
    <link rel="prev" title="graph_tool.run_action - Inline C++ code embedding" href="run_action.html" />
    <script type="text/javascript">
      var _gaq = _gaq || [];
      var pluginUrl =
        '//www.google-analytics.com/plugins/ga/inpage_linkid.js';
      _gaq.push(['_require', 'inpage_linkid', pluginUrl]);
      _gaq.push(['_setAccount', 'UA-248813-2']);
      _gaq.push(['_setDomainName', '.skewed.de']);
      _gaq.push(['_trackPageview']);
      (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
     

  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="spectral.html" title="graph_tool.spectral - Spectral properties"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="run_action.html" title="graph_tool.run_action - Inline C++ code embedding"
             accesskey="P">previous</a> |</li>
    <li><img src="_static/graph-icon.png" alt="logo" style="margin-right: 5px; margin-bottom:-2px;" /><a href="/">Project Homepage</a> &raquo;</li>
    
        <li class="nav-item nav-item-0"><a href="index.html">graph-tool 2.2.44 documentation</a> &raquo;</li>

          <li class="nav-item nav-item-1"><a href="modules.html" >Module documentation</a> &raquo;</li>
          <li class="nav-item nav-item-2"><a href="graph_tool.html" accesskey="U">graph_tool - efficient graph analysis and manipulation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <span class="target" id="module-graph_tool.search"></span><div class="section" id="graph-tool-search-search-algorithms">
<h1><code class="docutils literal"><span class="pre">graph_tool.search</span></code> - Search algorithms<a class="headerlink" href="#graph-tool-search-search-algorithms" title="Permalink to this headline">¶</a></h1>
<p>This module includes several search algorithms, which are customizable to
arbitrary purposes. It is mostly a wrapper around the Visitor interface of the
<a class="reference external" href="http://www.boost.org/doc/libs/release/libs/graph/doc/visitor_concepts.html">Boost Graph Library</a>,
and the respective search functions.</p>
<div class="section" id="summary">
<h2>Summary<a class="headerlink" href="#summary" title="Permalink to this headline">¶</a></h2>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#graph_tool.search.bfs_search" title="graph_tool.search.bfs_search"><code class="xref py py-obj docutils literal"><span class="pre">bfs_search</span></code></a></td>
<td>Breadth-first traversal of a directed or undirected graph.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#graph_tool.search.dfs_search" title="graph_tool.search.dfs_search"><code class="xref py py-obj docutils literal"><span class="pre">dfs_search</span></code></a></td>
<td>Depth-first traversal of a directed or undirected graph.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#graph_tool.search.dijkstra_search" title="graph_tool.search.dijkstra_search"><code class="xref py py-obj docutils literal"><span class="pre">dijkstra_search</span></code></a></td>
<td>Dijsktra traversal of a directed or undirected graph, with non-negative weights.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#graph_tool.search.bellman_ford_search" title="graph_tool.search.bellman_ford_search"><code class="xref py py-obj docutils literal"><span class="pre">bellman_ford_search</span></code></a></td>
<td>Bellman-Ford traversal of a directed or undirected graph, with negative weights.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#graph_tool.search.astar_search" title="graph_tool.search.astar_search"><code class="xref py py-obj docutils literal"><span class="pre">astar_search</span></code></a></td>
<td>Heuristic <span class="math">\(A^*\)</span> search on a weighted, directed or undirected graph for the case where all edge weights are non-negative.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#graph_tool.search.BFSVisitor" title="graph_tool.search.BFSVisitor"><code class="xref py py-obj docutils literal"><span class="pre">BFSVisitor</span></code></a></td>
<td>A visitor object that is invoked at the event-points inside the <a class="reference internal" href="#graph_tool.search.bfs_search" title="graph_tool.search.bfs_search"><code class="xref py py-func docutils literal"><span class="pre">bfs_search()</span></code></a> algorithm.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#graph_tool.search.DFSVisitor" title="graph_tool.search.DFSVisitor"><code class="xref py py-obj docutils literal"><span class="pre">DFSVisitor</span></code></a></td>
<td>A visitor object that is invoked at the event-points inside the <a class="reference internal" href="#graph_tool.search.dfs_search" title="graph_tool.search.dfs_search"><code class="xref py py-func docutils literal"><span class="pre">dfs_search()</span></code></a> algorithm.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#graph_tool.search.DijkstraVisitor" title="graph_tool.search.DijkstraVisitor"><code class="xref py py-obj docutils literal"><span class="pre">DijkstraVisitor</span></code></a></td>
<td>A visitor object that is invoked at the event-points inside the <a class="reference internal" href="#graph_tool.search.dijkstra_search" title="graph_tool.search.dijkstra_search"><code class="xref py py-func docutils literal"><span class="pre">dijkstra_search()</span></code></a> algorithm.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#graph_tool.search.BellmanFordVisitor" title="graph_tool.search.BellmanFordVisitor"><code class="xref py py-obj docutils literal"><span class="pre">BellmanFordVisitor</span></code></a></td>
<td>A visitor object that is invoked at the event-points inside the <a class="reference internal" href="#graph_tool.search.bellman_ford_search" title="graph_tool.search.bellman_ford_search"><code class="xref py py-func docutils literal"><span class="pre">bellman_ford_search()</span></code></a> algorithm.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#graph_tool.search.AStarVisitor" title="graph_tool.search.AStarVisitor"><code class="xref py py-obj docutils literal"><span class="pre">AStarVisitor</span></code></a></td>
<td>A visitor object that is invoked at the event-points inside the <a class="reference internal" href="#graph_tool.search.astar_search" title="graph_tool.search.astar_search"><code class="xref py py-func docutils literal"><span class="pre">astar_search()</span></code></a> algorithm.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#graph_tool.search.StopSearch" title="graph_tool.search.StopSearch"><code class="xref py py-obj docutils literal"><span class="pre">StopSearch</span></code></a></td>
<td>If this exception is raised from inside any search visitor object, the search is aborted.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="examples">
<h2>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h2>
<p>In this module, most documentation examples will make use of the network
<a class="reference download internal" href="_downloads/search_example.xml"><code class="xref download docutils literal"><span class="pre">search_example.xml</span></code></a>, shown below.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">load_graph</span><span class="p">(</span><span class="s">&quot;search_example.xml&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">name</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">vp</span><span class="p">[</span><span class="s">&quot;name&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">weight</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">ep</span><span class="p">[</span><span class="s">&quot;weight&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pos</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">vp</span><span class="p">[</span><span class="s">&quot;pos&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gt</span><span class="o">.</span><span class="n">graph_draw</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">vertex_text</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">vertex_font_size</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">vertex_shape</span><span class="o">=</span><span class="s">&quot;double_circle&quot;</span><span class="p">,</span>
<span class="gp">... </span>              <span class="n">vertex_fill_color</span><span class="o">=</span><span class="s">&quot;#729fcf&quot;</span><span class="p">,</span> <span class="n">vertex_pen_width</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
<span class="gp">... </span>              <span class="n">edge_pen_width</span><span class="o">=</span><span class="n">weight</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s">&quot;search_example.pdf&quot;</span><span class="p">)</span>
<span class="go">&lt;...&gt;</span>
</pre></div>
</div>
<div class="figure align-center" id="id16">
<img alt="search example" src="_images/search_example.png" />
<p class="caption"><span class="caption-text">This is the network used in the examples below. The width of the edges
correspond to the values of the &#8220;weight&#8221; property map.</span></p>
</div>
</div>
<div class="section" id="contents">
<h2>Contents<a class="headerlink" href="#contents" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="graph_tool.search.BFSVisitor">
<em class="property">class </em><code class="descclassname">graph_tool.search.</code><code class="descname">BFSVisitor</code><a class="reference internal" href="_modules/graph_tool/search.html#BFSVisitor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.search.BFSVisitor" title="Permalink to this definition">¶</a></dt>
<dd><p>A visitor object that is invoked at the event-points inside the
<a class="reference internal" href="#graph_tool.search.bfs_search" title="graph_tool.search.bfs_search"><code class="xref py py-func docutils literal"><span class="pre">bfs_search()</span></code></a> algorithm. By default, it performs no
action, and should be used as a base class in order to be useful.</p>
<dl class="method">
<dt id="graph_tool.search.BFSVisitor.initialize_vertex">
<code class="descname">initialize_vertex</code><span class="sig-paren">(</span><em>u</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/search.html#BFSVisitor.initialize_vertex"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.search.BFSVisitor.initialize_vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>This is invoked on every vertex of the graph before the start of the
graph search.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.search.BFSVisitor.discover_vertex">
<code class="descname">discover_vertex</code><span class="sig-paren">(</span><em>u</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/search.html#BFSVisitor.discover_vertex"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.search.BFSVisitor.discover_vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>This is invoked when a vertex is encountered for the first time.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.search.BFSVisitor.examine_vertex">
<code class="descname">examine_vertex</code><span class="sig-paren">(</span><em>u</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/search.html#BFSVisitor.examine_vertex"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.search.BFSVisitor.examine_vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>This is invoked on a vertex as it is popped from the queue. This
happens immediately before examine_edge() is invoked on each of the
out-edges of vertex u.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.search.BFSVisitor.examine_edge">
<code class="descname">examine_edge</code><span class="sig-paren">(</span><em>e</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/search.html#BFSVisitor.examine_edge"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.search.BFSVisitor.examine_edge" title="Permalink to this definition">¶</a></dt>
<dd><p>This is invoked on every out-edge of each vertex after it is
discovered.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.search.BFSVisitor.tree_edge">
<code class="descname">tree_edge</code><span class="sig-paren">(</span><em>e</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/search.html#BFSVisitor.tree_edge"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.search.BFSVisitor.tree_edge" title="Permalink to this definition">¶</a></dt>
<dd><p>This is invoked on each edge as it becomes a member of the edges that
form the search tree.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.search.BFSVisitor.non_tree_edge">
<code class="descname">non_tree_edge</code><span class="sig-paren">(</span><em>e</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/search.html#BFSVisitor.non_tree_edge"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.search.BFSVisitor.non_tree_edge" title="Permalink to this definition">¶</a></dt>
<dd><p>This is invoked on back or cross edges for directed graphs and cross
edges for undirected graphs.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.search.BFSVisitor.gray_target">
<code class="descname">gray_target</code><span class="sig-paren">(</span><em>e</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/search.html#BFSVisitor.gray_target"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.search.BFSVisitor.gray_target" title="Permalink to this definition">¶</a></dt>
<dd><p>This is invoked on the subset of non-tree edges whose target vertex
is colored gray at the time of examination. The color gray indicates
that the vertex is currently in the queue.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.search.BFSVisitor.black_target">
<code class="descname">black_target</code><span class="sig-paren">(</span><em>e</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/search.html#BFSVisitor.black_target"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.search.BFSVisitor.black_target" title="Permalink to this definition">¶</a></dt>
<dd><p>This is invoked on the subset of non-tree edges whose target vertex
is colored black at the time of examination. The color black indicates
that the vertex has been removed from the queue.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.search.BFSVisitor.finish_vertex">
<code class="descname">finish_vertex</code><span class="sig-paren">(</span><em>u</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/search.html#BFSVisitor.finish_vertex"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.search.BFSVisitor.finish_vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>This invoked on a vertex after all of its out edges have been added
to the search tree and all of the adjacent vertices have been discovered
(but before the out-edges of the adjacent vertices have been examined).</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="graph_tool.search.bfs_search">
<code class="descclassname">graph_tool.search.</code><code class="descname">bfs_search</code><span class="sig-paren">(</span><em>g</em>, <em>source</em>, <em>visitor=&lt;graph_tool.search.BFSVisitor object&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/search.html#bfs_search"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.search.bfs_search" title="Permalink to this definition">¶</a></dt>
<dd><p>Breadth-first traversal of a directed or undirected graph.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>g</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.Graph" title="graph_tool.Graph"><code class="xref py py-class docutils literal"><span class="pre">Graph</span></code></a></p>
<blockquote>
<div><p>Graph to be used.</p>
</div></blockquote>
<p><strong>source</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.Vertex" title="graph_tool.Vertex"><code class="xref py py-class docutils literal"><span class="pre">Vertex</span></code></a></p>
<blockquote>
<div><p>Source vertex.</p>
</div></blockquote>
<p><strong>visitor</strong> : <a class="reference internal" href="#graph_tool.search.BFSVisitor" title="graph_tool.search.BFSVisitor"><code class="xref py py-class docutils literal"><span class="pre">BFSVisitor</span></code></a> (optional, default: <code class="docutils literal"><span class="pre">BFSVisitor()</span></code>)</p>
<blockquote class="last">
<div><p>A visitor object that is invoked at the event points inside the
algorithm. This should be a subclass of
<a class="reference internal" href="#graph_tool.search.BFSVisitor" title="graph_tool.search.BFSVisitor"><code class="xref py py-class docutils literal"><span class="pre">BFSVisitor</span></code></a>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#graph_tool.search.dfs_search" title="graph_tool.search.dfs_search"><code class="xref py py-obj docutils literal"><span class="pre">dfs_search</span></code></a></dt>
<dd>Depth-first search</dd>
<dt><a class="reference internal" href="#graph_tool.search.dijkstra_search" title="graph_tool.search.dijkstra_search"><code class="xref py py-obj docutils literal"><span class="pre">dijkstra_search</span></code></a></dt>
<dd>Dijkstra&#8217;s search algorithm</dd>
<dt><a class="reference internal" href="#graph_tool.search.astar_search" title="graph_tool.search.astar_search"><code class="xref py py-obj docutils literal"><span class="pre">astar_search</span></code></a></dt>
<dd><span class="math">\(A^*\)</span> heuristic search algorithm</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>A breadth-first traversal visits vertices that are closer to the source
before visiting vertices that are further away. In this context &#8220;distance&#8221;
is defined as the number of edges in the shortest path from the source
vertex.</p>
<p>The time complexity is <span class="math">\(O(V + E)\)</span>.</p>
<p>The pseudo-code for the BFS algorithm is listed below, with the annotated
event points, for which the given visitor object will be called with the
appropriate method.</p>
<div class="highlight-python"><div class="highlight"><pre>BFS(G, source)
 for each vertex u in V[G]       initialize vertex u
   color[u] := WHITE
   d[u] := infinity
 end for
 color[source] := GRAY
 d[source] := 0
 ENQUEUE(Q, source)              discover vertex source
 while (Q != Ø)
   u := DEQUEUE(Q)               examine vertex u
   for each vertex v in Adj[u]   examine edge (u,v)
     if (color[v] = WHITE)       (u,v) is a tree edge
       color[v] := GRAY
       ENQUEUE(Q, v)             discover vertex v
     else                        (u,v) is a non-tree edge
       if (color[v] = GRAY)
         ...                     (u,v) has a gray target
       else
         ...                     (u,v) has a black target
   end for
   color[u] := BLACK             finish vertex u
 end while
</pre></div>
</div>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="bfs" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[bfs]</a></td><td>Edward Moore, &#8220;The shortest path through a maze&#8221;, International
Symposium on the Theory of Switching, 1959</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="bfs-bgl" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[bfs-bgl]</a></td><td><a class="reference external" href="http://www.boost.org/doc/libs/release/libs/graph/doc/breadth_first_search.html">http://www.boost.org/doc/libs/release/libs/graph/doc/breadth_first_search.html</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="bfs-wikipedia" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[bfs-wikipedia]</a></td><td><a class="reference external" href="http://en.wikipedia.org/wiki/Breadth-first_search">http://en.wikipedia.org/wiki/Breadth-first_search</a></td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>We must define what should be done during the search by subclassing
<a class="reference internal" href="#graph_tool.search.BFSVisitor" title="graph_tool.search.BFSVisitor"><code class="xref py py-class docutils literal"><span class="pre">BFSVisitor</span></code></a>, and specializing the appropriate
methods. In the following we will keep track of the distance from the root,
and the predecessor tree.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">VisitorExample</span><span class="p">(</span><span class="n">gt</span><span class="o">.</span><span class="n">BFSVisitor</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">pred</span><span class="p">,</span> <span class="n">dist</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pred</span> <span class="o">=</span> <span class="n">pred</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist</span> <span class="o">=</span> <span class="n">dist</span>

    <span class="k">def</span> <span class="nf">discover_vertex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&quot;--&gt;&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="s">&quot;has been discovered!&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">examine_vertex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="s">&quot;has been examined...&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">tree_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pred</span><span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">target</span><span class="p">()]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">source</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist</span><span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">target</span><span class="p">()]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist</span><span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">source</span><span class="p">()]</span> <span class="o">+</span> <span class="mi">1</span>
</pre></div>
</div>
<p>With the above class defined, we can perform the BFS search as follows.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">dist</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="s">&quot;int&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pred</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="s">&quot;int&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gt</span><span class="o">.</span><span class="n">bfs_search</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">VisitorExample</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">pred</span><span class="p">,</span> <span class="n">dist</span><span class="p">))</span>
<span class="go">--&gt; Bob has been discovered!</span>
<span class="go">Bob has been examined...</span>
<span class="go">--&gt; Eve has been discovered!</span>
<span class="go">--&gt; Chuck has been discovered!</span>
<span class="go">--&gt; Carlos has been discovered!</span>
<span class="go">--&gt; Isaac has been discovered!</span>
<span class="go">Eve has been examined...</span>
<span class="go">--&gt; Carol has been discovered!</span>
<span class="go">--&gt; Imothep has been discovered!</span>
<span class="go">Chuck has been examined...</span>
<span class="go">Carlos has been examined...</span>
<span class="go">--&gt; Alice has been discovered!</span>
<span class="go">Isaac has been examined...</span>
<span class="go">Carol has been examined...</span>
<span class="go">Imothep has been examined...</span>
<span class="go">Alice has been examined...</span>
<span class="go">--&gt; Oscar has been discovered!</span>
<span class="go">--&gt; Dave has been discovered!</span>
<span class="go">Oscar has been examined...</span>
<span class="go">Dave has been examined...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">dist</span><span class="o">.</span><span class="n">a</span><span class="p">)</span>
<span class="go">[0 2 2 1 1 3 1 1 3 2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">pred</span><span class="o">.</span><span class="n">a</span><span class="p">)</span>
<span class="go">[0 3 6 0 0 1 0 0 1 6]</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="graph_tool.search.DFSVisitor">
<em class="property">class </em><code class="descclassname">graph_tool.search.</code><code class="descname">DFSVisitor</code><a class="reference internal" href="_modules/graph_tool/search.html#DFSVisitor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.search.DFSVisitor" title="Permalink to this definition">¶</a></dt>
<dd><p>A visitor object that is invoked at the event-points inside the
<a class="reference internal" href="#graph_tool.search.dfs_search" title="graph_tool.search.dfs_search"><code class="xref py py-func docutils literal"><span class="pre">dfs_search()</span></code></a> algorithm. By default, it performs no
action, and should be used as a base class in order to be useful.</p>
<dl class="method">
<dt id="graph_tool.search.DFSVisitor.initialize_vertex">
<code class="descname">initialize_vertex</code><span class="sig-paren">(</span><em>u</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/search.html#DFSVisitor.initialize_vertex"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.search.DFSVisitor.initialize_vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>This is invoked on every vertex of the graph before the start of the
graph search.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.search.DFSVisitor.start_vertex">
<code class="descname">start_vertex</code><span class="sig-paren">(</span><em>u</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/search.html#DFSVisitor.start_vertex"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.search.DFSVisitor.start_vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>This is invoked on the source vertex once before the start of the
search.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.search.DFSVisitor.discover_vertex">
<code class="descname">discover_vertex</code><span class="sig-paren">(</span><em>u</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/search.html#DFSVisitor.discover_vertex"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.search.DFSVisitor.discover_vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>This is invoked when a vertex is encountered for the first time.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.search.DFSVisitor.examine_edge">
<code class="descname">examine_edge</code><span class="sig-paren">(</span><em>e</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/search.html#DFSVisitor.examine_edge"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.search.DFSVisitor.examine_edge" title="Permalink to this definition">¶</a></dt>
<dd><p>This is invoked on every out-edge of each vertex after it is discovered.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.search.DFSVisitor.tree_edge">
<code class="descname">tree_edge</code><span class="sig-paren">(</span><em>e</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/search.html#DFSVisitor.tree_edge"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.search.DFSVisitor.tree_edge" title="Permalink to this definition">¶</a></dt>
<dd><p>This is invoked on each edge as it becomes a member of the edges that
form the search tree.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.search.DFSVisitor.back_edge">
<code class="descname">back_edge</code><span class="sig-paren">(</span><em>e</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/search.html#DFSVisitor.back_edge"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.search.DFSVisitor.back_edge" title="Permalink to this definition">¶</a></dt>
<dd><p>This is invoked on the back edges in the graph. For an undirected graph
there is some ambiguity between tree edges and back edges since the edge
(u,v) and (v,u) are the same edge, but both the
<a class="reference internal" href="#graph_tool.search.DFSVisitor.tree_edge" title="graph_tool.search.DFSVisitor.tree_edge"><code class="xref py py-meth docutils literal"><span class="pre">tree_edge()</span></code></a> and
<code class="xref py py-meth docutils literal"><span class="pre">back_edge()</span></code> functions will be
invoked. One way to resolve this ambiguity is to record the tree edges,
and then disregard the back-edges that are already marked as tree
edges. An easy way to record tree edges is to record predecessors at the
tree_edge event point.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.search.DFSVisitor.forward_or_cross_edge">
<code class="descname">forward_or_cross_edge</code><span class="sig-paren">(</span><em>e</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/search.html#DFSVisitor.forward_or_cross_edge"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.search.DFSVisitor.forward_or_cross_edge" title="Permalink to this definition">¶</a></dt>
<dd><p>This is invoked on forward or cross edges in the graph. In an undirected
graph this method is never called.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.search.DFSVisitor.finish_vertex">
<code class="descname">finish_vertex</code><span class="sig-paren">(</span><em>e</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/search.html#DFSVisitor.finish_vertex"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.search.DFSVisitor.finish_vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>This is invoked on vertex u after finish_vertex has been called for all
the vertices in the DFS-tree rooted at vertex u. If vertex u is a leaf
in the DFS-tree, then the
<code class="xref py py-meth docutils literal"><span class="pre">finish_vertex()</span></code> function is called
on u after all the out-edges of u have been examined.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="graph_tool.search.dfs_search">
<code class="descclassname">graph_tool.search.</code><code class="descname">dfs_search</code><span class="sig-paren">(</span><em>g</em>, <em>source</em>, <em>visitor=&lt;graph_tool.search.DFSVisitor object&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/search.html#dfs_search"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.search.dfs_search" title="Permalink to this definition">¶</a></dt>
<dd><p>Depth-first traversal of a directed or undirected graph.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>g</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.Graph" title="graph_tool.Graph"><code class="xref py py-class docutils literal"><span class="pre">Graph</span></code></a></p>
<blockquote>
<div><p>Graph to be used.</p>
</div></blockquote>
<p><strong>source</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.Vertex" title="graph_tool.Vertex"><code class="xref py py-class docutils literal"><span class="pre">Vertex</span></code></a></p>
<blockquote>
<div><p>Source vertex.</p>
</div></blockquote>
<p><strong>visitor</strong> : <a class="reference internal" href="#graph_tool.search.DFSVisitor" title="graph_tool.search.DFSVisitor"><code class="xref py py-class docutils literal"><span class="pre">DFSVisitor</span></code></a> (optional, default: <code class="docutils literal"><span class="pre">DFSVisitor()</span></code>)</p>
<blockquote class="last">
<div><p>A visitor object that is invoked at the event points inside the
algorithm. This should be a subclass of
<a class="reference internal" href="#graph_tool.search.DFSVisitor" title="graph_tool.search.DFSVisitor"><code class="xref py py-class docutils literal"><span class="pre">DFSVisitor</span></code></a>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#graph_tool.search.bfs_search" title="graph_tool.search.bfs_search"><code class="xref py py-obj docutils literal"><span class="pre">bfs_search</span></code></a></dt>
<dd>Breadth-first search</dd>
<dt><a class="reference internal" href="#graph_tool.search.dijkstra_search" title="graph_tool.search.dijkstra_search"><code class="xref py py-obj docutils literal"><span class="pre">dijkstra_search</span></code></a></dt>
<dd>Dijkstra&#8217;s search algorithm</dd>
<dt><a class="reference internal" href="#graph_tool.search.astar_search" title="graph_tool.search.astar_search"><code class="xref py py-obj docutils literal"><span class="pre">astar_search</span></code></a></dt>
<dd><span class="math">\(A^*\)</span> heuristic search algorithm</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>When possible, a depth-first traversal chooses a vertex adjacent to the
current vertex to visit next. If all adjacent vertices have already been
discovered, or there are no adjacent vertices, then the algorithm backtracks
to the last vertex that had undiscovered neighbors. Once all reachable
vertices have been visited, the algorithm selects from any remaining
undiscovered vertices and continues the traversal. The algorithm finishes
when all vertices have been visited.</p>
<p>The time complexity is <span class="math">\(O(V + E)\)</span>.</p>
<p>The pseudo-code for the DFS algorithm is listed below, with the annotated
event points, for which the given visitor object will be called with the
appropriate method.</p>
<div class="highlight-python"><div class="highlight"><pre>DFS(G)
  for each vertex u in V
    color[u] := WHITE                 initialize vertex u
  end for
  time := 0
  call DFS-VISIT(G, source)           start vertex s

DFS-VISIT(G, u)
  color[u] := GRAY                    discover vertex u
  for each v in Adj[u]                examine edge (u,v)
    if (color[v] = WHITE)             (u,v) is a tree edge
      call DFS-VISIT(G, v)
    else if (color[v] = GRAY)         (u,v) is a back edge
      ...
    else if (color[v] = BLACK)        (u,v) is a cross or forward edge
      ...
  end for
  color[u] := BLACK                   finish vertex u
</pre></div>
</div>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="dfs-bgl" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[dfs-bgl]</a></td><td><a class="reference external" href="http://www.boost.org/doc/libs/release/libs/graph/doc/depth_first_search.html">http://www.boost.org/doc/libs/release/libs/graph/doc/depth_first_search.html</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="dfs-wikipedia" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[dfs-wikipedia]</a></td><td><a class="reference external" href="http://en.wikipedia.org/wiki/Depth-first_search">http://en.wikipedia.org/wiki/Depth-first_search</a></td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>We must define what should be done during the search by subclassing
<a class="reference internal" href="#graph_tool.search.DFSVisitor" title="graph_tool.search.DFSVisitor"><code class="xref py py-class docutils literal"><span class="pre">DFSVisitor</span></code></a>, and specializing the appropriate
methods. In the following we will keep track of the discover time, and the
predecessor tree.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">VisitorExample</span><span class="p">(</span><span class="n">gt</span><span class="o">.</span><span class="n">DFSVisitor</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">pred</span><span class="p">,</span> <span class="n">time</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pred</span> <span class="o">=</span> <span class="n">pred</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_time</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">discover_vertex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&quot;--&gt;&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="s">&quot;has been discovered!&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_time</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">examine_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&quot;edge (</span><span class="si">%s</span><span class="s">, </span><span class="si">%s</span><span class="s">) has been examined...&quot;</span> <span class="o">%</span> \
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">source</span><span class="p">()],</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">target</span><span class="p">()]))</span>

    <span class="k">def</span> <span class="nf">tree_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pred</span><span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">target</span><span class="p">()]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">source</span><span class="p">())</span>
</pre></div>
</div>
<p>With the above class defined, we can perform the DFS search as follows.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">time</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="s">&quot;int&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pred</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="s">&quot;int&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gt</span><span class="o">.</span><span class="n">dfs_search</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">VisitorExample</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">pred</span><span class="p">,</span> <span class="n">time</span><span class="p">))</span>
<span class="go">--&gt; Bob has been discovered!</span>
<span class="go">edge (Bob, Eve) has been examined...</span>
<span class="go">--&gt; Eve has been discovered!</span>
<span class="go">edge (Eve, Bob) has been examined...</span>
<span class="go">edge (Eve, Carol) has been examined...</span>
<span class="go">--&gt; Carol has been discovered!</span>
<span class="go">edge (Carol, Eve) has been examined...</span>
<span class="go">edge (Carol, Imothep) has been examined...</span>
<span class="go">--&gt; Imothep has been discovered!</span>
<span class="go">edge (Imothep, Carol) has been examined...</span>
<span class="go">edge (Imothep, Carlos) has been examined...</span>
<span class="go">--&gt; Carlos has been discovered!</span>
<span class="go">edge (Carlos, Bob) has been examined...</span>
<span class="go">edge (Carlos, Alice) has been examined...</span>
<span class="go">--&gt; Alice has been discovered!</span>
<span class="go">edge (Alice, Oscar) has been examined...</span>
<span class="go">--&gt; Oscar has been discovered!</span>
<span class="go">edge (Oscar, Alice) has been examined...</span>
<span class="go">edge (Oscar, Dave) has been examined...</span>
<span class="go">--&gt; Dave has been discovered!</span>
<span class="go">edge (Dave, Alice) has been examined...</span>
<span class="go">edge (Dave, Oscar) has been examined...</span>
<span class="go">edge (Alice, Dave) has been examined...</span>
<span class="go">edge (Alice, Carlos) has been examined...</span>
<span class="go">edge (Carlos, Eve) has been examined...</span>
<span class="go">edge (Carlos, Imothep) has been examined...</span>
<span class="go">edge (Imothep, Chuck) has been examined...</span>
<span class="go">--&gt; Chuck has been discovered!</span>
<span class="go">edge (Chuck, Bob) has been examined...</span>
<span class="go">edge (Chuck, Eve) has been examined...</span>
<span class="go">edge (Chuck, Isaac) has been examined...</span>
<span class="go">--&gt; Isaac has been discovered!</span>
<span class="go">edge (Isaac, Bob) has been examined...</span>
<span class="go">edge (Isaac, Chuck) has been examined...</span>
<span class="go">edge (Isaac, Eve) has been examined...</span>
<span class="go">edge (Chuck, Imothep) has been examined...</span>
<span class="go">edge (Imothep, Eve) has been examined...</span>
<span class="go">edge (Eve, Carlos) has been examined...</span>
<span class="go">edge (Eve, Chuck) has been examined...</span>
<span class="go">edge (Eve, Isaac) has been examined...</span>
<span class="go">edge (Eve, Imothep) has been examined...</span>
<span class="go">edge (Bob, Chuck) has been examined...</span>
<span class="go">edge (Bob, Carlos) has been examined...</span>
<span class="go">edge (Bob, Isaac) has been examined...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">a</span><span class="p">)</span>
<span class="go">[0 5 2 4 8 7 1 9 6 3]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">pred</span><span class="o">.</span><span class="n">a</span><span class="p">)</span>
<span class="go">[0 3 6 9 9 8 0 4 1 2]</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="graph_tool.search.DijkstraVisitor">
<em class="property">class </em><code class="descclassname">graph_tool.search.</code><code class="descname">DijkstraVisitor</code><a class="reference internal" href="_modules/graph_tool/search.html#DijkstraVisitor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.search.DijkstraVisitor" title="Permalink to this definition">¶</a></dt>
<dd><p>A visitor object that is invoked at the event-points inside the
<a class="reference internal" href="#graph_tool.search.dijkstra_search" title="graph_tool.search.dijkstra_search"><code class="xref py py-func docutils literal"><span class="pre">dijkstra_search()</span></code></a> algorithm. By default, it
performs no action, and should be used as a base class in order to be
useful.</p>
<dl class="method">
<dt id="graph_tool.search.DijkstraVisitor.initialize_vertex">
<code class="descname">initialize_vertex</code><span class="sig-paren">(</span><em>u</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/search.html#DijkstraVisitor.initialize_vertex"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.search.DijkstraVisitor.initialize_vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>This is invoked on every vertex of the graph before the start of the
graph search.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.search.DijkstraVisitor.examine_vertex">
<code class="descname">examine_vertex</code><span class="sig-paren">(</span><em>u</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/search.html#DijkstraVisitor.examine_vertex"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.search.DijkstraVisitor.examine_vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>This is invoked on a vertex as it is popped from the queue. This happens
immediately before <code class="xref py py-meth docutils literal"><span class="pre">examine_edge()</span></code> is
invoked on each of the out-edges of vertex u.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.search.DijkstraVisitor.examine_edge">
<code class="descname">examine_edge</code><span class="sig-paren">(</span><em>e</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/search.html#DijkstraVisitor.examine_edge"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.search.DijkstraVisitor.examine_edge" title="Permalink to this definition">¶</a></dt>
<dd><p>This is invoked on every out-edge of each vertex after it is discovered.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.search.DijkstraVisitor.discover_vertex">
<code class="descname">discover_vertex</code><span class="sig-paren">(</span><em>u</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/search.html#DijkstraVisitor.discover_vertex"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.search.DijkstraVisitor.discover_vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>This is invoked when a vertex is encountered for the first time.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.search.DijkstraVisitor.edge_relaxed">
<code class="descname">edge_relaxed</code><span class="sig-paren">(</span><em>e</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/search.html#DijkstraVisitor.edge_relaxed"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.search.DijkstraVisitor.edge_relaxed" title="Permalink to this definition">¶</a></dt>
<dd><p>Upon examination, if the following condition holds then the edge is
relaxed (its distance is reduced), and this method is invoked.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
<span class="k">assert</span><span class="p">(</span><span class="n">compare</span><span class="p">(</span><span class="n">combine</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="n">weight</span><span class="p">[</span><span class="n">e</span><span class="p">]),</span> <span class="n">d</span><span class="p">[</span><span class="n">v</span><span class="p">]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="graph_tool.search.DijkstraVisitor.edge_not_relaxed">
<code class="descname">edge_not_relaxed</code><span class="sig-paren">(</span><em>e</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/search.html#DijkstraVisitor.edge_not_relaxed"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.search.DijkstraVisitor.edge_not_relaxed" title="Permalink to this definition">¶</a></dt>
<dd><p>Upon examination, if the edge is not relaxed (see
<code class="xref py py-meth docutils literal"><span class="pre">edge_relaxed()</span></code>) then this
method is invoked.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.search.DijkstraVisitor.finish_vertex">
<code class="descname">finish_vertex</code><span class="sig-paren">(</span><em>u</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/search.html#DijkstraVisitor.finish_vertex"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.search.DijkstraVisitor.finish_vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>This invoked on a vertex after all of its out edges have been added to
the search tree and all of the adjacent vertices have been discovered
(but before their out-edges have been examined).</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="graph_tool.search.dijkstra_search">
<code class="descclassname">graph_tool.search.</code><code class="descname">dijkstra_search</code><span class="sig-paren">(</span><em>g</em>, <em>source</em>, <em>weight</em>, <em>visitor=&lt;graph_tool.search.DijkstraVisitor object&gt;</em>, <em>dist_map=None</em>, <em>pred_map=None</em>, <em>combine=&lt;function &lt;lambda&gt;&gt;</em>, <em>compare=&lt;function &lt;lambda&gt;&gt;</em>, <em>zero=0</em>, <em>infinity=inf</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/search.html#dijkstra_search"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.search.dijkstra_search" title="Permalink to this definition">¶</a></dt>
<dd><p>Dijsktra traversal of a directed or undirected graph, with non-negative weights.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>g</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.Graph" title="graph_tool.Graph"><code class="xref py py-class docutils literal"><span class="pre">Graph</span></code></a></p>
<blockquote>
<div><p>Graph to be used.</p>
</div></blockquote>
<p><strong>source</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.Vertex" title="graph_tool.Vertex"><code class="xref py py-class docutils literal"><span class="pre">Vertex</span></code></a></p>
<blockquote>
<div><p>Source vertex.</p>
</div></blockquote>
<p><strong>weight</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal"><span class="pre">PropertyMap</span></code></a></p>
<blockquote>
<div><p>Edge property map with weight values.</p>
</div></blockquote>
<p><strong>visitor</strong> : <a class="reference internal" href="#graph_tool.search.DijkstraVisitor" title="graph_tool.search.DijkstraVisitor"><code class="xref py py-class docutils literal"><span class="pre">DijkstraVisitor</span></code></a> (optional, default: <code class="docutils literal"><span class="pre">DijkstraVisitor()</span></code>)</p>
<blockquote>
<div><p>A visitor object that is invoked at the event points inside the
algorithm. This should be a subclass of
<a class="reference internal" href="#graph_tool.search.DijkstraVisitor" title="graph_tool.search.DijkstraVisitor"><code class="xref py py-class docutils literal"><span class="pre">DijkstraVisitor</span></code></a>.</p>
</div></blockquote>
<p><strong>dist_map</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal"><span class="pre">PropertyMap</span></code></a> (optional, default: <code class="docutils literal"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>A vertex property map where the distances from the source will be
stored.</p>
</div></blockquote>
<p><strong>pred_map</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal"><span class="pre">PropertyMap</span></code></a> (optional, default: <code class="docutils literal"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>A vertex property map where the predecessor map will be
stored (must have value type &#8220;int&#8221;).</p>
</div></blockquote>
<p><strong>combine</strong> : binary function (optional, default: <code class="docutils literal"><span class="pre">lambda</span> <span class="pre">a,</span> <span class="pre">b:</span> <span class="pre">a</span> <span class="pre">+</span> <span class="pre">b</span></code>)</p>
<blockquote>
<div><p>This function is used to combine distances to compute the distance of a
path.</p>
</div></blockquote>
<p><strong>compare</strong> : binary function (optional, default: <code class="docutils literal"><span class="pre">lambda</span> <span class="pre">a,</span> <span class="pre">b:</span> <span class="pre">a</span> <span class="pre">&lt;</span> <span class="pre">b</span></code>)</p>
<blockquote>
<div><p>This function is use to compare distances to determine which vertex is
closer to the source vertex.</p>
</div></blockquote>
<p><strong>zero</strong> : int or float (optional, default: <code class="docutils literal"><span class="pre">0</span></code>)</p>
<blockquote>
<div><p>Value assumed to correspond to a distance of zero by the combine and
compare functions.</p>
</div></blockquote>
<p><strong>infinity</strong> : int or float (optional, default: <code class="docutils literal"><span class="pre">float('inf')</span></code>)</p>
<blockquote>
<div><p>Value assumed to correspond to a distance of infinity by the combine and
compare functions.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dist_map</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal"><span class="pre">PropertyMap</span></code></a></p>
<blockquote>
<div><p>A vertex property map with the computed distances from the source.</p>
</div></blockquote>
<p><strong>pred_map</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal"><span class="pre">PropertyMap</span></code></a></p>
<blockquote class="last">
<div><p>A vertex property map with the predecessor tree.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#graph_tool.search.bfs_search" title="graph_tool.search.bfs_search"><code class="xref py py-obj docutils literal"><span class="pre">bfs_search</span></code></a></dt>
<dd>Breadth-first search</dd>
<dt><a class="reference internal" href="#graph_tool.search.dfs_search" title="graph_tool.search.dfs_search"><code class="xref py py-obj docutils literal"><span class="pre">dfs_search</span></code></a></dt>
<dd>Depth-first search</dd>
<dt><a class="reference internal" href="#graph_tool.search.astar_search" title="graph_tool.search.astar_search"><code class="xref py py-obj docutils literal"><span class="pre">astar_search</span></code></a></dt>
<dd><span class="math">\(A^*\)</span> heuristic search algorithm</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Dijkstra&#8217;s algorithm finds all the shortest paths from the source vertex to
every other vertex by iteratively &#8220;growing&#8221; the set of vertices S to which
it knows the shortest path. At each step of the algorithm, the next vertex
added to S is determined by a priority queue. The queue contains the
vertices in V - S prioritized by their distance label, which is the length
of the shortest path seen so far for each vertex. The vertex u at the top of
the priority queue is then added to S, and each of its out-edges is relaxed:
if the distance to u plus the weight of the out-edge (u,v) is less than the
distance label for v then the estimated distance for vertex v is
reduced. The algorithm then loops back, processing the next vertex at the
top of the priority queue. The algorithm finishes when the priority queue is
empty.</p>
<p>The time complexity is <span class="math">\(O(V \log V)\)</span>.</p>
<p>The pseudo-code for Dijkstra&#8217;s algorithm is listed below, with the annotated
event points, for which the given visitor object will be called with the
appropriate method.</p>
<div class="highlight-python"><div class="highlight"><pre>DIJKSTRA(G, source, weight)
  for each vertex u in V                      initialize vertex u
    d[u] := infinity
    p[u] := u
  end for
  d[source] := 0
  INSERT(Q, source)                           discover vertex s
  while (Q != Ø)
    u := EXTRACT-MIN(Q)                       examine vertex u
    for each vertex v in Adj[u]               examine edge (u,v)
      if (weight[(u,v)] + d[u] &lt; d[v])        edge (u,v) relaxed
        d[v] := weight[(u,v)] + d[u]
        p[v] := u
        DECREASE-KEY(Q, v)
      else                                    edge (u,v) not relaxed
        ...
      if (d[v] was originally infinity)
        INSERT(Q, v)                          discover vertex v
    end for                                   finish vertex u
  end while
  return d
</pre></div>
</div>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="dijkstra" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[dijkstra]</a></td><td>E. Dijkstra, &#8220;A note on two problems in connexion with
graphs&#8221;, Numerische Mathematik, 1:269-271, 1959.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="dijkstra-bgl" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[dijkstra-bgl]</a></td><td><a class="reference external" href="http://www.boost.org/doc/libs/release/libs/graph/doc/dijkstra_shortest_paths_no_color_map.html">http://www.boost.org/doc/libs/release/libs/graph/doc/dijkstra_shortest_paths_no_color_map.html</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="dijkstra-wikipedia" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[dijkstra-wikipedia]</a></td><td><a class="reference external" href="http://en.wikipedia.org/wiki/Dijkstra's_algorithm">http://en.wikipedia.org/wiki/Dijkstra&#8217;s_algorithm</a></td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>We must define what should be done during the search by subclassing
<a class="reference internal" href="#graph_tool.search.DijkstraVisitor" title="graph_tool.search.DijkstraVisitor"><code class="xref py py-class docutils literal"><span class="pre">DijkstraVisitor</span></code></a>, and specializing the
appropriate methods. In the following we will keep track of the discover
time, and the predecessor tree.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">VisitorExample</span><span class="p">(</span><span class="n">gt</span><span class="o">.</span><span class="n">DijkstraVisitor</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">time</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_time</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">discover_vertex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&quot;--&gt;&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="s">&quot;has been discovered!&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_time</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">examine_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&quot;edge (</span><span class="si">%s</span><span class="s">, </span><span class="si">%s</span><span class="s">) has been examined...&quot;</span> <span class="o">%</span> \
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">source</span><span class="p">()],</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">target</span><span class="p">()]))</span>

    <span class="k">def</span> <span class="nf">edge_relaxed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&quot;edge (</span><span class="si">%s</span><span class="s">, </span><span class="si">%s</span><span class="s">) has been relaxed...&quot;</span> <span class="o">%</span> \
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">source</span><span class="p">()],</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">target</span><span class="p">()]))</span>
</pre></div>
</div>
<p>With the above class defined, we can perform the Dijkstra search as follows.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">time</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="s">&quot;int&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dist</span><span class="p">,</span> <span class="n">pred</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">dijkstra_search</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">weight</span><span class="p">,</span> <span class="n">VisitorExample</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">time</span><span class="p">))</span>
<span class="go">--&gt; Bob has been discovered!</span>
<span class="go">edge (Bob, Eve) has been examined...</span>
<span class="go">edge (Bob, Eve) has been relaxed...</span>
<span class="go">--&gt; Eve has been discovered!</span>
<span class="go">edge (Bob, Chuck) has been examined...</span>
<span class="go">edge (Bob, Chuck) has been relaxed...</span>
<span class="go">--&gt; Chuck has been discovered!</span>
<span class="go">edge (Bob, Carlos) has been examined...</span>
<span class="go">edge (Bob, Carlos) has been relaxed...</span>
<span class="go">--&gt; Carlos has been discovered!</span>
<span class="go">edge (Bob, Isaac) has been examined...</span>
<span class="go">edge (Bob, Isaac) has been relaxed...</span>
<span class="go">--&gt; Isaac has been discovered!</span>
<span class="go">edge (Eve, Bob) has been examined...</span>
<span class="go">edge (Eve, Carol) has been examined...</span>
<span class="go">edge (Eve, Carol) has been relaxed...</span>
<span class="go">--&gt; Carol has been discovered!</span>
<span class="go">edge (Eve, Carlos) has been examined...</span>
<span class="go">edge (Eve, Chuck) has been examined...</span>
<span class="go">edge (Eve, Isaac) has been examined...</span>
<span class="go">edge (Eve, Imothep) has been examined...</span>
<span class="go">edge (Eve, Imothep) has been relaxed...</span>
<span class="go">--&gt; Imothep has been discovered!</span>
<span class="go">edge (Isaac, Bob) has been examined...</span>
<span class="go">edge (Isaac, Chuck) has been examined...</span>
<span class="go">edge (Isaac, Eve) has been examined...</span>
<span class="go">edge (Chuck, Bob) has been examined...</span>
<span class="go">edge (Chuck, Eve) has been examined...</span>
<span class="go">edge (Chuck, Isaac) has been examined...</span>
<span class="go">edge (Chuck, Imothep) has been examined...</span>
<span class="go">edge (Carlos, Bob) has been examined...</span>
<span class="go">edge (Carlos, Alice) has been examined...</span>
<span class="go">edge (Carlos, Alice) has been relaxed...</span>
<span class="go">--&gt; Alice has been discovered!</span>
<span class="go">edge (Carlos, Eve) has been examined...</span>
<span class="go">edge (Carlos, Imothep) has been examined...</span>
<span class="go">edge (Imothep, Carol) has been examined...</span>
<span class="go">edge (Imothep, Carlos) has been examined...</span>
<span class="go">edge (Imothep, Chuck) has been examined...</span>
<span class="go">edge (Imothep, Eve) has been examined...</span>
<span class="go">edge (Alice, Oscar) has been examined...</span>
<span class="go">edge (Alice, Oscar) has been relaxed...</span>
<span class="go">--&gt; Oscar has been discovered!</span>
<span class="go">edge (Alice, Dave) has been examined...</span>
<span class="go">edge (Alice, Dave) has been relaxed...</span>
<span class="go">--&gt; Dave has been discovered!</span>
<span class="go">edge (Alice, Carlos) has been examined...</span>
<span class="go">edge (Carol, Eve) has been examined...</span>
<span class="go">edge (Carol, Imothep) has been examined...</span>
<span class="go">edge (Oscar, Alice) has been examined...</span>
<span class="go">edge (Oscar, Dave) has been examined...</span>
<span class="go">edge (Dave, Alice) has been examined...</span>
<span class="go">edge (Dave, Oscar) has been examined...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">a</span><span class="p">)</span>
<span class="go">[0 7 5 3 2 9 1 4 8 6]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">pred</span><span class="o">.</span><span class="n">a</span><span class="p">)</span>
<span class="go">[0 3 6 0 0 1 0 0 1 6]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">dist</span><span class="o">.</span><span class="n">a</span><span class="p">)</span>
<span class="go">[  0.           8.91915887   9.27141329   4.29277116   4.02118246</span>
<span class="go">  12.23513866   3.23790211   3.45487436  11.04391549   7.74858396]</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="graph_tool.search.BellmanFordVisitor">
<em class="property">class </em><code class="descclassname">graph_tool.search.</code><code class="descname">BellmanFordVisitor</code><a class="reference internal" href="_modules/graph_tool/search.html#BellmanFordVisitor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.search.BellmanFordVisitor" title="Permalink to this definition">¶</a></dt>
<dd><p>A visitor object that is invoked at the event-points inside the
<a class="reference internal" href="#graph_tool.search.bellman_ford_search" title="graph_tool.search.bellman_ford_search"><code class="xref py py-func docutils literal"><span class="pre">bellman_ford_search()</span></code></a> algorithm. By default, it
performs no action, and should be used as a base class in order to be
useful.</p>
<dl class="method">
<dt id="graph_tool.search.BellmanFordVisitor.examine_edge">
<code class="descname">examine_edge</code><span class="sig-paren">(</span><em>e</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/search.html#BellmanFordVisitor.examine_edge"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.search.BellmanFordVisitor.examine_edge" title="Permalink to this definition">¶</a></dt>
<dd><p>This is invoked on every edge in the graph <code class="docutils literal"><span class="pre">|V|</span></code> times.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.search.BellmanFordVisitor.edge_relaxed">
<code class="descname">edge_relaxed</code><span class="sig-paren">(</span><em>e</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/search.html#BellmanFordVisitor.edge_relaxed"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.search.BellmanFordVisitor.edge_relaxed" title="Permalink to this definition">¶</a></dt>
<dd><p>This is invoked when the distance label for the target vertex is
decreased. The edge (u,v) that participated in the last relaxation for
vertex v is an edge in the shortest paths tree.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.search.BellmanFordVisitor.edge_not_relaxed">
<code class="descname">edge_not_relaxed</code><span class="sig-paren">(</span><em>e</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/search.html#BellmanFordVisitor.edge_not_relaxed"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.search.BellmanFordVisitor.edge_not_relaxed" title="Permalink to this definition">¶</a></dt>
<dd><p>This is invoked if the distance label for the target vertex is not
decreased.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.search.BellmanFordVisitor.edge_minimized">
<code class="descname">edge_minimized</code><span class="sig-paren">(</span><em>e</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/search.html#BellmanFordVisitor.edge_minimized"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.search.BellmanFordVisitor.edge_minimized" title="Permalink to this definition">¶</a></dt>
<dd><p>This is invoked during the second stage of the algorithm, during the
test of whether each edge was minimized. If the edge is minimized then
this function is invoked.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.search.BellmanFordVisitor.edge_not_minimized">
<code class="descname">edge_not_minimized</code><span class="sig-paren">(</span><em>e</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/search.html#BellmanFordVisitor.edge_not_minimized"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.search.BellmanFordVisitor.edge_not_minimized" title="Permalink to this definition">¶</a></dt>
<dd><p>This is invoked during the second stage of the algorithm, during the
test of whether each edge was minimized. If the edge was not minimized,
this function is invoked. This happens when there is a negative cycle in
the graph.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="graph_tool.search.bellman_ford_search">
<code class="descclassname">graph_tool.search.</code><code class="descname">bellman_ford_search</code><span class="sig-paren">(</span><em>g</em>, <em>source</em>, <em>weight</em>, <em>visitor=&lt;graph_tool.search.BellmanFordVisitor object&gt;</em>, <em>dist_map=None</em>, <em>pred_map=None</em>, <em>combine=&lt;function &lt;lambda&gt;&gt;</em>, <em>compare=&lt;function &lt;lambda&gt;&gt;</em>, <em>zero=0</em>, <em>infinity=inf</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/search.html#bellman_ford_search"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.search.bellman_ford_search" title="Permalink to this definition">¶</a></dt>
<dd><p>Bellman-Ford traversal of a directed or undirected graph, with negative weights.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>g</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.Graph" title="graph_tool.Graph"><code class="xref py py-class docutils literal"><span class="pre">Graph</span></code></a></p>
<blockquote>
<div><p>Graph to be used.</p>
</div></blockquote>
<p><strong>source</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.Vertex" title="graph_tool.Vertex"><code class="xref py py-class docutils literal"><span class="pre">Vertex</span></code></a></p>
<blockquote>
<div><p>Source vertex.</p>
</div></blockquote>
<p><strong>weight</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal"><span class="pre">PropertyMap</span></code></a></p>
<blockquote>
<div><p>Edge property map with weight values.</p>
</div></blockquote>
<p><strong>visitor</strong> : <a class="reference internal" href="#graph_tool.search.DijkstraVisitor" title="graph_tool.search.DijkstraVisitor"><code class="xref py py-class docutils literal"><span class="pre">DijkstraVisitor</span></code></a> (optional, default: <code class="docutils literal"><span class="pre">DijkstraVisitor()</span></code>)</p>
<blockquote>
<div><p>A visitor object that is invoked at the event points inside the
algorithm. This should be a subclass of
<a class="reference internal" href="#graph_tool.search.DijkstraVisitor" title="graph_tool.search.DijkstraVisitor"><code class="xref py py-class docutils literal"><span class="pre">DijkstraVisitor</span></code></a>.</p>
</div></blockquote>
<p><strong>dist_map</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal"><span class="pre">PropertyMap</span></code></a> (optional, default: <code class="docutils literal"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>A vertex property map where the distances from the source will be
stored.</p>
</div></blockquote>
<p><strong>pred_map</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal"><span class="pre">PropertyMap</span></code></a> (optional, default: <code class="docutils literal"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>A vertex property map where the predecessor map will be
stored (must have value type &#8220;int&#8221;).</p>
</div></blockquote>
<p><strong>combine</strong> : binary function (optional, default: <code class="docutils literal"><span class="pre">lambda</span> <span class="pre">a,</span> <span class="pre">b:</span> <span class="pre">a</span> <span class="pre">+</span> <span class="pre">b</span></code>)</p>
<blockquote>
<div><p>This function is used to combine distances to compute the distance of a
path.</p>
</div></blockquote>
<p><strong>compare</strong> : binary function (optional, default: <code class="docutils literal"><span class="pre">lambda</span> <span class="pre">a,</span> <span class="pre">b:</span> <span class="pre">a</span> <span class="pre">&lt;</span> <span class="pre">b</span></code>)</p>
<blockquote>
<div><p>This function is use to compare distances to determine which vertex is
closer to the source vertex.</p>
</div></blockquote>
<p><strong>zero</strong> : int or float (optional, default: <code class="docutils literal"><span class="pre">0</span></code>)</p>
<blockquote>
<div><p>Value assumed to correspond to a distance of zero by the combine and
compare functions.</p>
</div></blockquote>
<p><strong>infinity</strong> : int or float (optional, default: <code class="docutils literal"><span class="pre">float('inf')</span></code>)</p>
<blockquote>
<div><p>Value assumed to correspond to a distance of infinity by the combine and
compare functions.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>minimized</strong> : bool</p>
<blockquote>
<div><p>True if all edges were successfully minimized, or False if there is a
negative loop in the graph.</p>
</div></blockquote>
<p><strong>dist_map</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal"><span class="pre">PropertyMap</span></code></a></p>
<blockquote>
<div><p>A vertex property map with the computed distances from the source.</p>
</div></blockquote>
<p><strong>pred_map</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal"><span class="pre">PropertyMap</span></code></a></p>
<blockquote class="last">
<div><p>A vertex property map with the predecessor tree.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#graph_tool.search.bfs_search" title="graph_tool.search.bfs_search"><code class="xref py py-obj docutils literal"><span class="pre">bfs_search</span></code></a></dt>
<dd>Breadth-first search</dd>
<dt><a class="reference internal" href="#graph_tool.search.dfs_search" title="graph_tool.search.dfs_search"><code class="xref py py-obj docutils literal"><span class="pre">dfs_search</span></code></a></dt>
<dd>Depth-first search</dd>
<dt><code class="xref py py-obj docutils literal"><span class="pre">dijsktra_search</span></code></dt>
<dd>Dijkstra search</dd>
<dt><a class="reference internal" href="#graph_tool.search.astar_search" title="graph_tool.search.astar_search"><code class="xref py py-obj docutils literal"><span class="pre">astar_search</span></code></a></dt>
<dd><span class="math">\(A^*\)</span> heuristic search</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The Bellman-Ford algorithm <a class="reference internal" href="#bellman-ford" id="id9">[bellman-ford]</a> solves the single-source shortest
paths problem for a graph with both positive and negative edge weights. If
you only need to solve the shortest paths problem for positive edge weights,
<a class="reference internal" href="#graph_tool.search.dijkstra_search" title="graph_tool.search.dijkstra_search"><code class="xref py py-func docutils literal"><span class="pre">dijkstra_search()</span></code></a> provides a more efficient
alternative. If all the edge weights are all equal, then
<a class="reference internal" href="#graph_tool.search.bfs_search" title="graph_tool.search.bfs_search"><code class="xref py py-func docutils literal"><span class="pre">bfs_search()</span></code></a> provides an even more efficient
alternative.</p>
<p>The Bellman-Ford algorithm proceeds by looping through all of the edges in
the graph, applying the relaxation operation to each edge. In the following
pseudo-code, <code class="docutils literal"><span class="pre">v</span></code> is a vertex adjacent to <code class="docutils literal"><span class="pre">u</span></code>, <code class="docutils literal"><span class="pre">w</span></code> maps edges to their
weight, and <code class="docutils literal"><span class="pre">d</span></code> is a distance map that records the length of the shortest
path to each vertex seen so far. <code class="docutils literal"><span class="pre">p</span></code> is a predecessor map which records
the parent of each vertex, which will ultimately be the parent in the
shortest paths tree</p>
<div class="highlight-python"><div class="highlight"><pre>RELAX(u, v, w, d, p)
  if (w(u,v) + d[u] &lt; d[v])
    d[v] := w(u,v) + d[u]       relax edge (u,v)
    p[v] := u
  else
    ...                         edge (u,v) is not relaxed
</pre></div>
</div>
<p>The algorithm repeats this loop <code class="docutils literal"><span class="pre">|V|</span></code> times after which it is guaranteed
that the distances to each vertex have been reduced to the minimum possible
unless there is a negative cycle in the graph. If there is a negative cycle,
then there will be edges in the graph that were not properly minimized. That
is, there will be edges <code class="docutils literal"><span class="pre">(u,v)</span></code> such that <code class="docutils literal"><span class="pre">w(u,v)</span> <span class="pre">+</span> <span class="pre">d[u]</span> <span class="pre">&lt;</span> <span class="pre">d[v]</span></code>. The
algorithm loops over the edges in the graph one final time to check if all
the edges were minimized, returning true if they were and returning false
otherwise.</p>
<div class="highlight-python"><div class="highlight"><pre>BELLMAN-FORD(G)
  for each vertex u in V
    d[u] := infinity
    p[u] := u
  end for
  for i := 1 to |V|-1
    for each edge (u,v) in E          examine edge (u,v)
      RELAX(u, v, w, d, p)
    end for
  end for
  for each edge (u,v) in E
    if (w(u,v) + d[u] &lt; d[v])
      return (false, , )              edge (u,v) was not minimized
    else
      ...                             edge (u,v) was minimized
  end for
  return (true, p, d)
</pre></div>
</div>
<p>The time complexity is <span class="math">\(O(V E)\)</span>.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="bellman-ford" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[bellman-ford]</td><td><em>(<a class="fn-backref" href="#id9">1</a>, <a class="fn-backref" href="#id10">2</a>)</em> R. Bellman, &#8220;On a routing problem&#8221;, Quarterly of Applied
Mathematics, 16(1):87-90, 1958.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="bellman-ford-bgl" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id11">[bellman-ford-bgl]</a></td><td><a class="reference external" href="http://www.boost.org/doc/libs/release/libs/graph/doc/bellman_ford_shortest.html">http://www.boost.org/doc/libs/release/libs/graph/doc/bellman_ford_shortest.html</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="bellman-ford-wikipedia" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id12">[bellman-ford-wikipedia]</a></td><td><a class="reference external" href="http://en.wikipedia.org/wiki/Bellman-Ford_algorithm">http://en.wikipedia.org/wiki/Bellman-Ford_algorithm</a></td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>We must define what should be done during the search by subclassing
<a class="reference internal" href="#graph_tool.search.BellmanFordVisitor" title="graph_tool.search.BellmanFordVisitor"><code class="xref py py-class docutils literal"><span class="pre">BellmanFordVisitor</span></code></a>, and specializing the
appropriate methods. In the following we will keep track of the edge
minimizations.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">VisitorExample</span><span class="p">(</span><span class="n">gt</span><span class="o">.</span><span class="n">BellmanFordVisitor</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

    <span class="k">def</span> <span class="nf">edge_minimized</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&quot;edge (</span><span class="si">%s</span><span class="s">, </span><span class="si">%s</span><span class="s">) has been minimized...&quot;</span> <span class="o">%</span> \
              <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">source</span><span class="p">()],</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">target</span><span class="p">()]))</span>

    <span class="k">def</span> <span class="nf">edge_not_minimized</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&quot;edge (</span><span class="si">%s</span><span class="s">, </span><span class="si">%s</span><span class="s">) has not been minimized...&quot;</span> <span class="o">%</span> \
              <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">source</span><span class="p">()],</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">target</span><span class="p">()]))</span>
</pre></div>
</div>
<p>With the above class defined, we can perform the Bellman-Ford search as
follows.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">nweight</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">copy_property</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nweight</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>   <span class="c"># include negative weight in edge (Carlos, Alice)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">minimized</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">pred</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">bellman_ford_search</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">nweight</span><span class="p">,</span> <span class="n">VisitorExample</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
<span class="go">edge (Bob, Eve) has been minimized...</span>
<span class="go">edge (Bob, Chuck) has been minimized...</span>
<span class="go">edge (Bob, Carlos) has been minimized...</span>
<span class="go">edge (Bob, Isaac) has been minimized...</span>
<span class="go">edge (Alice, Oscar) has been minimized...</span>
<span class="go">edge (Alice, Dave) has been minimized...</span>
<span class="go">edge (Alice, Carlos) has been minimized...</span>
<span class="go">edge (Carol, Eve) has been minimized...</span>
<span class="go">edge (Carol, Imothep) has been minimized...</span>
<span class="go">edge (Carlos, Eve) has been minimized...</span>
<span class="go">edge (Carlos, Imothep) has been minimized...</span>
<span class="go">edge (Chuck, Eve) has been minimized...</span>
<span class="go">edge (Chuck, Isaac) has been minimized...</span>
<span class="go">edge (Chuck, Imothep) has been minimized...</span>
<span class="go">edge (Dave, Oscar) has been minimized...</span>
<span class="go">edge (Eve, Isaac) has been minimized...</span>
<span class="go">edge (Eve, Imothep) has been minimized...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">minimized</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">pred</span><span class="o">.</span><span class="n">a</span><span class="p">)</span>
<span class="go">[3 3 9 1 6 1 3 6 1 3]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">dist</span><span class="o">.</span><span class="n">a</span><span class="p">)</span>
<span class="go">[-28.42555934 -37.34471821 -25.20438243 -41.97110592 -35.20316571</span>
<span class="go"> -34.02873843 -36.58860946 -33.55645565 -35.2199616  -36.0029274 ]</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="graph_tool.search.AStarVisitor">
<em class="property">class </em><code class="descclassname">graph_tool.search.</code><code class="descname">AStarVisitor</code><a class="reference internal" href="_modules/graph_tool/search.html#AStarVisitor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.search.AStarVisitor" title="Permalink to this definition">¶</a></dt>
<dd><p>A visitor object that is invoked at the event-points inside the
<a class="reference internal" href="#graph_tool.search.astar_search" title="graph_tool.search.astar_search"><code class="xref py py-func docutils literal"><span class="pre">astar_search()</span></code></a> algorithm. By default, it
performs no action, and should be used as a base class in order to be
useful.</p>
<dl class="method">
<dt id="graph_tool.search.AStarVisitor.initialize_vertex">
<code class="descname">initialize_vertex</code><span class="sig-paren">(</span><em>u</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/search.html#AStarVisitor.initialize_vertex"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.search.AStarVisitor.initialize_vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>This is invoked on every vertex of the graph before the start of the
graph search.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.search.AStarVisitor.examine_vertex">
<code class="descname">examine_vertex</code><span class="sig-paren">(</span><em>u</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/search.html#AStarVisitor.examine_vertex"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.search.AStarVisitor.examine_vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>This is invoked on a vertex as it is popped from the queue (i.e. it
has the lowest cost on the <code class="docutils literal"><span class="pre">OPEN</span></code> list). This happens immediately
before examine_edge() is invoked on each of the out-edges of vertex u.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.search.AStarVisitor.examine_edge">
<code class="descname">examine_edge</code><span class="sig-paren">(</span><em>e</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/search.html#AStarVisitor.examine_edge"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.search.AStarVisitor.examine_edge" title="Permalink to this definition">¶</a></dt>
<dd><p>This is invoked on every out-edge of each vertex after it is examined.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.search.AStarVisitor.discover_vertex">
<code class="descname">discover_vertex</code><span class="sig-paren">(</span><em>u</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/search.html#AStarVisitor.discover_vertex"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.search.AStarVisitor.discover_vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>This is invoked when a vertex is first discovered and is added to the
<code class="docutils literal"><span class="pre">OPEN</span></code> list.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.search.AStarVisitor.edge_relaxed">
<code class="descname">edge_relaxed</code><span class="sig-paren">(</span><em>e</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/search.html#AStarVisitor.edge_relaxed"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.search.AStarVisitor.edge_relaxed" title="Permalink to this definition">¶</a></dt>
<dd><p>Upon examination, if the following condition holds then the edge is
relaxed (its distance is reduced), and this method is invoked.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
<span class="k">assert</span><span class="p">(</span><span class="n">compare</span><span class="p">(</span><span class="n">combine</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="n">weight</span><span class="p">[</span><span class="n">e</span><span class="p">]),</span> <span class="n">d</span><span class="p">[</span><span class="n">v</span><span class="p">]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="graph_tool.search.AStarVisitor.edge_not_relaxed">
<code class="descname">edge_not_relaxed</code><span class="sig-paren">(</span><em>e</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/search.html#AStarVisitor.edge_not_relaxed"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.search.AStarVisitor.edge_not_relaxed" title="Permalink to this definition">¶</a></dt>
<dd><p>Upon examination, if the edge is not relaxed (see
<a class="reference internal" href="#graph_tool.search.AStarVisitor.edge_relaxed" title="graph_tool.search.AStarVisitor.edge_relaxed"><code class="xref py py-meth docutils literal"><span class="pre">edge_relaxed()</span></code></a>) then this
method is invoked.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.search.AStarVisitor.black_target">
<code class="descname">black_target</code><span class="sig-paren">(</span><em>e</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/search.html#AStarVisitor.black_target"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.search.AStarVisitor.black_target" title="Permalink to this definition">¶</a></dt>
<dd><p>This is invoked when a vertex that is on the <code class="docutils literal"><span class="pre">CLOSED</span></code> list is
&#8220;rediscovered&#8221; via a more efficient path, and is re-added to the
<code class="docutils literal"><span class="pre">OPEN</span></code> list.</p>
</dd></dl>

<dl class="method">
<dt id="graph_tool.search.AStarVisitor.finish_vertex">
<code class="descname">finish_vertex</code><span class="sig-paren">(</span><em>u</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/search.html#AStarVisitor.finish_vertex"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.search.AStarVisitor.finish_vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>This is invoked on a vertex when it is added to the CLOSED list,
which happens after all of its out edges have been examined.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="graph_tool.search.astar_search">
<code class="descclassname">graph_tool.search.</code><code class="descname">astar_search</code><span class="sig-paren">(</span><em>g</em>, <em>source</em>, <em>weight</em>, <em>visitor=&lt;graph_tool.search.AStarVisitor object&gt;</em>, <em>heuristic=&lt;function &lt;lambda&gt;&gt;</em>, <em>dist_map=None</em>, <em>pred_map=None</em>, <em>cost_map=None</em>, <em>combine=&lt;function &lt;lambda&gt;&gt;</em>, <em>compare=&lt;function &lt;lambda&gt;&gt;</em>, <em>zero=0</em>, <em>infinity=inf</em>, <em>implicit=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/graph_tool/search.html#astar_search"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.search.astar_search" title="Permalink to this definition">¶</a></dt>
<dd><p>Heuristic <span class="math">\(A^*\)</span> search on a weighted, directed or undirected graph for the case where all edge weights are non-negative.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>g</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.Graph" title="graph_tool.Graph"><code class="xref py py-class docutils literal"><span class="pre">Graph</span></code></a></p>
<blockquote>
<div><p>Graph to be used.</p>
</div></blockquote>
<p><strong>source</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.Vertex" title="graph_tool.Vertex"><code class="xref py py-class docutils literal"><span class="pre">Vertex</span></code></a></p>
<blockquote>
<div><p>Source vertex.</p>
</div></blockquote>
<p><strong>weight</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal"><span class="pre">PropertyMap</span></code></a></p>
<blockquote>
<div><p>Edge property map with weight values.</p>
</div></blockquote>
<p><strong>visitor</strong> : <a class="reference internal" href="#graph_tool.search.AStarVisitor" title="graph_tool.search.AStarVisitor"><code class="xref py py-class docutils literal"><span class="pre">AStarVisitor</span></code></a> (optional, default: <code class="docutils literal"><span class="pre">AStarVisitor()</span></code>)</p>
<blockquote>
<div><p>A visitor object that is invoked at the event points inside the
algorithm. This should be a subclass of
<a class="reference internal" href="#graph_tool.search.AStarVisitor" title="graph_tool.search.AStarVisitor"><code class="xref py py-class docutils literal"><span class="pre">AStarVisitor</span></code></a>.</p>
</div></blockquote>
<p><strong>heuristic</strong> : unary function (optional, default: <code class="docutils literal"><span class="pre">lambda</span> <span class="pre">v:</span> <span class="pre">1</span></code>)</p>
<blockquote>
<div><p>The heuristic function that guides the search. It should take a single
argument which is a <a class="reference internal" href="graph_tool.html#graph_tool.Vertex" title="graph_tool.Vertex"><code class="xref py py-class docutils literal"><span class="pre">Vertex</span></code></a>, and output an estimated
distance from the supplied vertex to the target vertex.</p>
</div></blockquote>
<p><strong>dist_map</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal"><span class="pre">PropertyMap</span></code></a> (optional, default: <code class="docutils literal"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>A vertex property map where the distances from the source will be
stored.</p>
</div></blockquote>
<p><strong>pred_map</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal"><span class="pre">PropertyMap</span></code></a> (optional, default: <code class="docutils literal"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>A vertex property map where the predecessor map will be
stored (must have value type &#8220;int&#8221;).</p>
</div></blockquote>
<p><strong>cost_map</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal"><span class="pre">PropertyMap</span></code></a> (optional, default: <code class="docutils literal"><span class="pre">None</span></code>)</p>
<blockquote>
<div><p>A vertex property map where the vertex costs will be stored. It must
have the same value type as <code class="docutils literal"><span class="pre">dist_map</span></code>. This parameter is only used if
<code class="docutils literal"><span class="pre">implicit</span></code> is True.</p>
</div></blockquote>
<p><strong>combine</strong> : binary function (optional, default: <code class="docutils literal"><span class="pre">lambda</span> <span class="pre">a,</span> <span class="pre">b:</span> <span class="pre">a</span> <span class="pre">+</span> <span class="pre">b</span></code>)</p>
<blockquote>
<div><p>This function is used to combine distances to compute the distance of a
path.</p>
</div></blockquote>
<p><strong>compare</strong> : binary function (optional, default: <code class="docutils literal"><span class="pre">lambda</span> <span class="pre">a,</span> <span class="pre">b:</span> <span class="pre">a</span> <span class="pre">&lt;</span> <span class="pre">b</span></code>)</p>
<blockquote>
<div><p>This function is use to compare distances to determine which vertex is
closer to the source vertex.</p>
</div></blockquote>
<p><strong>implicit</strong> : bool (optional, default: <code class="docutils literal"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>If true, the underlying graph will be assumed to be implicit
(i.e. constructed during the search).</p>
</div></blockquote>
<p><strong>zero</strong> : int or float (optional, default: <code class="docutils literal"><span class="pre">0</span></code>)</p>
<blockquote>
<div><p>Value assumed to correspond to a distance of zero by the combine and
compare functions.</p>
</div></blockquote>
<p><strong>infinity</strong> : int or float (optional, default: <code class="docutils literal"><span class="pre">float('inf')</span></code>)</p>
<blockquote>
<div><p>Value assumed to correspond to a distance of infinity by the combine and
compare functions.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dist_map</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal"><span class="pre">PropertyMap</span></code></a></p>
<blockquote>
<div><p>A vertex property map with the computed distances from the source.</p>
</div></blockquote>
<p><strong>pred_map</strong> : <a class="reference internal" href="graph_tool.html#graph_tool.PropertyMap" title="graph_tool.PropertyMap"><code class="xref py py-class docutils literal"><span class="pre">PropertyMap</span></code></a></p>
<blockquote class="last">
<div><p>A vertex property map with the predecessor tree.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#graph_tool.search.bfs_search" title="graph_tool.search.bfs_search"><code class="xref py py-obj docutils literal"><span class="pre">bfs_search</span></code></a></dt>
<dd>Breadth-first search</dd>
<dt><a class="reference internal" href="#graph_tool.search.dfs_search" title="graph_tool.search.dfs_search"><code class="xref py py-obj docutils literal"><span class="pre">dfs_search</span></code></a></dt>
<dd>Depth-first search</dd>
<dt><a class="reference internal" href="#graph_tool.search.dijkstra_search" title="graph_tool.search.dijkstra_search"><code class="xref py py-obj docutils literal"><span class="pre">dijkstra_search</span></code></a></dt>
<dd>Dijkstra&#8217;s search algorithm</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The <span class="math">\(A^*\)</span> algorithm is a heuristic graph search algorithm: an
<span class="math">\(A^*\)</span> search is &#8220;guided&#8221; by a heuristic function. A heuristic function
<span class="math">\(h(v)\)</span> is one which estimates the cost from a non-goal state (v) in
the graph to some goal state, t. Intuitively, <span class="math">\(A^*\)</span> follows paths
(through the graph) to the goal that are estimated by the heuristic function
to be the best paths. Unlike best-first search, <span class="math">\(A^*\)</span> takes into
account the known cost from the start of the search to v; the paths
<span class="math">\(A^*\)</span> takes are guided by a function <span class="math">\(f(v) = g(v) + h(v)\)</span>, where
<span class="math">\(h(v)\)</span> is the heuristic function, and <span class="math">\(g(v)\)</span> (sometimes denoted
<span class="math">\(c(s, v)\)</span>) is the known cost from the start to v. Clearly, the
efficiency of <span class="math">\(A^*\)</span> is highly dependent on the heuristic function with
which it is used.</p>
<p>The time complexity is <span class="math">\(O((E + V) \log V)\)</span>.</p>
<p>The pseudo-code for the <span class="math">\(A^*\)</span> algorithm is listed below, with the
annotated event points, for which the given visitor object will be called
with the appropriate method.</p>
<div class="highlight-python"><div class="highlight"><pre>A*(G, source, h)
  for each vertex u in V                 initialize vertex u
    d[u] := f[u] := infinity
    color[u] := WHITE
  end for
  color[s] := GRAY
  d[s] := 0
  f[s] := h(source)
  INSERT(Q, source)                      discover vertex source
  while (Q != Ø)
    u := EXTRACT-MIN(Q)                  examine vertex u
    for each vertex v in Adj[u]          examine edge (u,v)
      if (w(u,v) + d[u] &lt; d[v])
        d[v] := w(u,v) + d[u]            edge (u,v) relaxed
        f[v] := d[v] + h(v)
        if (color[v] = WHITE)
          color[v] := GRAY
          INSERT(Q, v)                   discover vertex v
        else if (color[v] = BLACK)
          color[v] := GRAY
          INSERT(Q, v)                   reopen vertex v
        end if
      else
        ...                              edge (u,v) not relaxed
    end for
    color[u] := BLACK                    finish vertex u
  end while
</pre></div>
</div>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="astar" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id13">[astar]</a></td><td>Hart, P. E.; Nilsson, N. J.; Raphael, B. &#8220;A Formal Basis for the
Heuristic Determination of Minimum Cost Paths&#8221;. IEEE Transactions on
Systems Science and Cybernetics SSC4 4 (2): 100-107, 1968.
<a class="reference external" href="http://dx.doi.org/10.1109/TSSC.1968.300136">DOI: 10.1109/TSSC.1968.300136</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="astar-bgl" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id14">[astar-bgl]</a></td><td><a class="reference external" href="http://www.boost.org/doc/libs/release/libs/graph/doc/astar_search.html">http://www.boost.org/doc/libs/release/libs/graph/doc/astar_search.html</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="astar-wikipedia" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id15">[astar-wikipedia]</a></td><td><a class="reference external" href="http://en.wikipedia.org/wiki/A*_search_algorithm">http://en.wikipedia.org/wiki/A*_search_algorithm</a></td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>We will use an irregular two-dimensional lattice as an example, where the
heuristic function will be based on the euclidean distance to the target.</p>
<p>The heuristic function will be defined as:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">h</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">pos</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">sqrt</span><span class="p">(</span><span class="nb">sum</span><span class="p">((</span><span class="n">pos</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">a</span> <span class="o">-</span> <span class="n">pos</span><span class="p">[</span><span class="n">target</span><span class="p">]</span><span class="o">.</span><span class="n">a</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">pos</span></code> is the vertex position in the plane.</p>
<p>We must define what should be done during the search by subclassing
<a class="reference internal" href="#graph_tool.search.AStarVisitor" title="graph_tool.search.AStarVisitor"><code class="xref py py-class docutils literal"><span class="pre">AStarVisitor</span></code></a>, and specializing the appropriate
methods. In the following we will keep track of the discovered vertices, and
which edges were examined, as well as the predecessor tree. We will also
abort the search when a given target vertex is found, by raising the
<a class="reference internal" href="#graph_tool.search.StopSearch" title="graph_tool.search.StopSearch"><code class="xref py py-class docutils literal"><span class="pre">StopSearch</span></code></a> exception.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">VisitorExample</span><span class="p">(</span><span class="n">gt</span><span class="o">.</span><span class="n">AStarVisitor</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">touched_v</span><span class="p">,</span> <span class="n">touched_e</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">touched_v</span> <span class="o">=</span> <span class="n">touched_v</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">touched_e</span> <span class="o">=</span> <span class="n">touched_e</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target</span> <span class="o">=</span> <span class="n">target</span>

    <span class="k">def</span> <span class="nf">discover_vertex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">touched_v</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">examine_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">touched_e</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">edge_relaxed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">target</span><span class="p">()</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">gt</span><span class="o">.</span><span class="n">StopSearch</span><span class="p">()</span>
</pre></div>
</div>
<p>With the above class defined, we can perform the <span class="math">\(A^*\)</span> search as
follows.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">points</span> <span class="o">=</span> <span class="n">random</span><span class="p">((</span><span class="mi">500</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="o">*</span> <span class="mi">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mf">4.01</span><span class="p">,</span> <span class="mf">4.01</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="p">,</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">triangulation</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s">&quot;delaunay&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">weight</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_edge_property</span><span class="p">(</span><span class="s">&quot;double&quot;</span><span class="p">)</span> <span class="c"># Edge weights corresponding to</span>
<span class="gp">... </span>                                       <span class="c"># Euclidean distances</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
<span class="gp">... </span>   <span class="n">weight</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="nb">sum</span><span class="p">((</span><span class="n">pos</span><span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">source</span><span class="p">()]</span><span class="o">.</span><span class="n">a</span> <span class="o">-</span>
<span class="gp">... </span>                         <span class="n">pos</span><span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">target</span><span class="p">()]</span><span class="o">.</span><span class="n">a</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">touch_v</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="s">&quot;bool&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">touch_e</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_edge_property</span><span class="p">(</span><span class="s">&quot;bool&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">target</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dist</span><span class="p">,</span> <span class="n">pred</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">astar_search</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">weight</span><span class="p">,</span>
<span class="gp">... </span>                             <span class="n">VisitorExample</span><span class="p">(</span><span class="n">touch_v</span><span class="p">,</span> <span class="n">touch_e</span><span class="p">,</span> <span class="n">target</span><span class="p">),</span>
<span class="gp">... </span>                             <span class="n">heuristic</span><span class="o">=</span><span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="n">h</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">pos</span><span class="p">))</span>
</pre></div>
</div>
<p>We can now observe the best path found, and how many vertices and edges were
visited in the process.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">ecolor</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_edge_property</span><span class="p">(</span><span class="s">&quot;string&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ewidth</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_edge_property</span><span class="p">(</span><span class="s">&quot;double&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ewidth</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
<span class="gp">... </span>   <span class="n">ecolor</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;#3465a4&quot;</span> <span class="k">if</span> <span class="n">touch_e</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="k">else</span> <span class="s">&quot;#d3d7cf&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">target</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">while</span> <span class="n">v</span> <span class="o">!=</span> <span class="n">g</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="mi">0</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">p</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="n">pred</span><span class="p">[</span><span class="n">v</span><span class="p">])</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">out_edges</span><span class="p">():</span>
<span class="gp">... </span>        <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">target</span><span class="p">()</span> <span class="o">==</span> <span class="n">p</span><span class="p">:</span>
<span class="gp">... </span>            <span class="n">ecolor</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;#a40000&quot;</span>
<span class="gp">... </span>            <span class="n">ewidth</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">... </span>    <span class="n">v</span> <span class="o">=</span> <span class="n">p</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gt</span><span class="o">.</span><span class="n">graph_draw</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span> <span class="n">output_size</span><span class="o">=</span><span class="p">(</span><span class="mi">300</span><span class="p">,</span> <span class="mi">300</span><span class="p">),</span> <span class="n">vertex_fill_color</span><span class="o">=</span><span class="n">touch_v</span><span class="p">,</span>
<span class="gp">... </span>              <span class="n">vcmap</span><span class="o">=</span><span class="n">matplotlib</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">binary</span><span class="p">,</span> <span class="n">edge_color</span><span class="o">=</span><span class="n">ecolor</span><span class="p">,</span>
<span class="gp">... </span>              <span class="n">edge_pen_width</span><span class="o">=</span><span class="n">ewidth</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s">&quot;astar-delaunay.pdf&quot;</span><span class="p">)</span>
<span class="go">&lt;...&gt;</span>
</pre></div>
</div>
<div class="figure align-center" id="id17">
<img alt="_images/astar-delaunay.png" src="_images/astar-delaunay.png" />
<p class="caption"><span class="caption-text">The shortest path is shown in red. The visited edges are shown in blue,
and the visited vertices in black.</span></p>
</div>
<p>The <span class="math">\(A^*\)</span> algorithm is very useful for searching <em>implicit</em> graphs,
i.e. graphs which are not entirely stored in memory and are generated
&#8220;on-the-fly&#8221; during the search. In the following example we will carry out a
search in a hamming hypercube of 10 bits witch has random weights on its
edges in the range <span class="math">\([0,1]\)</span>. The vertices of the hypercube will be
created during the search.</p>
<p>The heuristic function will use the Hamming distance between vertices:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">h</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">state</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">a</span> <span class="o">-</span> <span class="n">target</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span>
</pre></div>
</div>
<p>In the following visitor we will keep growing the graph on-the-fly, and
abort the search when a given target vertex is found, by raising the
<a class="reference internal" href="#graph_tool.search.StopSearch" title="graph_tool.search.StopSearch"><code class="xref py py-class docutils literal"><span class="pre">StopSearch</span></code></a> exception.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">numpy.random</span> <span class="kn">import</span> <span class="n">random</span>

<span class="k">class</span> <span class="nc">HammingVisitor</span><span class="p">(</span><span class="n">gt</span><span class="o">.</span><span class="n">AStarVisitor</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">cost</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">g</span> <span class="o">=</span> <span class="n">g</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target</span> <span class="o">=</span> <span class="n">target</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weight</span> <span class="o">=</span> <span class="n">weight</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist</span> <span class="o">=</span> <span class="n">dist</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cost</span> <span class="o">=</span> <span class="n">cost</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">visited</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">examine_vertex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">u</span><span class="p">])):</span>
            <span class="n">nstate</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">u</span><span class="p">])</span>
            <span class="n">nstate</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">^=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">nstate</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">visited</span><span class="p">:</span>
                <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visited</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">nstate</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">visited</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">nstate</span><span class="p">)]</span> <span class="o">=</span> <span class="n">v</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">nstate</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cost</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s">&#39;inf&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">u</span><span class="o">.</span><span class="n">out_edges</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">target</span><span class="p">()</span> <span class="o">==</span> <span class="n">v</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">e</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="n">random</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">visited</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">u</span><span class="p">])]</span> <span class="o">=</span> <span class="n">u</span>

    <span class="k">def</span> <span class="nf">edge_relaxed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">target</span><span class="p">()]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">visited</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">)]</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">target</span><span class="p">()</span>
            <span class="k">raise</span> <span class="n">gt</span><span class="o">.</span><span class="n">StopSearch</span><span class="p">()</span>
</pre></div>
</div>
<p>With the above class defined, we can perform the <span class="math">\(A^*\)</span> search as
follows.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">directed</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="s">&quot;vector&lt;bool&gt;&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">target</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">weight</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_edge_property</span><span class="p">(</span><span class="s">&quot;double&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dist</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="s">&quot;double&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cost</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="s">&quot;double&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">visitor</span> <span class="o">=</span> <span class="n">HammingVisitor</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">cost</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dist</span><span class="p">,</span> <span class="n">pred</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">astar_search</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">weight</span><span class="p">,</span> <span class="n">visitor</span><span class="p">,</span> <span class="n">dist_map</span><span class="o">=</span><span class="n">dist</span><span class="p">,</span>
<span class="gp">... </span>                             <span class="n">cost_map</span><span class="o">=</span><span class="n">cost</span><span class="p">,</span> <span class="n">heuristic</span><span class="o">=</span><span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="n">h</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">array</span><span class="p">(</span><span class="n">target</span><span class="p">),</span> <span class="n">state</span><span class="p">),</span>
<span class="gp">... </span>                             <span class="n">implicit</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>We can now observe the best path found, and how many vertices and edges were
visited in the process.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">ecolor</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_edge_property</span><span class="p">(</span><span class="s">&quot;string&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vcolor</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_vertex_property</span><span class="p">(</span><span class="s">&quot;string&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ewidth</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">new_edge_property</span><span class="p">(</span><span class="s">&quot;double&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ewidth</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
<span class="gp">... </span>   <span class="n">ecolor</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;black&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">vertices</span><span class="p">():</span>
<span class="gp">... </span>   <span class="n">vcolor</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;white&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">visitor</span><span class="o">.</span><span class="n">visited</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">target</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">while</span> <span class="n">v</span> <span class="o">!=</span> <span class="n">g</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="mi">0</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">vcolor</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;black&quot;</span>
<span class="gp">... </span>    <span class="n">p</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">vertex</span><span class="p">(</span><span class="n">pred</span><span class="p">[</span><span class="n">v</span><span class="p">])</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">out_edges</span><span class="p">():</span>
<span class="gp">... </span>        <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">target</span><span class="p">()</span> <span class="o">==</span> <span class="n">p</span><span class="p">:</span>
<span class="gp">... </span>            <span class="n">ecolor</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;#a40000&quot;</span>
<span class="gp">... </span>            <span class="n">ewidth</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">... </span>    <span class="n">v</span> <span class="o">=</span> <span class="n">p</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vcolor</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;black&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pos</span> <span class="o">=</span> <span class="n">gt</span><span class="o">.</span><span class="n">graph_draw</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">output_size</span><span class="o">=</span><span class="p">(</span><span class="mi">300</span><span class="p">,</span> <span class="mi">300</span><span class="p">),</span> <span class="n">vertex_fill_color</span><span class="o">=</span><span class="n">vcolor</span><span class="p">,</span> <span class="n">edge_color</span><span class="o">=</span><span class="n">ecolor</span><span class="p">,</span>
<span class="gp">... </span>                    <span class="n">edge_pen_width</span><span class="o">=</span><span class="n">ewidth</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s">&quot;astar-implicit.pdf&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="figure align-center" id="id18">
<img alt="_images/astar-implicit.png" src="_images/astar-implicit.png" />
<p class="caption"><span class="caption-text">The shortest path is shown in red, and the vertices which belong to it
are in black. Note that the number of vertices visited is much smaller
than the total number <span class="math">\(2^{10} = 1024\)</span>.</span></p>
</div>
</dd></dl>

<dl class="exception">
<dt id="graph_tool.search.StopSearch">
<em class="property">exception </em><code class="descclassname">graph_tool.search.</code><code class="descname">StopSearch</code><a class="reference internal" href="_modules/graph_tool/search.html#StopSearch"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graph_tool.search.StopSearch" title="Permalink to this definition">¶</a></dt>
<dd><p>If this exception is raised from inside any search visitor object, the search is aborted.</p>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="docutils literal"><span class="pre">graph_tool.search</span></code> - Search algorithms</a><ul>
<li><a class="reference internal" href="#summary">Summary</a></li>
<li><a class="reference internal" href="#examples">Examples</a></li>
<li><a class="reference internal" href="#contents">Contents</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="run_action.html"
                        title="previous chapter"><code class="docutils literal"><span class="pre">graph_tool.run_action</span></code> - Inline C++ code embedding</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="spectral.html"
                        title="next chapter"><code class="docutils literal"><span class="pre">graph_tool.spectral</span></code> - Spectral properties</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/search_module.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>

<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
<!-- <a href="graph-tool.pdf">(Download PDF version)</a> -->

<p/>
Latest <a href="/doc/dev/">development version docs</a> are also available.

        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="spectral.html" title="graph_tool.spectral - Spectral properties"
             >next</a> |</li>
        <li class="right" >
          <a href="run_action.html" title="graph_tool.run_action - Inline C++ code embedding"
             >previous</a> |</li>
    <li><img src="_static/graph-icon.png" alt="logo" style="margin-right: 5px; margin-bottom:-2px;" /><a href="/">Project Homepage</a> &raquo;</li>
    
        <li class="nav-item nav-item-0"><a href="index.html">graph-tool 2.2.44 documentation</a> &raquo;</li>

          <li class="nav-item nav-item-1"><a href="modules.html" >Module documentation</a> &raquo;</li>
          <li class="nav-item nav-item-2"><a href="graph_tool.html" >graph_tool - efficient graph analysis and manipulation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2015, Tiago de Paula Peixoto &lt;tiago@skewed.de&gt;.
      Last updated on Jul 02, 2015.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
  </body>
</html>